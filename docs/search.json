[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "Albert Joon Park",
    "section": "",
    "text": "Albert Joonyoung Park is an aspiring and dedicated independent data analyst with a diverse background spanning entrepreneurship, eCommerce, manufacturing operations, and database application development. With a strong focus on delivering valuable insights, he collaborates closely with clients to extract meaningful information from diverse datasets across various industries. Additionally, Albert has recently ventured into mortgage brokering, aiming to leverage his data skills to assist individuals in identifying optimal financial solutions tailored to their specific needs. Beyond his professional pursuits, Albert finds joy in spending quality time with his spouse, continuously expanding his expertise in data science, actively participating in the church choir, and honing his piano-playing skills."
  },
  {
    "objectID": "blog.html",
    "href": "blog.html",
    "title": "Blog Posts",
    "section": "",
    "text": "[3] Built-In Data Structures, Functions, and Files\n\n\nA series of posts, exploring data analysis using the book - Python for Data Analysis, 3E by Wes McKinney\n\n\n\n\n\n\nSeptember 11, 2023\n\n\n19 min\n\n\n\n\n\n\n  \n\n\n\n\nExploring Polar Coordinate Plot in Python Using Matplotlib\n\n\nMetplotlib - Polar coordinate plot.\n\n\n\n\n\n\nAugust 22, 2023\n\n\n3 min\n\n\n\n\n\n\n  \n\n\n\n\nPython Setup in R with Reticulate\n\n\nMetplotlib - Polar coordinate plot.\n\n\n\n\n\n\nAugust 22, 2023\n\n\n2 min\n\n\n\n\n\n\n  \n\n\n\n\nA Demo Blog Post Using Quarto\n\n\nWhat Quarto can do for your blog posts.\n\n\n\n\n\n\nJune 1, 2022\n\n\n4 min\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Greetings from Albert Joonyoung Park",
    "section": "",
    "text": "Welcome to my personal website, where I share my selected examples and blogs on data analysis. The primary aim is to share my enriching journey in data analysis and its multitude of benefits. When data is harnessed and interpreted effectively, it has the remarkable ability to reveal concealed paths that guide decision-making, be it in our personal lives or the business world. To fully unlock its potential, I invite you to don your\"Curiosity Hat\" and explore the stories that lie within the data. Brace yourself, for the results have the potential to transcend mere significance—they possess the inherent power to shape and transform.\n  \n  \n  \n    Albert Joonyoung Park"
  },
  {
    "objectID": "posts/my-first-blog.html",
    "href": "posts/my-first-blog.html",
    "title": "A Demo Blog Post Using Quarto",
    "section": "",
    "text": "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nam suscipit est nec dui eleifend, at dictum elit ullamcorper. Aliquam feugiat dictum bibendum. Praesent fermentum laoreet quam, cursus volutpat odio dapibus in. Fusce luctus porttitor vehicula. Donec ac tortor nisi. Donec at lectus tortor. Morbi tempor, nibh non euismod viverra, metus arcu aliquet elit, sed fringilla urna leo vel purus.\n\n\nLorem ipsum dolor sit amet, consectetur adipiscing elit. Nam suscipit est nec dui eleifend, at dictum elit ullamcorper. Aliquam feugiat dictum bibendum. Praesent fermentum laoreet quam, cursus volutpat odio dapibus in. Fusce luctus porttitor vehicula. Donec ac tortor nisi. Donec at lectus tortor. Morbi tempor, nibh non euismod viverra, metus arcu aliquet elit, sed fringilla urna leo vel purus.\n\n\nThis is inline code plus a small code chunk.\n\nlibrary(tidyverse)\n\nggplot(mpg) +\n    geom_jitter(aes(cty, hwy), size = 4, alpha = 0.5)\n\n\n\n\n\n\n\n\nTransforming OLS estimatesMaximizing likelihood\n\n\n\n\nCode\npreds_lm %&gt;%\n    ggplot(aes(body_mass_g, bill_length_mm, col = correct)) +\n    geom_jitter(size = 4, alpha = 0.6) +\n    facet_wrap(vars(species)) +\n    scale_color_manual(values = c(\"grey60\", thematic::okabe_ito(3)[3])) +\n    scale_x_continuous(breaks = seq(3000, 6000, 1000)) +\n    theme_minimal(base_size = 12) +\n    theme(\n        legend.position = \"top\",\n        panel.background = element_rect(color = \"black\"),\n        panel.grid.minor = element_blank()\n    ) +\n    labs(\n        x = \"Body mass (in g)\",\n        y = \"Bill length (in mm)\"\n    )\n\n\n\n\n\n\n\n\n\nCode\nglm.mod &lt;- glm(sex ~ body_mass_g + bill_length_mm + species, family = binomial, data = dat)\n\npreds &lt;- dat %&gt;% \n  mutate(\n    prob.fit = glm.mod$fitted.values,\n    prediction = if_else(prob.fit &gt; 0.5, 'male', 'female'),\n    correct = if_else(sex == prediction, 'correct', 'incorrect')\n  )\n\n\npreds %&gt;% \n  ggplot(aes(body_mass_g, bill_length_mm, col = correct)) +\n  geom_jitter(size = 4, alpha = 0.6) +\n  facet_wrap(vars(species)) +\n  scale_x_continuous(breaks = seq(3000, 6000, 1000)) +\n  scale_color_manual(values = c('grey60', thematic::okabe_ito(3)[3])) +\n  theme_minimal(base_size = 10) +\n  theme(\n    legend.position = 'top', \n    panel.background = element_rect(color = 'black'),\n    panel.grid.minor = element_blank()\n  ) +\n  labs(\n    x = 'Body mass (in g)',\n    y = 'Bill length (in mm)'\n  )\n\n\n\n\n\n\n\n\n\n\n\n\\int_0^1 f(x) \\ dx\n\n\n\n\n\n\n\n\n\ngeom_density(\n  mapping = NULL,\n  data = NULL,\n  stat = \"density\",\n  position = \"identity\",\n  ...,\n  na.rm = FALSE,\n  orientation = NA,\n  show.legend = NA,\n  inherit.aes = TRUE,\n  outline.type = \"upper\"\n)\n\n\nstat_density(\n  mapping = NULL,\n  data = NULL,\n  geom = \"area\",\n  position = \"stack\",\n  ...,\n  bw = \"nrd0\",\n  adjust = 1,\n  kernel = \"gaussian\",\n  n = 512,\n  trim = FALSE,\n  na.rm = FALSE,\n  orientation = NA,\n  show.legend = NA,\n  inherit.aes = TRUE\n)\n\n\n\n\n\n\n\nggplot(data = gapminder::gapminder, mapping = aes(x = lifeExp, fill = continent)) +\n    stat_density(position = \"identity\", alpha = 0.5)\n\n\n\n\nBla bla bla. This is a caption in the margin. Super cool isn’t it?"
  },
  {
    "objectID": "posts/my-first-blog.html#merriweather",
    "href": "posts/my-first-blog.html#merriweather",
    "title": "A Demo Blog Post Using Quarto",
    "section": "",
    "text": "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nam suscipit est nec dui eleifend, at dictum elit ullamcorper. Aliquam feugiat dictum bibendum. Praesent fermentum laoreet quam, cursus volutpat odio dapibus in. Fusce luctus porttitor vehicula. Donec ac tortor nisi. Donec at lectus tortor. Morbi tempor, nibh non euismod viverra, metus arcu aliquet elit, sed fringilla urna leo vel purus.\n\n\nThis is inline code plus a small code chunk.\n\nlibrary(tidyverse)\n\nggplot(mpg) +\n    geom_jitter(aes(cty, hwy), size = 4, alpha = 0.5)\n\n\n\n\n\n\n\n\nTransforming OLS estimatesMaximizing likelihood\n\n\n\n\nCode\npreds_lm %&gt;%\n    ggplot(aes(body_mass_g, bill_length_mm, col = correct)) +\n    geom_jitter(size = 4, alpha = 0.6) +\n    facet_wrap(vars(species)) +\n    scale_color_manual(values = c(\"grey60\", thematic::okabe_ito(3)[3])) +\n    scale_x_continuous(breaks = seq(3000, 6000, 1000)) +\n    theme_minimal(base_size = 12) +\n    theme(\n        legend.position = \"top\",\n        panel.background = element_rect(color = \"black\"),\n        panel.grid.minor = element_blank()\n    ) +\n    labs(\n        x = \"Body mass (in g)\",\n        y = \"Bill length (in mm)\"\n    )\n\n\n\n\n\n\n\n\n\nCode\nglm.mod &lt;- glm(sex ~ body_mass_g + bill_length_mm + species, family = binomial, data = dat)\n\npreds &lt;- dat %&gt;% \n  mutate(\n    prob.fit = glm.mod$fitted.values,\n    prediction = if_else(prob.fit &gt; 0.5, 'male', 'female'),\n    correct = if_else(sex == prediction, 'correct', 'incorrect')\n  )\n\n\npreds %&gt;% \n  ggplot(aes(body_mass_g, bill_length_mm, col = correct)) +\n  geom_jitter(size = 4, alpha = 0.6) +\n  facet_wrap(vars(species)) +\n  scale_x_continuous(breaks = seq(3000, 6000, 1000)) +\n  scale_color_manual(values = c('grey60', thematic::okabe_ito(3)[3])) +\n  theme_minimal(base_size = 10) +\n  theme(\n    legend.position = 'top', \n    panel.background = element_rect(color = 'black'),\n    panel.grid.minor = element_blank()\n  ) +\n  labs(\n    x = 'Body mass (in g)',\n    y = 'Bill length (in mm)'\n  )\n\n\n\n\n\n\n\n\n\n\n\n\\int_0^1 f(x) \\ dx"
  },
  {
    "objectID": "posts/my-first-blog.html#columns",
    "href": "posts/my-first-blog.html#columns",
    "title": "A Demo Blog Post Using Quarto",
    "section": "",
    "text": "geom_density(\n  mapping = NULL,\n  data = NULL,\n  stat = \"density\",\n  position = \"identity\",\n  ...,\n  na.rm = FALSE,\n  orientation = NA,\n  show.legend = NA,\n  inherit.aes = TRUE,\n  outline.type = \"upper\"\n)\n\n\nstat_density(\n  mapping = NULL,\n  data = NULL,\n  geom = \"area\",\n  position = \"stack\",\n  ...,\n  bw = \"nrd0\",\n  adjust = 1,\n  kernel = \"gaussian\",\n  n = 512,\n  trim = FALSE,\n  na.rm = FALSE,\n  orientation = NA,\n  show.legend = NA,\n  inherit.aes = TRUE\n)"
  },
  {
    "objectID": "posts/my-first-blog.html#margin-captions",
    "href": "posts/my-first-blog.html#margin-captions",
    "title": "A Demo Blog Post Using Quarto",
    "section": "",
    "text": "ggplot(data = gapminder::gapminder, mapping = aes(x = lifeExp, fill = continent)) +\n    stat_density(position = \"identity\", alpha = 0.5)\n\n\n\n\nBla bla bla. This is a caption in the margin. Super cool isn’t it?"
  },
  {
    "objectID": "projects/cyclistic-bike-share-analysis.html#characters-and-teams",
    "href": "projects/cyclistic-bike-share-analysis.html#characters-and-teams",
    "title": "The Cyclistic Bike-share Analysis Case Study",
    "section": "Characters and teams",
    "text": "Characters and teams\n\nCyclistic: A bike-share program that features more than 5,800 bicycles and 600 docking stations. Cyclistic sets itself apart by also offering reclining bikes, hand tricycles, and cargo bikes, making bike-share more inclusive to people with disabilities and riders who can’t use a standard two-wheeled bike. The majority of riders opt for traditional bikes; about 8% of riders use the assistive options. Cyclistic users are more likely to ride for leisure, but about 30% use them to commute to work each day.\nLily Moreno: The director of marketing and your manager. Moreno is responsible for the development of campaigns and initiatives to promote the bike-share program. These may include email, social media, and other channels.\nCyclistic marketing analytics team: A team of data analysts who are responsible for collecting, analyzing, and reporting data that helps guide Cyclistic marketing strategy. You joined this team six months ago and have been busy learning about Cyclistic’s mission and business goals — as well as how you, as a junior data analyst, can help Cyclistic achieve them.\nCyclistic executive team: The notoriously detail-oriented executive team will decide whether to approve the recommended marketing program."
  },
  {
    "objectID": "projects/cyclistic-bike-share-analysis.html#about-the-company",
    "href": "projects/cyclistic-bike-share-analysis.html#about-the-company",
    "title": "The Cyclistic Bike-share Analysis Case Study",
    "section": "About the company",
    "text": "About the company\nIn 2016, Cyclistic launched a successful bike-share offering. Since then, the program has grown to a fleet of 5,824 bicycles that are geotracked and locked into a network of 692 stations across Chicago. The bikes can be unlocked from one station and returned to any other station in the system anytime.\nUntil now, Cyclistic’s marketing strategy relied on building general awareness and appealing to broad consumer segments. One approach that helped make these things possible was the flexibility of its pricing plans: single-ride passes, full-day passes, and annual memberships. Customers who purchase single-ride or full-day passes are referred to as casual riders. Customers who purchase annual memberships are Cyclistic members.\nCyclistic’s finance analysts have concluded that annual members are much more profitable than casual riders. Although the pricing flexibility helps Cyclistic attract more customers, Moreno believes that maximizing the number of annual members will be key to future growth. Rather than creating a marketing campaign that targets all-new customers, Moreno believes there is a very good chance to convert casual riders into members. She notes that casual riders are already aware of the Cyclistic program and have chosen Cyclistic for their mobility needs.\nMoreno has set a clear goal: Design marketing strategies aimed at converting casual riders into annual members. In order to do that, however, the marketing analyst team needs to better understand how annual members and casual riders differ, why casual riders would buy a membership, and how digital media could affect their marketing tactics. Moreno and her team are interested in analyzing the Cyclistic historical bike trip data to identify trends."
  },
  {
    "objectID": "projects/cyclistic-bike-share-analysis.html#project-deliverables",
    "href": "projects/cyclistic-bike-share-analysis.html#project-deliverables",
    "title": "The Cyclistic Bike-share Analysis Case Study",
    "section": "Project deliverables",
    "text": "Project deliverables\nProduce a report with the following deliverables:\n\n\nA clear statement of the business task.\nA description of all data sources used.\nDocumentation of any cleaning or manipulation of data.\nA summary of your analysis.\nSupporting visualizations and key findings.\nYour top three recommendations based on your analysis."
  },
  {
    "objectID": "projects/cyclistic-bike-share-analysis.html#key-findings",
    "href": "projects/cyclistic-bike-share-analysis.html#key-findings",
    "title": "The Cyclistic Bike-share Analysis Case Study",
    "section": "Key findings",
    "text": "Key findings\n\nThe bikes were used by members more frequently than casual users, with a 24.12% higher usage rate in the last 12 months.\nHowever, casual riders had longer ride duration compared to members, with an average difference of 4-7 minutes.\nFrom a quarterly perspective, the third and second quarters of the year were the most popular seasons for casual riders.\nCasual riders exhibited a preference for riding bikes on Fridays, Saturdays, and Sundays, and they had longer trip duration during these days.\nAmong the rideable types, classic bikes were the most popular choice among casual riders.\nCasual riders were the only user group that utilized docked bikes.\n“Streeter Dr & Grand Ave” and “DuSable Lake Shore Dr & Monroe St” were the most common starting stations for casual users."
  },
  {
    "objectID": "projects/cyclistic-bike-share-analysis.html#three-recommendations",
    "href": "projects/cyclistic-bike-share-analysis.html#three-recommendations",
    "title": "The Cyclistic Bike-share Analysis Case Study",
    "section": "Three recommendations",
    "text": "Three recommendations\n\nCreate a marketing campaign that educates casual riders on their long-ride trips and invites them to a membership that can cater to their riding needs year-round. The campaign can be advertised both online and offline, with a focus on regions where the most popular stations for casual riders are located. This recommendation is supported by the data analysis, which highlights the long ride durations of casual riders and emphasizes the value of a membership that can provide continuous benefits.\nConsider creating a specialty membership specifically designed for docked-bike users. This targeted approach can be an effective way to engage casual riders who prefer docked bikes. However, instead of offering a separate membership, it may be more beneficial to incorporate docked-bike usage as an additional feature within the existing full-scale membership. This way, casual riders can experience the benefits of membership without creating a distinct membership category.\nDevelop a special introductory membership for the months between April and September or for the days of the week (Friday to Sunday). This limited-time membership can serve as a trial period, offering casual riders the opportunity to experience the benefits of a membership during the most popular seasons or days. Following the introductory period, you can then transition these riders to a regular yearly membership."
  },
  {
    "objectID": "projects.html",
    "href": "projects.html",
    "title": "Projects",
    "section": "",
    "text": "The Cyclistic Bike-share Analysis Case Study\n\n\n\n\n\n\n\n\n\nFebruary 5, 2023\n\n\nAlbert Joonyoung Park\n\n\n25 min\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/document.html",
    "href": "posts/document.html",
    "title": "Exploring Polar Coordinate Plots in Python Using Matplotlib",
    "section": "",
    "text": "A polar plot is a type of graph that presents data in a circular format, offering a fresh perspective beyond the conventional Cartesian coordinate system. In a polar plot, data points are represented using radial distance from a central point and angular positions, creating a distinct visual representation that emphasizes patterns and relationships in a unique way. This type of plot is particularly suitable for data that exhibits directional or cyclic patterns, such as time series data, circular data (e.g., wind direction), or any data with inherent periodicity. Polar plots excel at revealing cyclical trends and variations that might go unnoticed on traditional scatter plots. They allow us to easily observe changes in data values as they evolve over angles, providing insights into periodic behaviors, phase shifts, and synchronization. Whether in the realms of engineering, meteorology, or scientific research, polar plots offer a valuable tool for gaining deeper insights from complex datasets that might otherwise remain hidden in a sea of numbers.\nFor a demonstration of a line plot on a polar axis, see Figure 1.\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Define an array of values for the radial distance\nr = np.arange(0, 2, 0.01)\n\n# Convert the radial distance into angles\ntheta = 2 * np.pi * r\n\n# Create a figure and axis with polar projection\nfig, ax = plt.subplots(subplot_kw={'projection': 'polar'})\n\n# Plot the data points on the polar axis\nax.plot(theta, r)\n\n# Customize the radial ticks to enhance readability\nax.set_rticks([0.5, 1, 1.5, 2])\n\n# Add grid lines for a clear reference\nax.grid(True)\n\n# Display the enchanting plot\nplt.show()\n\n\n\n\nFigure 1: A line plot on a polar axis"
  },
  {
    "objectID": "projects/bellabeat-analysis.html#characters-and-products",
    "href": "projects/bellabeat-analysis.html#characters-and-products",
    "title": "Bellabeat Analysis Case Study",
    "section": "Characters and products",
    "text": "Characters and products\n\nCharacters\n\nUrška Sršen: Bellabeat’s cofounder and Chief Creative Officer\nSando Mur: Mathematician and Bellabeat’s cofounder; key member of the Bellabeat executive team\nBellabeat marketing analytics team: A team of data analysts responsible for collecting, analyzing, and reporting data that helps guide Bellabeat’s marketing strategy. You joined this team six months ago and have been busy learning about Bellabeat’’s mission and business goals — as well as how you, as a junior data analyst, can help Bellabeat achieve them.\n\nProducts\n\nBellabeat app: The Bellabeat app provides users with health data related to their activity, sleep, stress, menstrual cycle, and mindfulness habits. This data can help users better understand their current habits and make healthy decisions. The Bellabeat app connects to their line of smart wellness products.\nLeaf: Bellabeat’s classic wellness tracker can be worn as a bracelet, necklace, or clip. The Leaf tracker connects to the Bellabeat app to track activity, sleep, and stress.\nTime: This wellness watch combines the timeless look of a classic timepiece with smart technology to track user activity, sleep, and stress. The Time watch connects to the Bellabeat app to provide you with insights into your daily wellness.\nSpring: This is a water bottle that tracks daily water intake using smart technology to ensure that you are appropriately hydrated throughout the day. The Spring bottle connects to the Bellabeat app to track your hydration levels.\nBellabeat membership: Bellabeat also offers a subscription-based membership program for users. Membership gives users 24/7 access to fully personalized guidance on nutrition, activity, sleep, health and beauty, and mindfulness based on their lifestyle and goals."
  },
  {
    "objectID": "projects/bellabeat-analysis.html#about-the-company",
    "href": "projects/bellabeat-analysis.html#about-the-company",
    "title": "Bellabeat Analysis Case Study",
    "section": "About the company",
    "text": "About the company\nUrška Sršen and Sando Mur founded Bellabeat, a high-tech company that manufactures health-focused smart products. Sršen used her background as an artist to develop beautifully designed technology that informs and inspires women around the world. Collecting data on activity, sleep, stress, and reproductive health has allowed Bellabeat to empower women with knowledge about their own health and habits. Since it was founded in 2013, Bellabeat has grown rapidly and quickly positioned itself as a tech-driven wellness company for women.\nBy 2016, Bellabeat had opened offices around the world and launched multiple products. Bellabeat products became available through a growing number of online retailers in addition to their own e-commerce channel on their website. The company has invested in traditional advertising media, such as radio, out-of-home billboards, print, and television, but focuses on digital marketing extensively. Bellabeat invests year-round in Google Search, maintaining active Facebook and Instagram pages, and consistently engages consumers on Twitter. Additionally, Bellabeat runs video ads on Youtube and display ads on the Google Display Network to support campaigns around key marketing dates.\nSršen knows that an analysis of Bellabeat’s available consumer data would reveal more opportunities for growth. She has asked the marketing analytics team to focus on a Bellabeat product and analyze smart device usage data in order to gain insight into how people are already using their smart devices. Then, using this information, she would like high-level recommendations for how these trends can inform Bellabeat marketing strategy."
  },
  {
    "objectID": "projects/bellabeat-analysis.html#project-deliverables",
    "href": "projects/bellabeat-analysis.html#project-deliverables",
    "title": "Bellabeat Analysis Case Study",
    "section": "Project deliverables",
    "text": "Project deliverables\nProduce a report with the following deliverables:\n\n\nA clear statement of the business task.\nA description of all data sources used.\nDocumentation of any cleaning or manipulation of data.\nA summary of your analysis.\nSupporting visualizations and key findings.\nYour top three recommendations based on your analysis."
  },
  {
    "objectID": "projects/bellabeat-analysis.html#key-findings",
    "href": "projects/bellabeat-analysis.html#key-findings",
    "title": "Bellabeat Analysis Case Study",
    "section": "Key findings",
    "text": "Key findings\n\nThe bikes were used by members more frequently than casual users, with a 24.12% higher usage rate in the last 12 months.\nHowever, casual riders had longer ride duration compared to members, with an average difference of 4-7 minutes.\nFrom a quarterly perspective, the third and second quarters of the year were the most popular seasons for casual riders.\nCasual riders exhibited a preference for riding bikes on Fridays, Saturdays, and Sundays, and they had longer trip duration during these days.\nAmong the rideable types, classic bikes were the most popular choice among casual riders.\nCasual riders were the only user group that utilized docked bikes.\n“Streeter Dr & Grand Ave” and “DuSable Lake Shore Dr & Monroe St” were the most common starting stations for casual users."
  },
  {
    "objectID": "projects/bellabeat-analysis.html#three-recommendations",
    "href": "projects/bellabeat-analysis.html#three-recommendations",
    "title": "Bellabeat Analysis Case Study",
    "section": "Three recommendations",
    "text": "Three recommendations\n\nCreate a marketing campaign that educates casual riders on their long-ride trips and invites them to a membership that can cater to their riding needs year-round. The campaign can be advertised both online and offline, with a focus on regions where the most popular stations for casual riders are located. This recommendation is supported by the data analysis, which highlights the long ride durations of casual riders and emphasizes the value of a membership that can provide continuous benefits.\nConsider creating a specialty membership specifically designed for docked-bike users. This targeted approach can be an effective way to engage casual riders who prefer docked bikes. However, instead of offering a separate membership, it may be more beneficial to incorporate docked-bike usage as an additional feature within the existing full-scale membership. This way, casual riders can experience the benefits of membership without creating a distinct membership category.\nDevelop a special introductory membership for the months between April and September or for the days of the week (Friday to Sunday). This limited-time membership can serve as a trial period, offering casual riders the opportunity to experience the benefits of a membership during the most popular seasons or days. Following the introductory period, you can then transition these riders to a regular yearly membership."
  },
  {
    "objectID": "posts/document.html#polar-plot",
    "href": "posts/document.html#polar-plot",
    "title": "Exploring Polar Coordinate Plots in Python Using Matplotlib",
    "section": "",
    "text": "A polar plot is a type of graph that presents data in a circular format, offering a fresh perspective beyond the conventional Cartesian coordinate system. In a polar plot, data points are represented using radial distance from a central point and angular positions, creating a distinct visual representation that emphasizes patterns and relationships in a unique way. This type of plot is particularly suitable for data that exhibits directional or cyclic patterns, such as time series data, circular data (e.g., wind direction), or any data with inherent periodicity. Polar plots excel at revealing cyclical trends and variations that might go unnoticed on traditional scatter plots. They allow us to easily observe changes in data values as they evolve over angles, providing insights into periodic behaviors, phase shifts, and synchronization. Whether in the realms of engineering, meteorology, or scientific research, polar plots offer a valuable tool for gaining deeper insights from complex datasets that might otherwise remain hidden in a sea of numbers.\nFor a demonstration of a line plot on a polar axis, see Figure 1.\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Define an array of values for the radial distance\nr = np.arange(0, 2, 0.01)\n\n# Convert the radial distance into angles\ntheta = 2 * np.pi * r\n\n# Create a figure and axis with polar projection\nfig, ax = plt.subplots(subplot_kw={'projection': 'polar'})\n\n# Plot the data points on the polar axis\nax.plot(theta, r)\n\n# Customize the radial ticks to enhance readability\nax.set_rticks([0.5, 1, 1.5, 2])\n\n# Add grid lines for a clear reference\nax.grid(True)\n\n# Display the enchanting plot\nplt.show()\n\n\n\n\nFigure 1: A line plot on a polar axis"
  },
  {
    "objectID": "posts/document.html#decoding-the-code",
    "href": "posts/document.html#decoding-the-code",
    "title": "Exploring Polar Coordinate Plots in Python Using Matplotlib",
    "section": "Decoding the Code",
    "text": "Decoding the Code\nImporting Libraries: We start by importing the NumPy and Matplotlib libraries. These are our trusty tools for handling numerical calculations and creating visual wonders.\nDefining Radial Values: The r array represents the radial distance from the center. We use NumPy’s arange() function to generate values from 0 to 2 in increments of 0.01. This gives us the varying distances from the center.\nConverting to Angles: Here comes the magic! We calculate the corresponding angles in radians using the formula 2 * pi * r. This establishes the circular motion around the center point.\nCreating the Plotting Canvas: With Matplotlib’s help, we create a figure and axis with a polar projection. This sets the stage for our polar coordinate plot.\nPlotting the Data: Using the plot() function, we unveil our plot to the world! The theta values represent the angles, and the r values dictate the distance from the center. As we connect the dots, a beautiful pattern unfolds.\nRadial Ticks and Grid: To make our plot more user-friendly, we customize the radial ticks to show values of 0.5, 1, 1.5, and 2. We also add grid lines to assist in interpreting the plot.\nShowcasing the Masterpiece: Finally, we display our creation using plt.show(). Behold the captivating polar coordinate plot!"
  },
  {
    "objectID": "posts/document.html#your-voyage-into-polar-coordinates",
    "href": "posts/document.html#your-voyage-into-polar-coordinates",
    "title": "Exploring Polar Coordinate Plots in Python Using Matplotlib",
    "section": "Your Voyage into Polar Coordinates",
    "text": "Your Voyage into Polar Coordinates\nCongratulations! You’ve just embarked on a visual adventure that combines mathematics and artistry. Through a few lines of Python code, you’ve created a stunning polar coordinate plot using Matplotlib. As you delve deeper into the world of programming and data visualization, remember that every line of code has the potential to bring your imagination to life.\nSo go ahead, experiment with different values, and let your creativity flourish. The world of data visualization is at your fingertips, waiting for you to explore and innovate. Happy coding and plotting!"
  },
  {
    "objectID": "posts/document.html#lets-break-it-down-decoding-the-code",
    "href": "posts/document.html#lets-break-it-down-decoding-the-code",
    "title": "Exploring Polar Coordinate Plots in Python Using Matplotlib",
    "section": "Let’s Break It Down: Decoding the Code",
    "text": "Let’s Break It Down: Decoding the Code\n1. Importing Libraries: We start by importing the NumPy and Matplotlib libraries. These are our trusty tools for handling numerical calculations and creating visual wonders.\n2. Defining Radial Values: The r array represents the radial distance from the center. We use NumPy’s arange() function to generate values from 0 to 2 in increments of 0.01. This gives us the varying distances from the center.\n3. Converting to Angles: Here comes the magic! We calculate the corresponding angles in radians using the formula 2 * pi * r. This establishes the circular motion around the center point.\n4. Creating the Plotting Canvas: With Matplotlib’s help, we create a figure and axis with a polar projection. This sets the stage for our polar coordinate plot.\n5. Plotting the Data: Using the plot() function, we unveil our plot to the world! The theta values represent the angles, and the r values dictate the distance from the center. As we connect the dots, a beautiful pattern unfolds.\n6. Radial Ticks and Grid: To make our plot more user-friendly, we customize the radial ticks to show values of 0.5, 1, 1.5, and 2. We also add grid lines to assist in interpreting the plot.\n7. Showcasing the Masterpiece: Finally, we display our creation using plt.show(). Behold the captivating polar coordinate plot!"
  },
  {
    "objectID": "posts/document.html#conclusion-your-voyage-into-polar-coordinates",
    "href": "posts/document.html#conclusion-your-voyage-into-polar-coordinates",
    "title": "Exploring Polar Coordinate Plots in Python Using Matplotlib",
    "section": "Conclusion: Your Voyage into Polar Coordinates",
    "text": "Conclusion: Your Voyage into Polar Coordinates\nCongratulations! You’ve just embarked on a visual adventure that combines mathematics and artistry. Through a few lines of Python code, you’ve created a stunning polar coordinate plot using Matplotlib. As you delve deeper into the world of programming and data visualization, remember that every line of code has the potential to bring your imagination to life.\nSo go ahead, experiment with different values, and let your creativity flourish. The world of data visualization is at your fingertips, waiting for you to explore and innovate. Happy coding and plotting!"
  },
  {
    "objectID": "posts/matplotlib.html",
    "href": "posts/matplotlib.html",
    "title": "Exploring Polar Coordinate Plot in Python Using Matplotlib",
    "section": "",
    "text": "A polar plot is a type of graph that presents data in a circular format, offering a fresh perspective beyond the conventional Cartesian coordinate system. In a polar plot, data points are represented using radial distance from a central point and angular positions, creating a distinct visual representation that emphasizes patterns and relationships in a unique way. This type of plot is particularly suitable for data that exhibits directional or cyclic patterns, such as time series data, circular data (e.g., wind direction), or any data with inherent periodicity. Polar plots excel at revealing cyclical trends and variations that might go unnoticed on traditional scatter plots. They allow us to easily observe changes in data values as they evolve over angles, providing insights into periodic behaviors, phase shifts, and synchronization. Whether in the realms of engineering, meteorology, or scientific research, polar plots offer a valuable tool for gaining deeper insights from complex datasets that might otherwise remain hidden in a sea of numbers.\nFor a demonstration of a line plot on a polar axis, see Figure 1.\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Define an array of values for the radial distance\nr = np.arange(0, 2, 0.01)\n\n# Convert the radial distance into angles\ntheta = 2 * np.pi * r\n\n# Create a figure and axis with polar projection\nfig, ax = plt.subplots(subplot_kw={'projection': 'polar'})\n\n# Plot the data points on the polar axis\nax.plot(theta, r)\n\n# Customize the radial ticks to enhance readability\nax.set_rticks([0.5, 1, 1.5, 2])\n\n# Add grid lines for a clear reference\nax.grid(True)\n\n# Display the enchanting plot\nplt.show()\n\n\n\n\nFigure 1: A line plot on a polar axis"
  },
  {
    "objectID": "posts/matplotlib.html#polar-plot",
    "href": "posts/matplotlib.html#polar-plot",
    "title": "Exploring Polar Coordinate Plot in Python Using Matplotlib",
    "section": "",
    "text": "A polar plot is a type of graph that presents data in a circular format, offering a fresh perspective beyond the conventional Cartesian coordinate system. In a polar plot, data points are represented using radial distance from a central point and angular positions, creating a distinct visual representation that emphasizes patterns and relationships in a unique way. This type of plot is particularly suitable for data that exhibits directional or cyclic patterns, such as time series data, circular data (e.g., wind direction), or any data with inherent periodicity. Polar plots excel at revealing cyclical trends and variations that might go unnoticed on traditional scatter plots. They allow us to easily observe changes in data values as they evolve over angles, providing insights into periodic behaviors, phase shifts, and synchronization. Whether in the realms of engineering, meteorology, or scientific research, polar plots offer a valuable tool for gaining deeper insights from complex datasets that might otherwise remain hidden in a sea of numbers.\nFor a demonstration of a line plot on a polar axis, see Figure 1.\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Define an array of values for the radial distance\nr = np.arange(0, 2, 0.01)\n\n# Convert the radial distance into angles\ntheta = 2 * np.pi * r\n\n# Create a figure and axis with polar projection\nfig, ax = plt.subplots(subplot_kw={'projection': 'polar'})\n\n# Plot the data points on the polar axis\nax.plot(theta, r)\n\n# Customize the radial ticks to enhance readability\nax.set_rticks([0.5, 1, 1.5, 2])\n\n# Add grid lines for a clear reference\nax.grid(True)\n\n# Display the enchanting plot\nplt.show()\n\n\n\n\nFigure 1: A line plot on a polar axis"
  },
  {
    "objectID": "posts/matplotlib.html#lets-break-it-down-decoding-the-code",
    "href": "posts/matplotlib.html#lets-break-it-down-decoding-the-code",
    "title": "Exploring Polar Coordinate Plot in Python Using Matplotlib",
    "section": "Let’s Break It Down: Decoding the Code",
    "text": "Let’s Break It Down: Decoding the Code\n1. Importing Libraries: We start by importing the NumPy and Matplotlib libraries. These are our trusty tools for handling numerical calculations and creating visual wonders.\n2. Defining Radial Values: The r array represents the radial distance from the center. We use NumPy’s arange() function to generate values from 0 to 2 in increments of 0.01. This gives us the varying distances from the center.\n3. Converting to Angles: Here comes the magic! We calculate the corresponding angles in radians using the formula 2 * pi * r. This establishes the circular motion around the center point.\n4. Creating the Plotting Canvas: With Matplotlib’s help, we create a figure and axis with a polar projection. This sets the stage for our polar coordinate plot.\n5. Plotting the Data: Using the plot() function, we unveil our plot to the world! The theta values represent the angles, and the r values dictate the distance from the center. As we connect the dots, a beautiful pattern unfolds.\n6. Radial Ticks and Grid: To make our plot more user-friendly, we customize the radial ticks to show values of 0.5, 1, 1.5, and 2. We also add grid lines to assist in interpreting the plot.\n7. Showcasing the Masterpiece: Finally, we display our creation using plt.show(). Behold the captivating polar coordinate plot!"
  },
  {
    "objectID": "posts/matplotlib.html#conclusion-your-voyage-into-polar-coordinates",
    "href": "posts/matplotlib.html#conclusion-your-voyage-into-polar-coordinates",
    "title": "Exploring Polar Coordinate Plot in Python Using Matplotlib",
    "section": "Conclusion: Your Voyage into Polar Coordinates",
    "text": "Conclusion: Your Voyage into Polar Coordinates\nCongratulations! You’ve just embarked on a visual adventure that combines mathematics and artistry. Through a few lines of Python code, you’ve created a stunning polar coordinate plot using Matplotlib. As you delve deeper into the world of programming and data visualization, remember that every line of code has the potential to bring your imagination to life.\nSo go ahead, experiment with different values, and let your creativity flourish. The world of data visualization is at your fingertips, waiting for you to explore and innovate. Happy coding and plotting!"
  },
  {
    "objectID": "posts/reticulate.html",
    "href": "posts/reticulate.html",
    "title": "Python Setup in R with Reticulate",
    "section": "",
    "text": "# load r packages, including reticulate\nlibrary(tidyverse)\nlibrary(reticulate)\n\n# list current conda environments\nconda_list()\n# Set conda environment to use\nuse_condaenv(\"pydata-book\", required=TRUE)\n# Confirm the selected conda and python environemtn\npy_config()\n# Run some strings of python codes.\npy_run_string(\"import os as os\")\n\n# Very simple python function and an expression\nprint(\"Hello World!\")\n1+1\n\nHello World!\n\n\n2\n\n\n\n# package import and some data import\n\nimport numpy as np\nimport pandas as pd\n\narr = np.arange(1, 10)\nprint(type(arr))\narr\n\n# data frame creation\ndf = pd.DataFrame(data = {\"sequence\":np.arange(1,20,.01)})\ndf\ndf = df.assign(value=np.sin(df[\"sequence\"]))\ndf\n\n&lt;class 'numpy.ndarray'&gt;\n\n\n\n\n\n\n\n\n\nsequence\nvalue\n\n\n\n\n0\n1.00\n0.841471\n\n\n1\n1.01\n0.846832\n\n\n2\n1.02\n0.852108\n\n\n3\n1.03\n0.857299\n\n\n4\n1.04\n0.862404\n\n\n...\n...\n...\n\n\n1895\n19.95\n0.891409\n\n\n1896\n19.96\n0.895896\n\n\n1897\n19.97\n0.900294\n\n\n1898\n19.98\n0.904602\n\n\n1899\n19.99\n0.908819\n\n\n\n\n1900 rows × 2 columns\n\n\n\nVisualize the data frame using Matplotlib\n\nimport matplotlib.pyplot as plt\n\ndf.plot(x=\"sequence\", y = \"value\", title = \"Matplotlib\")\nplt.show()\n\n\n\n\n\n\n\nfrom sklearn.ensemble import RandomForestClassifier\n\nclf = RandomForestClassifier(random_state=0)\n\nX = [[ 1,  2,  3],  # 2 samples, 3 features\n     [11, 12, 13]]\n\ny = [0, 1]  # classes of each sample\n\nclf.fit(X, y)\n\nRandomForestClassifier(random_state=0)In a Jupyter environment, please rerun this cell to show the HTML representation or trust the notebook. On GitHub, the HTML representation is unable to render, please try loading this page with nbviewer.org.RandomForestClassifierRandomForestClassifier(random_state=0)\n\n\n\n\n\n\nfrom sklearn.cluster import AffinityPropagation\nfrom sklearn.datasets import make_blobs\n\n# #############################################################################\n# Generate sample data\ncenters = [[1, 1], [-1, -1], [1, -1]]\nX, labels_true = make_blobs(n_samples=300, centers=centers, cluster_std=0.5,\n                            random_state=0)\n\n# Compute Affinity Propagation\naf = AffinityPropagation(preference=-50).fit(X)\ncluster_centers_indices = af.cluster_centers_indices_\nlabels = af.labels_\n\nn_clusters_ = len(cluster_centers_indices)\n\n# #############################################################################\n# Plot result\nimport matplotlib.pyplot as plt\nfrom itertools import cycle\n\nplt.close('all')\nplt.figure(1)\nplt.clf()\n\ncolors = cycle('bgrcmykbgrcmykbgrcmykbgrcmyk')\nfor k, col in zip(range(n_clusters_), colors):\n    class_members = labels == k\n    cluster_center = X[cluster_centers_indices[k]]\n    plt.plot(X[class_members, 0], X[class_members, 1], col + '.')\n    plt.plot(cluster_center[0], cluster_center[1], 'o', markerfacecolor=col,\n             markeredgecolor='k', markersize=14)\n    for x in X[class_members]:\n        plt.plot([cluster_center[0], x[0]], [cluster_center[1], x[1]], col)\n\nplt.title('Estimated number of clusters: %d' % n_clusters_)\nplt.show()"
  },
  {
    "objectID": "posts/reticulate.html#scikit-learn---random-forest",
    "href": "posts/reticulate.html#scikit-learn---random-forest",
    "title": "Python Setup in R with Reticulate",
    "section": "",
    "text": "from sklearn.ensemble import RandomForestClassifier\n\nclf = RandomForestClassifier(random_state=0)\n\nX = [[ 1,  2,  3],  # 2 samples, 3 features\n     [11, 12, 13]]\n\ny = [0, 1]  # classes of each sample\n\nclf.fit(X, y)\n\nRandomForestClassifier(random_state=0)In a Jupyter environment, please rerun this cell to show the HTML representation or trust the notebook. On GitHub, the HTML representation is unable to render, please try loading this page with nbviewer.org.RandomForestClassifierRandomForestClassifier(random_state=0)"
  },
  {
    "objectID": "posts/reticulate.html#run-affinity-propagation",
    "href": "posts/reticulate.html#run-affinity-propagation",
    "title": "Python Setup in R with Reticulate",
    "section": "",
    "text": "from sklearn.cluster import AffinityPropagation\nfrom sklearn.datasets import make_blobs\n\n# #############################################################################\n# Generate sample data\ncenters = [[1, 1], [-1, -1], [1, -1]]\nX, labels_true = make_blobs(n_samples=300, centers=centers, cluster_std=0.5,\n                            random_state=0)\n\n# Compute Affinity Propagation\naf = AffinityPropagation(preference=-50).fit(X)\ncluster_centers_indices = af.cluster_centers_indices_\nlabels = af.labels_\n\nn_clusters_ = len(cluster_centers_indices)\n\n# #############################################################################\n# Plot result\nimport matplotlib.pyplot as plt\nfrom itertools import cycle\n\nplt.close('all')\nplt.figure(1)\nplt.clf()\n\ncolors = cycle('bgrcmykbgrcmykbgrcmykbgrcmyk')\nfor k, col in zip(range(n_clusters_), colors):\n    class_members = labels == k\n    cluster_center = X[cluster_centers_indices[k]]\n    plt.plot(X[class_members, 0], X[class_members, 1], col + '.')\n    plt.plot(cluster_center[0], cluster_center[1], 'o', markerfacecolor=col,\n             markeredgecolor='k', markersize=14)\n    for x in X[class_members]:\n        plt.plot([cluster_center[0], x[0]], [cluster_center[1], x[1]], col)\n\nplt.title('Estimated number of clusters: %d' % n_clusters_)\nplt.show()"
  },
  {
    "objectID": "posts/p4da3d-data-types.html",
    "href": "posts/p4da3d-data-types.html",
    "title": "[3] Built-In Data Structures, Functions, and Files",
    "section": "",
    "text": "Python Tuples: Immutable, ordered collections that allow you to store a sequence of elements. Tuples are defined using parentheses and can hold a mix of data types. They offer efficient data storage, are iterable, and can be used as keys in dictionaries. In this blog, we’ll explore the versatility of Python tuples and how to leverage them for various data analysis tasks.\n\n# create some tuples\ntup = (4, 5, 6)\ntup2 = 7, 8, 9\nprint(tup)\nprint(tup2)\nt = (tup, tup2)    # tuple of tuples\nprint(t)\ntype(t)\n\n# convert any sequence or iterator to tuple\nprint(tuple(['a', 'b', 'c']))\nprint(tuple('Some String'))\n\n# access elements\nnested_tup = ((4,5,6), (7,8))\nprint(nested_tup[1])\n\n(4, 5, 6)\n(7, 8, 9)\n((4, 5, 6), (7, 8, 9))\n('a', 'b', 'c')\n('S', 'o', 'm', 'e', ' ', 'S', 't', 'r', 'i', 'n', 'g')\n(7, 8)\n\n\nTuple itself is immutable; however, if an object inside a tuple is mutable, you can modify it in place.\n\ntup = tuple(['The bown ','fox ', 'jumped over the ',['fence.']])\nprint(tup)\n# tup[1] = 'wolf'           # error\ntup[3][0] = 'window '     # ok\nprint(tup)\ntup[3].append('fence')    # ok\nprint(tup)\n\n('The bown ', 'fox ', 'jumped over the ', ['fence.'])\n('The bown ', 'fox ', 'jumped over the ', ['window '])\n('The bown ', 'fox ', 'jumped over the ', ['window ', 'fence'])\n\n\nConcatenation, Variable swap, Unpacking\n\n# concatenation using +\ntup = (4, None, 'foo') + (6, 0) + ('bar',)\nprint(tup)\n\n# Swap\na, b = 1, 2\nprint(a, b)\nb, a = a, b\nprint(a, b)\n\n# Unpacking by iterating over sequences of tuples, lists\nseq = [('a1', 'a2', 'a3'),('b4', 'b5', 'b6'), ('c7', 'c8', 'c9')]\nprint(seq, type(seq))\nfor a, b, c in seq:\n  print(f'a={a}, b={b}, c={c}')\n  \n# unpacking using assignment, not concerning some trailing values\nvalues = 1, 2, 3, 4, 5, 6, 7\na, b, *_ = values     # *rest works the same as *_\nprint (a, b, *_)\n\n# method .count()\na = (1, 2, 2, 2, 3, 4, 2)\nprint(a.count(2))     # number of occurences\n\n(4, None, 'foo', 6, 0, 'bar')\n1 2\n2 1\n[('a1', 'a2', 'a3'), ('b4', 'b5', 'b6'), ('c7', 'c8', 'c9')] &lt;class 'list'&gt;\na=a1, b=a2, c=a3\na=b4, b=b5, c=b6\na=c7, b=c8, c=c9\n1 2 3 4 5 6 7\n4\n\n\n\n\n\nPython Lists: Ordered, mutable collections that allow you to store and manipulate sequences of items. Lists are versatile and can hold various data types. They support methods for adding, removing, and modifying elements, making them a fundamental data structure for data analysis and manipulation in Python.\n\n# create, convert lists\na_list = [2, 3, 7, None]\ntup = (\"foo\", \"bar\", \"baz\")\nb_list = list(tup)\nprint(b_list, type(b_list))\n\n# Access, modify list element\nb_list[1] = \"peekaboo\"\nprint(b_list)\n\n# Materialize an iterator / generator\ngen = range(20) # generator, not materialized yet.\nprint(gen) \nlist(gen) # materialize the generator to list\n\n# Work with the elements\nb_list.append(\"dwarf\")     # add to the end of list\nb_list.append(\"foo\")\nprint(b_list)\nb_list.insert(1, \"RED\")     # insert at specific location, consider using collections.deque for efficiency\nprint(b_list)\nb_list.remove(\"foo\")        # remove the first occurence only\nprint(b_list)\n\n# Check if element in the list\nprint(\"dwarf\" in b_list)\nprint(\"dwarf\" not in b_list)\n\n['foo', 'bar', 'baz'] &lt;class 'list'&gt;\n['foo', 'peekaboo', 'baz']\nrange(0, 20)\n['foo', 'peekaboo', 'baz', 'dwarf', 'foo']\n['foo', 'RED', 'peekaboo', 'baz', 'dwarf', 'foo']\n['RED', 'peekaboo', 'baz', 'dwarf', 'foo']\nTrue\nFalse\n\n\n\n# Concatenate and combine lists\nnew_list = [4, None, \"foo\"] + [7, 8, (2, 3)]\nprint(new_list)\nprint(b_list)\nnew_list.extend(b_list)\nprint(new_list)\n\n# Sorting in place\na = [\"saw\", \"small\", \"He\", \"foxes\", \"six\"]\na.sort() # default\nprint(a)\na.sort(key=len) # sort by key with given function, by the length of each element\nprint(a)\n\n# Sorted copy\na = [\"saw\", \"small\", \"He\", \"foxes\", \"six\"]\nsorted_copy = sorted(a)\nprint(sorted_copy)\n\n[4, None, 'foo', 7, 8, (2, 3)]\n['RED', 'peekaboo', 'baz', 'dwarf', 'foo']\n[4, None, 'foo', 7, 8, (2, 3), 'RED', 'peekaboo', 'baz', 'dwarf', 'foo']\n['He', 'foxes', 'saw', 'six', 'small']\n['He', 'saw', 'six', 'foxes', 'small']\n['He', 'foxes', 'saw', 'six', 'small']\n\n\n\n# Slices\n\nseq = [7, 2, 3, 7, 5, 6, 0, 1]\nprint(seq)\nprint(seq[1:5])   # index:1 - index: 4\nprint(seq[:5])    # index:beginning - index: 4\nprint(seq[5:])    # index:5 - index:last\nprint(seq[-4:])   # Indexing from the last, index:-4 to the end\nprint(seq[-6:-2]) # Indexing from the last, index: -6 to index: -2\n\nprint(\"-\"*30)\n\n# Stepping the list\nprint(seq[::2])     # Extract index 0, 2, 4, 6 ....\nprint(seq[::3])     # Extract index 0, 3, 6 ....\nprint(seq[::-2])    # Extract index -1, -3, -5 .....\nprint(seq[::-1])    # Extract index -1, -2, -3, -4 ... effectively reverse the list or tuple\n\n\nprint(\"-\"*30)\n\n# Slices replacement\nseq[3:5] = ['A','B']\nprint(seq)\n\n[7, 2, 3, 7, 5, 6, 0, 1]\n[2, 3, 7, 5]\n[7, 2, 3, 7, 5]\n[6, 0, 1]\n[5, 6, 0, 1]\n[3, 7, 5, 6]\n------------------------------\n[7, 3, 5, 0]\n[7, 7, 0]\n[1, 6, 7, 2]\n[1, 0, 6, 5, 7, 3, 2, 7]\n------------------------------\n[7, 2, 3, 'A', 'B', 6, 0, 1]\n\n\n\n\n\nPython Dictionaries: Versatile and dynamic data structures that store key-value pairs, allowing for efficient data retrieval and manipulation. Dictionaries are unordered collections that provide a way to map unique keys to associated values, making them invaluable for tasks like data storage, lookup tables, and configuration settings\n\n# Create a Dictionary (aka, hash-map, associative arrays)\n\nempty_dict = {} \nprint(empty_dict)\nd1 = {\"a\": \"some value\", \"b\": [1, 2, 3, 4]}  # key-value pair\nprint(d1)\n\n# Access, insert and set\nd1[7] = \"an integer\"      # 7:\"an integer\" pair\nprint(d1)\nprint(d1[\"b\"])            # lookup with key\n#print(d1[\"address\"])     # KeyError\nprint(\"address\" in d1)    # key exists?\n\nprint(\"-\"*30)\n\n# Delete values\ndel d1[7]              # delete with key\n#del d1[\"country\"]     # KeyError\nprint(d1)\nret = d1.pop(\"b\")      # delete with key and return the value\nprint(ret)\nprint(d1)\n\nprint(\"-\"*30)\n\n# Iteration using keys() values() items()\nd1 = {'a': 'some value', 'b': [1, 2, 3, 4], 7: 'an integer'}\nprint(type(d1.keys()))     # &lt;class 'dict_keys'&gt;\nprint(type(d1.values()))   # &lt;class 'dict_values'&gt;\n\nd1_keys = list(d1.keys())   \nd1_values = list(d1.values())\nd1_items = list(d1.items())  # Gives a list of tuples in (key, value)\nprint(d1_keys)\nprint(d1_values)\nprint(d1_items)  \n\n# iteration\nfor key, value in d1.items():\n  print(f'Key: \\\"{key}\\\" has value of \\\"{value}\\\".')\n\n{}\n{'a': 'some value', 'b': [1, 2, 3, 4]}\n{'a': 'some value', 'b': [1, 2, 3, 4], 7: 'an integer'}\n[1, 2, 3, 4]\nFalse\n------------------------------\n{'a': 'some value', 'b': [1, 2, 3, 4]}\n[1, 2, 3, 4]\n{'a': 'some value'}\n------------------------------\n&lt;class 'dict_keys'&gt;\n&lt;class 'dict_values'&gt;\n['a', 'b', 7]\n['some value', [1, 2, 3, 4], 'an integer']\n[('a', 'some value'), ('b', [1, 2, 3, 4]), (7, 'an integer')]\nKey: \"a\" has value of \"some value\".\nKey: \"b\" has value of \"[1, 2, 3, 4]\".\nKey: \"7\" has value of \"an integer\".\n\n\n\n# Update dictionary with a dictionary of new or changes of key-value pairs\nd1 = {'a': 'some value', 'b': [1, 2, 3, 4], 7: 'an integer'}\nprint(d1)\nd1.update({\"b\": \"foo\", \"c\": 12})\nprint(d1)\n\n{'a': 'some value', 'b': [1, 2, 3, 4], 7: 'an integer'}\n{'a': 'some value', 'b': 'foo', 7: 'an integer', 'c': 12}\n\n\n\n# Create a dictionary from two sequences\n\nlist_country = [\"USA\", \"Canada\", \"England\", \"France\"]\nlist_city = [\"Washigton\", \"Ottawa\", \"London\", \"Paris\"]\nprint(list_country)\nprint(list_city)\n\n# Using for loop - zip and iterate\nprint(zip(list_country, list_city))\n\nmapping = {}\nfor key, value in zip(list_country, list_city):\n  mapping[key] = value\nprint(mapping, type(mapping))\n\n# Using dict() method\ncountry_city_tuples = zip(list_country, list_city)\nprint(country_city_tuples, type(country_city_tuples))\nmapping = dict(country_city_tuples)\nprint(mapping, type(mapping))\n\n['USA', 'Canada', 'England', 'France']\n['Washigton', 'Ottawa', 'London', 'Paris']\n&lt;zip object at 0x000001A5023FF5C0&gt;\n{'USA': 'Washigton', 'Canada': 'Ottawa', 'England': 'London', 'France': 'Paris'} &lt;class 'dict'&gt;\n&lt;zip object at 0x000001A5023FE900&gt; &lt;class 'zip'&gt;\n{'USA': 'Washigton', 'Canada': 'Ottawa', 'England': 'London', 'France': 'Paris'} &lt;class 'dict'&gt;\n\n\n\n# Build a dictionary WUTHOUT using setdefault()\nwords = [\"apple\", \"bat\", \"bar\", \"atom\", \"book\"]\nprint(words, type(words))\n\nby_letter = {}\n\nfor word in words:\n  letter = word[0] # Using the first letter of each word as key\n  if letter not in by_letter:\n    by_letter[letter] = [word]\n  else:\n    by_letter[letter].append(word)\n\nprint(by_letter)\n\nprint(\"-\"*55)\n\n# Simplified version using setdefault()\n\nwords = [\"apple\", \"bat\", \"bar\", \"atom\", \"book\"]\nby_letter = {}\nfor word in words:\n  letter = word[0] # Using the first letter of each word as key\n  by_letter.setdefault(letter, []).append(word) # If the letter (the first letter of the current word) is already a key in the dictionary, it returns the corresponding value (which is a list) for that key. If the key doesn't exist, it initializes an empty list. The append() method is then used to add the current word to the list associated with the letter key.\nprint(by_letter)\n\nprint(\"-\"*55)\n\n# Using defaultdict from collections module\nfrom collections import defaultdict\n\nwords = [\"apple\", \"bat\", \"bar\", \"atom\", \"book\"]\nby_letter = defaultdict(list) # if you access a key that doesn't exist, it will automatically create that key with an empty list as the associated value. This is particularly useful when you want to avoid KeyError exceptions when working with dictionaries.\nprint(by_letter, type(by_letter))\n\nfor word in words:\n  by_letter[word[0]].append(word)\n\nprint(by_letter)\n\n['apple', 'bat', 'bar', 'atom', 'book'] &lt;class 'list'&gt;\n{'a': ['apple', 'atom'], 'b': ['bat', 'bar', 'book']}\n-------------------------------------------------------\n{'a': ['apple', 'atom'], 'b': ['bat', 'bar', 'book']}\n-------------------------------------------------------\ndefaultdict(&lt;class 'list'&gt;, {}) &lt;class 'collections.defaultdict'&gt;\ndefaultdict(&lt;class 'list'&gt;, {'a': ['apple', 'atom'], 'b': ['bat', 'bar', 'book']})\n\n\nUnderstanding Dictionary Key Types\nIn Python, dictionaries are versatile data structures used for mapping keys to corresponding values. While dictionaries allow flexibility in storing values of any Python data type as their values, there are specific requirements and considerations when it comes to selecting suitable key types. This aspect of dictionary design is crucial to ensure efficient and reliable key-value pair lookups and operations.\nKey Characteristics of Dictionary Keys\n\nImmutability Requirement:\nThe primary requirement for dictionary keys is that they should generally be immutable objects. Immutability refers to the property of an object that prevents its state from being modified after it is created.\nExamples of Immutable Key Types:\n\nScalar Types: Examples of immutable scalar types suitable as dictionary keys include integers (int), floating-point numbers (float), and strings (str). These types are inherently immutable, which means once you create a key with a specific value, that key-value pair remains consistent.\nTuples as Composite Keys: Tuples can also serve as dictionary keys, but there’s an important condition: all the objects within the tuple must also be immutable. This ensures the stability of the key, as the tuple itself remains unchanged.\n\n\nThe Significance of Hashability\nThe technical term that ties these requirements together is “hashability.” Hashability refers to an object’s ability to be hashed, which involves converting the object into a fixed-size numerical value, known as a hash code. This hash code is used as an index to efficiently store and retrieve key-value pairs in a dictionary. The key feature of hashable objects is that they produce the same hash code consistently.\nThe Role of the hash() Function\nYou can determine whether an object is hashable and can be used as a dictionary key by utilizing the built-in hash() function. When you apply the hash() function to an object, it returns a hash code if the object is hashable. However, keep in mind that not all Python objects are hashable, particularly mutable objects like lists and dictionaries.\n\n# Using hash() to validate key types in dictionary\n\nhash(\"string\")           # hashable\nhash((1, 2, (2, 3)))     # hashable\n# hash((1, 2, [2, 3]))     # Not hashable due to mutable element - list of [2, 3]\n\n# When in need of list for key, convert it tp tuple, hashable\nd = {}\nd[tuple([1,2,3])] = 5\nprint(d)  # dictionary with a tuple as key\n\n{(1, 2, 3): 5}\n\n\n\n\n\nSets in Python: A Set is an essential data structure that represents an unordered collection of unique elements. Unlike lists or tuples, which allow duplicates, sets only store distinct values. This characteristic makes sets ideal for various tasks, such as removing duplicates from a list, checking for membership, and performing set operations like union, intersection, and difference. One of the most common real-world use cases for sets is in data deduplication, where they excel at efficiently eliminating duplicate records from datasets, ensuring data integrity and enhancing the performance of data processing tasks.\n\n# Create a set\nprint(set([2, 2, 2, 1, 3, 3]))\nprint\n\n# Union, Difference, Intersection and Symmetric Difference\na = {1, 2, 3, 4, 5}\nb = {3, 4, 5, 6, 7, 8}\nprint (\"Set a:\", a, \" Set b:\", b)\n\n# a.union(b) = a | b\nprint(\"a union b: \", a.union(b), a | b)\n# a.intersection(b) = a & b\nprint(\"a intersection b: \", a.intersection(b), a & b)\n# a.difference(b) = a - b\nprint(\"a difference b: \", a.difference(b), a - b)\n# a.symmetric_difference(b)\nprint(\"a.symmetric_difference(b): \", a.symmetric_difference(b), a ^ b)\n\n{1, 2, 3}\nSet a: {1, 2, 3, 4, 5}  Set b: {3, 4, 5, 6, 7, 8}\na union b:  {1, 2, 3, 4, 5, 6, 7, 8} {1, 2, 3, 4, 5, 6, 7, 8}\na intersection b:  {3, 4, 5} {3, 4, 5}\na difference b:  {1, 2} {1, 2}\na.symmetric_difference(b):  {1, 2, 6, 7, 8} {1, 2, 6, 7, 8}\n\n\n\n# Common set operations\na = {1, 2, 3, 4, 5}\n\n# a.add(x) - Add x to the set\na.add(\"Fox\")\nprint(a)\n# a.remove(x) - Remove x from the set\na.remove(\"Fox\")\nprint(a)\n# a.pop() - Remove an element arbitrarily, set must not be empty\nret = a.pop()\nprint(a, ret)\n\n\n\n# a.clear() - reset to empty\nprint(a.clear())  # None - empty\n\n{1, 2, 3, 4, 5, 'Fox'}\n{1, 2, 3, 4, 5}\n{2, 3, 4, 5} 1\nNone\n\n\nBuilt-in Sequence Functions\n\na_list = [7, 1, 2, 6, 0, 3, 2]\n\n# Very useful, use at every opportunities\n\n# enumerate() - no need to write code to track index\nfor index, value in enumerate(a_list):\n  print(index, \" : \", value)  \n\n# sorted() - a new srted list from the elements of any sequence\nprint(sorted(a_list))\nprint(sorted(\"horse race\"))  # string is a sequence\n\n# zip() - pairs up sequences element-wise to create a list\nseq1 = [\"foo\", \"bar\", \"baz\"]\nseq2 = [\"one\", \"two\", \"three\"]\nseq3 = [\"BROWN\", \"FOX\", \"FENCE\", \"JUMP\"]\nzipped = zip(seq1, seq2, seq3)\nprint(list(zipped))  # \"JUMP\" ignored for pariing!\n\n# zip() commonly works with enumerate() for iteration - zip and iterate\nfor index, (a, b) in enumerate(zip(seq1, seq2)):\n  print(f\"{index}: {a}, {b}\")\n\n# reversed()\nreversed(range(10)) # range_iterator object, it's a generator\nprint(list(reversed(range(10)))) # list() materializes the generator\n\n0  :  7\n1  :  1\n2  :  2\n3  :  6\n4  :  0\n5  :  3\n6  :  2\n[0, 1, 2, 2, 3, 6, 7]\n[' ', 'a', 'c', 'e', 'e', 'h', 'o', 'r', 'r', 's']\n[('foo', 'one', 'BROWN'), ('bar', 'two', 'FOX'), ('baz', 'three', 'FENCE')]\n0: foo, one\n1: bar, two\n2: baz, three\n[9, 8, 7, 6, 5, 4, 3, 2, 1, 0]\n\n\n\n\n\nComprehensions in Python offer concise, readable, and often more efficient ways to create lists, sets, and dictionaries. They reduce code verbosity, enhance readability, and promote a functional programming style, ultimately leading to cleaner and more maintainable code.\nList Comprehension:\nList comprehensions provide a concise way to create lists by applying an expression to each item in an iterable (e.g., a list, tuple, or range) and optionally filtering the items based on a condition.\n\n## [exp for value in collection if condition]\n\n# create a list of strings in uppercase only if the string has more than two characters.\nstrings = [\"a\", \"as\", \"bat\", \"car\", \"dove\", \"python\"]\nstrings_2 = [ str.upper() for str in strings if len(str) &gt; 2 ]\nprint(strings_2)\n\n# create a list of squares of even numbers from 0 to 9\neven_squares = [ x ** 2 for x in range(10) if x % 2 == 0 ]\nprint(even_squares)\n\n['BAT', 'CAR', 'DOVE', 'PYTHON']\n[0, 4, 16, 36, 64]\n\n\nSet Comprehension:\nSet comprehensions allow you to create sets in a similar manner to list comprehensions, but with the guarantee of uniqueness among elements.\n\n## set_comp = {expr for value in collection if condition}\n\n# Create a set using strings list above, containing only the lengths of strings.\nstrings = [\"a\", \"as\", \"bat\", \"car\", \"dove\", \"python\"]\nunique_lengths = { len(str) for str in strings } # uniqueness guaranted\nprint(unique_lengths)\n\n# map() - even more powerful\nstrings_map = set(map(len, strings))\nprint(strings_map)\n\n# Create a set of unique even squares from 0 to 9\neven_squares_set = {x ** 2 for x in range(10) if x % 2 == 0}\nprint(even_squares_set)\n\n{1, 2, 3, 4, 6}\n{1, 2, 3, 4, 6}\n{0, 64, 4, 36, 16}\n\n\nDictionary Comprehension:\nDictionary comprehensions enable the creation of dictionaries by defining key-value pairs based on expressions applied to items in an iterable.\n\n## {key_expression: value_expression for item in iterable if condition}\n\n# Create a dictionary, mapping even numbers to their squares from 0 to 9\neven_squares_dict = { x: x**2 for x in range(10) if x % 2 == 0 }\nprint(even_squares_dict)\n\n# Create a dictionary of lookup map of string for the location of each string in the list\nstrings = [\"a\", \"as\", \"bat\", \"car\", \"dove\", \"python\"]\nstring_lookup_dict = { str: index for index, str in enumerate(strings) }\nprint(strings)\nprint(string_lookup_dict)\n\n{0: 0, 2: 4, 4: 16, 6: 36, 8: 64}\n['a', 'as', 'bat', 'car', 'dove', 'python']\n{'a': 0, 'as': 1, 'bat': 2, 'car': 3, 'dove': 4, 'python': 5}\n\n\nNested list comprehensions\nThe order of\n\n# List of lists with some English and Spanish names - List nesting lists\nall_data = [\n  [\"John\", \"Emily\", \"Michael\", \"Mary\", \"Steven\"],\n  [\"Maria\", \"Juan\", \"Javier\", \"Natalia\", \"Pilar\"]\n]\nprint(all_data)\nprint(\"-\"*55)\n\n# Create a list of names contating two of more of 'a'\n# The non-Pythonic apporach using for loop..\nnames_of_interest = []\nfor names in all_data:\n  print(\"Processing:\", names)\n  enough_as = [ name for name in names if name.count(\"a\") &gt;=2 ]\n  print(enough_as)\n  names_of_interest.extend(enough_as)\nprint(\"Results: \", names_of_interest)\n\n# Re-writtine in one-liner using nested list comprehension\nnames_of_interest = [ name for names in all_data for name in names if name.count(\"a\") &gt;=2 ]\nprint(\"Result using Nested List Comprehension: \", names_of_interest)\n\n# Flatten a list of tuples of integers into a simple list of integers using nested list comprehension\nsome_tuples = [(1, 2, 3), (4, 5, 6), (7, 8, 9)]\nprint(some_tuples, type(some_tuples)) # list of tuples with integers\nflattened = [ int for tuple in some_tuples for int in tuple ]\nprint(\"Flattened: \", flattened, type(flattened))  # flattend list\n\n# Readability and valid forms\nflattened = []\nprint(\"Init. flattened list: \", flattened)\nprint(\"some_tuples: \", some_tuples)\nfor tup in some_tuples:\n  for x in tup:\n    flattened.append(x)\nprint(\"flattend from some_tuples: \", flattened)\n\n# list comprehenson inside list comprehension\n# Change list of tuples to a list of lists\nprint(\"Init. list of some_tuples: \", some_tuples)\nnew_list_of_lists = [[ x for x in tup ] for tup in some_tuples ]\nprint(\"List of lists from some_tuples: \", new_list_of_lists)\n\n[['John', 'Emily', 'Michael', 'Mary', 'Steven'], ['Maria', 'Juan', 'Javier', 'Natalia', 'Pilar']]\n-------------------------------------------------------\nProcessing: ['John', 'Emily', 'Michael', 'Mary', 'Steven']\n[]\nProcessing: ['Maria', 'Juan', 'Javier', 'Natalia', 'Pilar']\n['Maria', 'Natalia']\nResults:  ['Maria', 'Natalia']\nResult using Nested List Comprehension:  ['Maria', 'Natalia']\n[(1, 2, 3), (4, 5, 6), (7, 8, 9)] &lt;class 'list'&gt;\nFlattened:  [1, 2, 3, 4, 5, 6, 7, 8, 9] &lt;class 'list'&gt;\nInit. flattened list:  []\nsome_tuples:  [(1, 2, 3), (4, 5, 6), (7, 8, 9)]\nflattend from some_tuples:  [1, 2, 3, 4, 5, 6, 7, 8, 9]\nInit. list of some_tuples:  [(1, 2, 3), (4, 5, 6), (7, 8, 9)]\nList of lists from some_tuples:  [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n\n\n\n# 6 Practical use caes of nested list comprehension\n\n# 1. Matrix operations:\n# Add 1 to each element in a 2D matrix\nmatrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\nmatrix_add_1 = [[ element + 1 for element in row] for row in matrix]\nprint(\"matrix_add_1: \", matrix_add_1)\n\n# 2. Data transformation:\n# Filter rows with even some from a list of lists\ndata = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\nfiltered_data = [ row for row in data if sum(row) % 2 == 0 ]\nprint(\"filtered_data: \", filtered_data)\n\n# 3. Flattening lists of lists:\nnested_lists = [[1, 2], [3, 4], [5, 6]]\nflattened_list = [ item for sublist in nested_lists for item in sublist ]\nprint(\"flattened_list: \", flattened_list)\n\n# 4. Combining data:\n# Create all possible pairs (in tuple) from two lists - Different from element-wise pairing using zip()\nlist1 = [1, 2, 3]\nlist2 = ['a', 'b', 'c']\ncombinations = [ (x, y) for x in list1 for y in list2 ]\nprint(\"combinations: \", combinations)\n\n# 5. Conditional filtering:\n# Filter rows containing 'John' from a list of lists\ndata = [['Alice', 25], ['John', 30], ['Bob', 35]]\nfiltered_data = [ list for list in data if 'John' in list ]\nprint(\"filtered_data: \", filtered_data)\n\n# 6. Transposing data:\n# Transpose a given matrix (switching rows and columns)\nmatrix = [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]]\ntransposed_matrix = [[ (row[i], print(\"row[i]: \", row[i]), print(\"processing row: \", row)) for row in matrix ] for i in range(len(matrix[0]))]\n#print(\"transposed_matrix: \", transposed_matrix)\n#print(len(matrix[0]))\n#print(range(len(matrix[0])))\n\nmatrix_add_1:  [[2, 3, 4], [5, 6, 7], [8, 9, 10]]\nfiltered_data:  [[1, 2, 3], [7, 8, 9]]\nflattened_list:  [1, 2, 3, 4, 5, 6]\ncombinations:  [(1, 'a'), (1, 'b'), (1, 'c'), (2, 'a'), (2, 'b'), (2, 'c'), (3, 'a'), (3, 'b'), (3, 'c')]\nfiltered_data:  [['John', 30]]\nrow[i]:  1\nprocessing row:  [1, 2, 3, 4]\nrow[i]:  5\nprocessing row:  [5, 6, 7, 8]\nrow[i]:  9\nprocessing row:  [9, 10, 11, 12]\nrow[i]:  2\nprocessing row:  [1, 2, 3, 4]\nrow[i]:  6\nprocessing row:  [5, 6, 7, 8]\nrow[i]:  10\nprocessing row:  [9, 10, 11, 12]\nrow[i]:  3\nprocessing row:  [1, 2, 3, 4]\nrow[i]:  7\nprocessing row:  [5, 6, 7, 8]\nrow[i]:  11\nprocessing row:  [9, 10, 11, 12]\nrow[i]:  4\nprocessing row:  [1, 2, 3, 4]\nrow[i]:  8\nprocessing row:  [5, 6, 7, 8]\nrow[i]:  12\nprocessing row:  [9, 10, 11, 12]\n\n\n\n\n\nFunctions in Python are a cornerstone of the language, offering powerful tools for structuring and modularizing code. Python functions come with several unique features that distinguish them from functions in other programming languages.\n\nVersatile and Expressive: Python functions support both positional and keyword arguments, enabling flexible and expressive function calls.\nMultiple Return Values: Python functions can return multiple values, simplifying the packaging and unpacking of results.\nDefault Argument Values: Python functions allow for default argument values, making function usage more straightforward by providing sensible defaults when arguments are omitted.\nLambda Functions: Python features lambda functions for concise and anonymous function definitions, particularly useful for simple operations.\nFirst-Class Functions: Python treats functions as first-class citizens, allowing them to be assigned to variables, passed as arguments, and returned from other functions. This flexibility enhances code modularity, maintainability, and readability.\nModular and Reusable: Python’s function-centric approach encourages the creation of clean, reusable, and modular code, making it a crucial topic for all Python programmers to master.\n\n\n# simple declaration and calling\ndef my_function(x,y):\n  return x + y\n\nret = my_function(1, 2)\nprint(ret)\n\n# Return None when no retorn statement is encountered\ndef funciton_without_return(x):\n  print(x)\nresult = funciton_without_return(\"hello!\")\nprint(result)\n\n# positional and keyword arguments\ndef my_function2(x, y, z=1.5):  # z as keyword argument with default value\n  if z &gt; 1:\n    return z * (x + y)\n  else:\n    return z / (x + y)\n\n# Naespace, scope and local functions\n\n\nprint(my_function2(5, 6, z=0.7))  # no need to put arg names, keword arg optional\nprint(my_function2(3.14, 7, 3.5))  # no need to specify name for kewoord arguments\nprint(my_function2(10, 20))   # keyword arg optional\n\n\na = []\ndef func():\n  for i in range(5):\n    a.append(i)\n\nfunc()\n\n3\nhello!\nNone\n0.06363636363636363\n35.49\n45.0\n\n\n\n# Assigining variable outside the function's scope\n\na = None\ndef bind_a_variable():\n  global a\n  a = []\n  \nbind_a_variable()\nprint(a)\n\n# multiple returns\ndef f():\n  a = 5\n  b = 6\n  c = 7\n  return a, b, c\n\na, b, c = f()\nprint(a, b)\n\n[]\n5 6\n\n\nFunctions Are Objects\nIn Python, functions are first-class objects, which means they are treated like any other object, such as integers, strings, or lists. This concept is a fundamental part of the Python language and has several implications and practical uses.\n\nFunctions can be assigned to variables:\n\n\n# Functions can be assigned to variables:\n\ndef greet(name):\n    return f\"Hello, {name}!\"\n\ngreeting = greet  # function assigned to variable \nprint(greeting(\"Alice\"))  # calling the function using the assigned variable\n\nprint(id(greet), id(greeting)) # both variable and function references the same object\n\nHello, Alice!\n1808218897312 1808218897312\n\n\n\nFunctions can be passed as arguments: This is particularly useful for functions that require a callback or custom behavior.\n\n\n# Functions can be passed as arguments\n\ndef apply(func, value):\n  return func(value)\n\ndef double(x):\n  return x * 2\n\nresult = apply(double, 5)\nprint(result)\n\n10\n\n\n\nFunctions can be returned from other functions: This enables dynamic function generation.\n\n\n# Functinos can be returned from other functions\ndef create_multiplier(factor):\n  \"\"\"\n  Returns a FUNCTION that produce the result of given factor * x\n  \"\"\"\n  def multiplier(x):\n    return x * factor\n  return multiplier    # return the inner function\n\ndouble = create_multiplier(2)\nprint(double(200))  # Result is a function returned by 'created_multiplier'\nprint(double(400))\n\n400\n800\n\n\nFunctions can be stored in data structures\nFunctions can be stored in data structures like lists, dictionaries, or sets, making it possible to manage and manipulate functions dynamically.\n\n# Functinos can be stored in data structures\n\ndef square(x):\n  return x**2\n\ndef cube(x):\n  return x**3\n\nmath_functions = [square, cube]\nresult = math_functions[1](3)  # access and call the 'cube' function, give 3 to the parameter\nprint(result)\n\n\n# Using a list of functinos for cleaning strings from survey data\nanswer_states = [\"   alabama \", \"georgia!\", \"Georgia\",  \\\n          \"georgia\", \"flOrIda\", \"south   carolina##\",   \\\n          \"West virginia?\"]\nprint(answer_states)\n          \ndef remove_punctuation(value):\n  return re.sub(\"[!#?]\", \"\", value)\n\nclean_ops = [str.strip, remove_punctuation, str.title] # 3 functinos in list for cleaning operation\n\nimport re\n\ndef clean_strings(strings, ops):\n    result = []\n    for value in strings:\n        for func in ops:\n            value = func(value)\n        result.append(value)\n    return result\n  \nprint(\"strings_cleaned: \", clean_strings(answer_states, clean_ops))\n\nprint(\"-\"*55)\n\n\n# Using map() to apply a function as argument to a sequence\nfor x in map(remove_punctuation, answer_states):\n  print(x)\n\n27\n['   alabama ', 'georgia!', 'Georgia', 'georgia', 'flOrIda', 'south   carolina##', 'West virginia?']\nstrings_cleaned:  ['Alabama', 'Georgia', 'Georgia', 'Georgia', 'Florida', 'South   Carolina', 'West Virginia']\n-------------------------------------------------------\n   alabama \ngeorgia\nGeorgia\ngeorgia\nflOrIda\nsouth   carolina\nWest virginia\n\n\nAnonymous (Lambda) Functions:\nAnonymous functions, often referred to as “lambda functions,” are a concise way to create small, inline functions without giving them a formal name. In Python, lambda functions are defined using the lambda keyword, followed by parameters and an expression. While they are limited in scope compared to regular functions, they offer several benefits:\nConciseness: Lambda functions are compact and allow you to define simple operations in a single line of code, making them particularly useful for short, one-off functions.\nReadability: When used appropriately, lambda functions can improve code readability by encapsulating a specific operation right where it’s needed, reducing the need for named functions or temporary variables.\nFunctional Programming: Lambda functions are a key component of functional programming in Python. They can be used with higher-order functions like map(), filter(), and reduce() to perform operations on collections of data.\n\n# sort a list of tuples by the second element:\ndata = [(1, 5), (3, 2), (2, 8)]\nsorted_data = sorted(data, key=lambda x: x[1])  # extracts the second element (index 1) of each tuple in the data list\nprint(sorted_data)\n\n[(3, 2), (1, 5), (2, 8)]\n\n\n\n# filter even numbers from a list\nnumbers = [1, 2, 3, 4, 5, 6]\neven_numbers = list(filter(lambda x: x % 2 == 0, numbers))  # filtering function, iterables\nprint(even_numbers)\n\n[2, 4, 6]\n\n\n\n# Mapping a Function to a List\n\nvalues = [1, 2, 3, 4, 5]\nsquared_values = list(map(lambda x: x**2, values))\nprint(squared_values)\n\n[1, 4, 9, 16, 25]\n\n\n\ndef short_function(x):\n  return x * 2\nprint(short_function(100))\n\nequiv_amon = lambda x: x * 2  # assign a function to variable\nprint(type(equiv_amon))\nprint(equiv_amon(100))  # produces the same result\nprint(\"-\"*55)\n\n# use a lambda function for the second argument\ndef apply_to_list(some_list, f):\n  \"\"\"\n  Apply the given function to the given list\n  \"\"\"\n  return [f(x) for x in some_list]\nints = [4, 0, 1, 5, 6]\n\nret = apply_to_list(ints, lambda x: x*2)\nprint(ret)\n\n# sort the list of strings based on the number of unique charaters for each string.\n\n200\n&lt;class 'function'&gt;\n200\n-------------------------------------------------------\n[8, 0, 2, 10, 12]"
  },
  {
    "objectID": "posts/p4da3d-data-types.html#built-in-data-structures-functions-and-files",
    "href": "posts/p4da3d-data-types.html#built-in-data-structures-functions-and-files",
    "title": "3. Built-In Data Structures, Functions, and Files",
    "section": "",
    "text": "Python Tuples: Immutable, ordered collections that allow you to store a sequence of elements. Tuples are defined using parentheses and can hold a mix of data types. They offer efficient data storage, are iterable, and can be used as keys in dictionaries. In this blog, we’ll explore the versatility of Python tuples and how to leverage them for various data analysis tasks.\n\n# create some tuples\ntup = (4, 5, 6)\ntup2 = 7, 8, 9\ntup\ntup2\ntup, tup2     # tuple of tuples\ntype(tup2)\n\n# convert any sequence or iterator to tuple\ntuple(['a', 'b', 'c'])\ntuple('Some String')\n\n('S', 'o', 'm', 'e', ' ', 'S', 't', 'r', 'i', 'n', 'g')"
  },
  {
    "objectID": "posts/p4da3d-data-types.html#chapter-3-built-in-data-structures-functions-and-files",
    "href": "posts/p4da3d-data-types.html#chapter-3-built-in-data-structures-functions-and-files",
    "title": "[3] Built-In Data Structures, Functions, and Files",
    "section": "",
    "text": "Python Tuples: Immutable, ordered collections that allow you to store a sequence of elements. Tuples are defined using parentheses and can hold a mix of data types. They offer efficient data storage, are iterable, and can be used as keys in dictionaries. In this blog, we’ll explore the versatility of Python tuples and how to leverage them for various data analysis tasks.\n\n# create some tuples\ntup = (4, 5, 6)\ntup2 = 7, 8, 9\nprint(tup)\nprint(tup2)\nt = (tup, tup2)    # tuple of tuples\nprint(t)\ntype(t)\n\n# convert any sequence or iterator to tuple\nprint(tuple(['a', 'b', 'c']))\nprint(tuple('Some String'))\n\n# access elements\nnested_tup = ((4,5,6), (7,8))\nprint(nested_tup)\n\n(4, 5, 6)\n(7, 8, 9)\n((4, 5, 6), (7, 8, 9))\n('a', 'b', 'c')\n('S', 'o', 'm', 'e', ' ', 'S', 't', 'r', 'i', 'n', 'g')\n((4, 5, 6), (7, 8))"
  },
  {
    "objectID": "posts/p4da3d-data-types.html#data-structures-and-sequences",
    "href": "posts/p4da3d-data-types.html#data-structures-and-sequences",
    "title": "[3] Built-In Data Structures, Functions, and Files",
    "section": "",
    "text": "Python Tuples: Immutable, ordered collections that allow you to store a sequence of elements. Tuples are defined using parentheses and can hold a mix of data types. They offer efficient data storage, are iterable, and can be used as keys in dictionaries. In this blog, we’ll explore the versatility of Python tuples and how to leverage them for various data analysis tasks.\n\n# create some tuples\ntup = (4, 5, 6)\ntup2 = 7, 8, 9\nprint(tup)\nprint(tup2)\nt = (tup, tup2)    # tuple of tuples\nprint(t)\ntype(t)\n\n# convert any sequence or iterator to tuple\nprint(tuple(['a', 'b', 'c']))\nprint(tuple('Some String'))\n\n# access elements\nnested_tup = ((4,5,6), (7,8))\nprint(nested_tup[1])\n\n(4, 5, 6)\n(7, 8, 9)\n((4, 5, 6), (7, 8, 9))\n('a', 'b', 'c')\n('S', 'o', 'm', 'e', ' ', 'S', 't', 'r', 'i', 'n', 'g')\n(7, 8)\n\n\nTuple itself is immutable; however, if an object inside a tuple is mutable, you can modify it in place.\n\ntup = tuple(['The bown ','fox ', 'jumped over the ',['fence.']])\nprint(tup)\n# tup[1] = 'wolf'           # error\ntup[3][0] = 'window '     # ok\nprint(tup)\ntup[3].append('fence')    # ok\nprint(tup)\n\n('The bown ', 'fox ', 'jumped over the ', ['fence.'])\n('The bown ', 'fox ', 'jumped over the ', ['window '])\n('The bown ', 'fox ', 'jumped over the ', ['window ', 'fence'])\n\n\nConcatenation, Variable swap, Unpacking\n\n# concatenation using +\ntup = (4, None, 'foo') + (6, 0) + ('bar',)\nprint(tup)\n\n# Swap\na, b = 1, 2\nprint(a, b)\nb, a = a, b\nprint(a, b)\n\n# Unpacking by iterating over sequences of tuples, lists\nseq = [('a1', 'a2', 'a3'),('b4', 'b5', 'b6'), ('c7', 'c8', 'c9')]\nprint(seq, type(seq))\nfor a, b, c in seq:\n  print(f'a={a}, b={b}, c={c}')\n  \n# unpacking using assignment, not concerning some trailing values\nvalues = 1, 2, 3, 4, 5, 6, 7\na, b, *_ = values     # *rest works the same as *_\nprint (a, b, *_)\n\n# method .count()\na = (1, 2, 2, 2, 3, 4, 2)\nprint(a.count(2))     # number of occurences\n\n(4, None, 'foo', 6, 0, 'bar')\n1 2\n2 1\n[('a1', 'a2', 'a3'), ('b4', 'b5', 'b6'), ('c7', 'c8', 'c9')] &lt;class 'list'&gt;\na=a1, b=a2, c=a3\na=b4, b=b5, c=b6\na=c7, b=c8, c=c9\n1 2 3 4 5 6 7\n4\n\n\n\n\n\nPython Lists: Ordered, mutable collections that allow you to store and manipulate sequences of items. Lists are versatile and can hold various data types. They support methods for adding, removing, and modifying elements, making them a fundamental data structure for data analysis and manipulation in Python.\n\n# create, convert lists\na_list = [2, 3, 7, None]\ntup = (\"foo\", \"bar\", \"baz\")\nb_list = list(tup)\nprint(b_list, type(b_list))\n\n# Access, modify list element\nb_list[1] = \"peekaboo\"\nprint(b_list)\n\n# Materialize an iterator / generator\ngen = range(20) # generator, not materialized yet.\nprint(gen) \nlist(gen) # materialize the generator to list\n\n# Work with the elements\nb_list.append(\"dwarf\")     # add to the end of list\nb_list.append(\"foo\")\nprint(b_list)\nb_list.insert(1, \"RED\")     # insert at specific location, consider using collections.deque for efficiency\nprint(b_list)\nb_list.remove(\"foo\")        # remove the first occurence only\nprint(b_list)\n\n# Check if element in the list\nprint(\"dwarf\" in b_list)\nprint(\"dwarf\" not in b_list)\n\n['foo', 'bar', 'baz'] &lt;class 'list'&gt;\n['foo', 'peekaboo', 'baz']\nrange(0, 20)\n['foo', 'peekaboo', 'baz', 'dwarf', 'foo']\n['foo', 'RED', 'peekaboo', 'baz', 'dwarf', 'foo']\n['RED', 'peekaboo', 'baz', 'dwarf', 'foo']\nTrue\nFalse\n\n\n\n# Concatenate and combine lists\nnew_list = [4, None, \"foo\"] + [7, 8, (2, 3)]\nprint(new_list)\nprint(b_list)\nnew_list.extend(b_list)\nprint(new_list)\n\n# Sorting in place\na = [\"saw\", \"small\", \"He\", \"foxes\", \"six\"]\na.sort() # default\nprint(a)\na.sort(key=len) # sort by key with given function, by the length of each element\nprint(a)\n\n# Sorted copy\na = [\"saw\", \"small\", \"He\", \"foxes\", \"six\"]\nsorted_copy = sorted(a)\nprint(sorted_copy)\n\n[4, None, 'foo', 7, 8, (2, 3)]\n['RED', 'peekaboo', 'baz', 'dwarf', 'foo']\n[4, None, 'foo', 7, 8, (2, 3), 'RED', 'peekaboo', 'baz', 'dwarf', 'foo']\n['He', 'foxes', 'saw', 'six', 'small']\n['He', 'saw', 'six', 'foxes', 'small']\n['He', 'foxes', 'saw', 'six', 'small']\n\n\n\n# Slices\n\nseq = [7, 2, 3, 7, 5, 6, 0, 1]\nprint(seq)\nprint(seq[1:5])   # index:1 - index: 4\nprint(seq[:5])    # index:beginning - index: 4\nprint(seq[5:])    # index:5 - index:last\nprint(seq[-4:])   # Indexing from the last, index:-4 to the end\nprint(seq[-6:-2]) # Indexing from the last, index: -6 to index: -2\n\nprint(\"-\"*30)\n\n# Stepping the list\nprint(seq[::2])     # Extract index 0, 2, 4, 6 ....\nprint(seq[::3])     # Extract index 0, 3, 6 ....\nprint(seq[::-2])    # Extract index -1, -3, -5 .....\nprint(seq[::-1])    # Extract index -1, -2, -3, -4 ... effectively reverse the list or tuple\n\n\nprint(\"-\"*30)\n\n# Slices replacement\nseq[3:5] = ['A','B']\nprint(seq)\n\n[7, 2, 3, 7, 5, 6, 0, 1]\n[2, 3, 7, 5]\n[7, 2, 3, 7, 5]\n[6, 0, 1]\n[5, 6, 0, 1]\n[3, 7, 5, 6]\n------------------------------\n[7, 3, 5, 0]\n[7, 7, 0]\n[1, 6, 7, 2]\n[1, 0, 6, 5, 7, 3, 2, 7]\n------------------------------\n[7, 2, 3, 'A', 'B', 6, 0, 1]\n\n\n\n\n\nPython Dictionaries: Versatile and dynamic data structures that store key-value pairs, allowing for efficient data retrieval and manipulation. Dictionaries are unordered collections that provide a way to map unique keys to associated values, making them invaluable for tasks like data storage, lookup tables, and configuration settings\n\n# Create a Dictionary (aka, hash-map, associative arrays)\n\nempty_dict = {} \nprint(empty_dict)\nd1 = {\"a\": \"some value\", \"b\": [1, 2, 3, 4]}  # key-value pair\nprint(d1)\n\n# Access, insert and set\nd1[7] = \"an integer\"      # 7:\"an integer\" pair\nprint(d1)\nprint(d1[\"b\"])            # lookup with key\n#print(d1[\"address\"])     # KeyError\nprint(\"address\" in d1)    # key exists?\n\nprint(\"-\"*30)\n\n# Delete values\ndel d1[7]              # delete with key\n#del d1[\"country\"]     # KeyError\nprint(d1)\nret = d1.pop(\"b\")      # delete with key and return the value\nprint(ret)\nprint(d1)\n\nprint(\"-\"*30)\n\n# Iteration using keys() values() items()\nd1 = {'a': 'some value', 'b': [1, 2, 3, 4], 7: 'an integer'}\nprint(type(d1.keys()))     # &lt;class 'dict_keys'&gt;\nprint(type(d1.values()))   # &lt;class 'dict_values'&gt;\n\nd1_keys = list(d1.keys())   \nd1_values = list(d1.values())\nd1_items = list(d1.items())  # Gives a list of tuples in (key, value)\nprint(d1_keys)\nprint(d1_values)\nprint(d1_items)  \n\n# iteration\nfor key, value in d1.items():\n  print(f'Key: \\\"{key}\\\" has value of \\\"{value}\\\".')\n\n{}\n{'a': 'some value', 'b': [1, 2, 3, 4]}\n{'a': 'some value', 'b': [1, 2, 3, 4], 7: 'an integer'}\n[1, 2, 3, 4]\nFalse\n------------------------------\n{'a': 'some value', 'b': [1, 2, 3, 4]}\n[1, 2, 3, 4]\n{'a': 'some value'}\n------------------------------\n&lt;class 'dict_keys'&gt;\n&lt;class 'dict_values'&gt;\n['a', 'b', 7]\n['some value', [1, 2, 3, 4], 'an integer']\n[('a', 'some value'), ('b', [1, 2, 3, 4]), (7, 'an integer')]\nKey: \"a\" has value of \"some value\".\nKey: \"b\" has value of \"[1, 2, 3, 4]\".\nKey: \"7\" has value of \"an integer\".\n\n\n\n# Update dictionary with a dictionary of new or changes of key-value pairs\nd1 = {'a': 'some value', 'b': [1, 2, 3, 4], 7: 'an integer'}\nprint(d1)\nd1.update({\"b\": \"foo\", \"c\": 12})\nprint(d1)\n\n{'a': 'some value', 'b': [1, 2, 3, 4], 7: 'an integer'}\n{'a': 'some value', 'b': 'foo', 7: 'an integer', 'c': 12}\n\n\n\n# Create a dictionary from two sequences\n\nlist_country = [\"USA\", \"Canada\", \"England\", \"France\"]\nlist_city = [\"Washigton\", \"Ottawa\", \"London\", \"Paris\"]\nprint(list_country)\nprint(list_city)\n\n# Using for loop - zip and iterate\nprint(zip(list_country, list_city))\n\nmapping = {}\nfor key, value in zip(list_country, list_city):\n  mapping[key] = value\nprint(mapping, type(mapping))\n\n# Using dict() method\ncountry_city_tuples = zip(list_country, list_city)\nprint(country_city_tuples, type(country_city_tuples))\nmapping = dict(country_city_tuples)\nprint(mapping, type(mapping))\n\n['USA', 'Canada', 'England', 'France']\n['Washigton', 'Ottawa', 'London', 'Paris']\n&lt;zip object at 0x000001A5023FF5C0&gt;\n{'USA': 'Washigton', 'Canada': 'Ottawa', 'England': 'London', 'France': 'Paris'} &lt;class 'dict'&gt;\n&lt;zip object at 0x000001A5023FE900&gt; &lt;class 'zip'&gt;\n{'USA': 'Washigton', 'Canada': 'Ottawa', 'England': 'London', 'France': 'Paris'} &lt;class 'dict'&gt;\n\n\n\n# Build a dictionary WUTHOUT using setdefault()\nwords = [\"apple\", \"bat\", \"bar\", \"atom\", \"book\"]\nprint(words, type(words))\n\nby_letter = {}\n\nfor word in words:\n  letter = word[0] # Using the first letter of each word as key\n  if letter not in by_letter:\n    by_letter[letter] = [word]\n  else:\n    by_letter[letter].append(word)\n\nprint(by_letter)\n\nprint(\"-\"*55)\n\n# Simplified version using setdefault()\n\nwords = [\"apple\", \"bat\", \"bar\", \"atom\", \"book\"]\nby_letter = {}\nfor word in words:\n  letter = word[0] # Using the first letter of each word as key\n  by_letter.setdefault(letter, []).append(word) # If the letter (the first letter of the current word) is already a key in the dictionary, it returns the corresponding value (which is a list) for that key. If the key doesn't exist, it initializes an empty list. The append() method is then used to add the current word to the list associated with the letter key.\nprint(by_letter)\n\nprint(\"-\"*55)\n\n# Using defaultdict from collections module\nfrom collections import defaultdict\n\nwords = [\"apple\", \"bat\", \"bar\", \"atom\", \"book\"]\nby_letter = defaultdict(list) # if you access a key that doesn't exist, it will automatically create that key with an empty list as the associated value. This is particularly useful when you want to avoid KeyError exceptions when working with dictionaries.\nprint(by_letter, type(by_letter))\n\nfor word in words:\n  by_letter[word[0]].append(word)\n\nprint(by_letter)\n\n['apple', 'bat', 'bar', 'atom', 'book'] &lt;class 'list'&gt;\n{'a': ['apple', 'atom'], 'b': ['bat', 'bar', 'book']}\n-------------------------------------------------------\n{'a': ['apple', 'atom'], 'b': ['bat', 'bar', 'book']}\n-------------------------------------------------------\ndefaultdict(&lt;class 'list'&gt;, {}) &lt;class 'collections.defaultdict'&gt;\ndefaultdict(&lt;class 'list'&gt;, {'a': ['apple', 'atom'], 'b': ['bat', 'bar', 'book']})\n\n\nUnderstanding Dictionary Key Types\nIn Python, dictionaries are versatile data structures used for mapping keys to corresponding values. While dictionaries allow flexibility in storing values of any Python data type as their values, there are specific requirements and considerations when it comes to selecting suitable key types. This aspect of dictionary design is crucial to ensure efficient and reliable key-value pair lookups and operations.\nKey Characteristics of Dictionary Keys\n\nImmutability Requirement:\nThe primary requirement for dictionary keys is that they should generally be immutable objects. Immutability refers to the property of an object that prevents its state from being modified after it is created.\nExamples of Immutable Key Types:\n\nScalar Types: Examples of immutable scalar types suitable as dictionary keys include integers (int), floating-point numbers (float), and strings (str). These types are inherently immutable, which means once you create a key with a specific value, that key-value pair remains consistent.\nTuples as Composite Keys: Tuples can also serve as dictionary keys, but there’s an important condition: all the objects within the tuple must also be immutable. This ensures the stability of the key, as the tuple itself remains unchanged.\n\n\nThe Significance of Hashability\nThe technical term that ties these requirements together is “hashability.” Hashability refers to an object’s ability to be hashed, which involves converting the object into a fixed-size numerical value, known as a hash code. This hash code is used as an index to efficiently store and retrieve key-value pairs in a dictionary. The key feature of hashable objects is that they produce the same hash code consistently.\nThe Role of the hash() Function\nYou can determine whether an object is hashable and can be used as a dictionary key by utilizing the built-in hash() function. When you apply the hash() function to an object, it returns a hash code if the object is hashable. However, keep in mind that not all Python objects are hashable, particularly mutable objects like lists and dictionaries.\n\n# Using hash() to validate key types in dictionary\n\nhash(\"string\")           # hashable\nhash((1, 2, (2, 3)))     # hashable\n# hash((1, 2, [2, 3]))     # Not hashable due to mutable element - list of [2, 3]\n\n# When in need of list for key, convert it tp tuple, hashable\nd = {}\nd[tuple([1,2,3])] = 5\nprint(d)  # dictionary with a tuple as key\n\n{(1, 2, 3): 5}\n\n\n\n\n\nSets in Python: A Set is an essential data structure that represents an unordered collection of unique elements. Unlike lists or tuples, which allow duplicates, sets only store distinct values. This characteristic makes sets ideal for various tasks, such as removing duplicates from a list, checking for membership, and performing set operations like union, intersection, and difference. One of the most common real-world use cases for sets is in data deduplication, where they excel at efficiently eliminating duplicate records from datasets, ensuring data integrity and enhancing the performance of data processing tasks.\n\n# Create a set\nprint(set([2, 2, 2, 1, 3, 3]))\nprint\n\n# Union, Difference, Intersection and Symmetric Difference\na = {1, 2, 3, 4, 5}\nb = {3, 4, 5, 6, 7, 8}\nprint (\"Set a:\", a, \" Set b:\", b)\n\n# a.union(b) = a | b\nprint(\"a union b: \", a.union(b), a | b)\n# a.intersection(b) = a & b\nprint(\"a intersection b: \", a.intersection(b), a & b)\n# a.difference(b) = a - b\nprint(\"a difference b: \", a.difference(b), a - b)\n# a.symmetric_difference(b)\nprint(\"a.symmetric_difference(b): \", a.symmetric_difference(b), a ^ b)\n\n{1, 2, 3}\nSet a: {1, 2, 3, 4, 5}  Set b: {3, 4, 5, 6, 7, 8}\na union b:  {1, 2, 3, 4, 5, 6, 7, 8} {1, 2, 3, 4, 5, 6, 7, 8}\na intersection b:  {3, 4, 5} {3, 4, 5}\na difference b:  {1, 2} {1, 2}\na.symmetric_difference(b):  {1, 2, 6, 7, 8} {1, 2, 6, 7, 8}\n\n\n\n# Common set operations\na = {1, 2, 3, 4, 5}\n\n# a.add(x) - Add x to the set\na.add(\"Fox\")\nprint(a)\n# a.remove(x) - Remove x from the set\na.remove(\"Fox\")\nprint(a)\n# a.pop() - Remove an element arbitrarily, set must not be empty\nret = a.pop()\nprint(a, ret)\n\n\n\n# a.clear() - reset to empty\nprint(a.clear())  # None - empty\n\n{1, 2, 3, 4, 5, 'Fox'}\n{1, 2, 3, 4, 5}\n{2, 3, 4, 5} 1\nNone\n\n\nBuilt-in Sequence Functions\n\na_list = [7, 1, 2, 6, 0, 3, 2]\n\n# Very useful, use at every opportunities\n\n# enumerate() - no need to write code to track index\nfor index, value in enumerate(a_list):\n  print(index, \" : \", value)  \n\n# sorted() - a new srted list from the elements of any sequence\nprint(sorted(a_list))\nprint(sorted(\"horse race\"))  # string is a sequence\n\n# zip() - pairs up sequences element-wise to create a list\nseq1 = [\"foo\", \"bar\", \"baz\"]\nseq2 = [\"one\", \"two\", \"three\"]\nseq3 = [\"BROWN\", \"FOX\", \"FENCE\", \"JUMP\"]\nzipped = zip(seq1, seq2, seq3)\nprint(list(zipped))  # \"JUMP\" ignored for pariing!\n\n# zip() commonly works with enumerate() for iteration - zip and iterate\nfor index, (a, b) in enumerate(zip(seq1, seq2)):\n  print(f\"{index}: {a}, {b}\")\n\n# reversed()\nreversed(range(10)) # range_iterator object, it's a generator\nprint(list(reversed(range(10)))) # list() materializes the generator\n\n0  :  7\n1  :  1\n2  :  2\n3  :  6\n4  :  0\n5  :  3\n6  :  2\n[0, 1, 2, 2, 3, 6, 7]\n[' ', 'a', 'c', 'e', 'e', 'h', 'o', 'r', 'r', 's']\n[('foo', 'one', 'BROWN'), ('bar', 'two', 'FOX'), ('baz', 'three', 'FENCE')]\n0: foo, one\n1: bar, two\n2: baz, three\n[9, 8, 7, 6, 5, 4, 3, 2, 1, 0]\n\n\n\n\n\nComprehensions in Python offer concise, readable, and often more efficient ways to create lists, sets, and dictionaries. They reduce code verbosity, enhance readability, and promote a functional programming style, ultimately leading to cleaner and more maintainable code.\nList Comprehension:\nList comprehensions provide a concise way to create lists by applying an expression to each item in an iterable (e.g., a list, tuple, or range) and optionally filtering the items based on a condition.\n\n## [exp for value in collection if condition]\n\n# create a list of strings in uppercase only if the string has more than two characters.\nstrings = [\"a\", \"as\", \"bat\", \"car\", \"dove\", \"python\"]\nstrings_2 = [ str.upper() for str in strings if len(str) &gt; 2 ]\nprint(strings_2)\n\n# create a list of squares of even numbers from 0 to 9\neven_squares = [ x ** 2 for x in range(10) if x % 2 == 0 ]\nprint(even_squares)\n\n['BAT', 'CAR', 'DOVE', 'PYTHON']\n[0, 4, 16, 36, 64]\n\n\nSet Comprehension:\nSet comprehensions allow you to create sets in a similar manner to list comprehensions, but with the guarantee of uniqueness among elements.\n\n## set_comp = {expr for value in collection if condition}\n\n# Create a set using strings list above, containing only the lengths of strings.\nstrings = [\"a\", \"as\", \"bat\", \"car\", \"dove\", \"python\"]\nunique_lengths = { len(str) for str in strings } # uniqueness guaranted\nprint(unique_lengths)\n\n# map() - even more powerful\nstrings_map = set(map(len, strings))\nprint(strings_map)\n\n# Create a set of unique even squares from 0 to 9\neven_squares_set = {x ** 2 for x in range(10) if x % 2 == 0}\nprint(even_squares_set)\n\n{1, 2, 3, 4, 6}\n{1, 2, 3, 4, 6}\n{0, 64, 4, 36, 16}\n\n\nDictionary Comprehension:\nDictionary comprehensions enable the creation of dictionaries by defining key-value pairs based on expressions applied to items in an iterable.\n\n## {key_expression: value_expression for item in iterable if condition}\n\n# Create a dictionary, mapping even numbers to their squares from 0 to 9\neven_squares_dict = { x: x**2 for x in range(10) if x % 2 == 0 }\nprint(even_squares_dict)\n\n# Create a dictionary of lookup map of string for the location of each string in the list\nstrings = [\"a\", \"as\", \"bat\", \"car\", \"dove\", \"python\"]\nstring_lookup_dict = { str: index for index, str in enumerate(strings) }\nprint(strings)\nprint(string_lookup_dict)\n\n{0: 0, 2: 4, 4: 16, 6: 36, 8: 64}\n['a', 'as', 'bat', 'car', 'dove', 'python']\n{'a': 0, 'as': 1, 'bat': 2, 'car': 3, 'dove': 4, 'python': 5}\n\n\nNested list comprehensions\nThe order of\n\n# List of lists with some English and Spanish names - List nesting lists\nall_data = [\n  [\"John\", \"Emily\", \"Michael\", \"Mary\", \"Steven\"],\n  [\"Maria\", \"Juan\", \"Javier\", \"Natalia\", \"Pilar\"]\n]\nprint(all_data)\nprint(\"-\"*55)\n\n# Create a list of names contating two of more of 'a'\n# The non-Pythonic apporach using for loop..\nnames_of_interest = []\nfor names in all_data:\n  print(\"Processing:\", names)\n  enough_as = [ name for name in names if name.count(\"a\") &gt;=2 ]\n  print(enough_as)\n  names_of_interest.extend(enough_as)\nprint(\"Results: \", names_of_interest)\n\n# Re-writtine in one-liner using nested list comprehension\nnames_of_interest = [ name for names in all_data for name in names if name.count(\"a\") &gt;=2 ]\nprint(\"Result using Nested List Comprehension: \", names_of_interest)\n\n# Flatten a list of tuples of integers into a simple list of integers using nested list comprehension\nsome_tuples = [(1, 2, 3), (4, 5, 6), (7, 8, 9)]\nprint(some_tuples, type(some_tuples)) # list of tuples with integers\nflattened = [ int for tuple in some_tuples for int in tuple ]\nprint(\"Flattened: \", flattened, type(flattened))  # flattend list\n\n# Readability and valid forms\nflattened = []\nprint(\"Init. flattened list: \", flattened)\nprint(\"some_tuples: \", some_tuples)\nfor tup in some_tuples:\n  for x in tup:\n    flattened.append(x)\nprint(\"flattend from some_tuples: \", flattened)\n\n# list comprehenson inside list comprehension\n# Change list of tuples to a list of lists\nprint(\"Init. list of some_tuples: \", some_tuples)\nnew_list_of_lists = [[ x for x in tup ] for tup in some_tuples ]\nprint(\"List of lists from some_tuples: \", new_list_of_lists)\n\n[['John', 'Emily', 'Michael', 'Mary', 'Steven'], ['Maria', 'Juan', 'Javier', 'Natalia', 'Pilar']]\n-------------------------------------------------------\nProcessing: ['John', 'Emily', 'Michael', 'Mary', 'Steven']\n[]\nProcessing: ['Maria', 'Juan', 'Javier', 'Natalia', 'Pilar']\n['Maria', 'Natalia']\nResults:  ['Maria', 'Natalia']\nResult using Nested List Comprehension:  ['Maria', 'Natalia']\n[(1, 2, 3), (4, 5, 6), (7, 8, 9)] &lt;class 'list'&gt;\nFlattened:  [1, 2, 3, 4, 5, 6, 7, 8, 9] &lt;class 'list'&gt;\nInit. flattened list:  []\nsome_tuples:  [(1, 2, 3), (4, 5, 6), (7, 8, 9)]\nflattend from some_tuples:  [1, 2, 3, 4, 5, 6, 7, 8, 9]\nInit. list of some_tuples:  [(1, 2, 3), (4, 5, 6), (7, 8, 9)]\nList of lists from some_tuples:  [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n\n\n\n# 6 Practical use caes of nested list comprehension\n\n# 1. Matrix operations:\n# Add 1 to each element in a 2D matrix\nmatrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\nmatrix_add_1 = [[ element + 1 for element in row] for row in matrix]\nprint(\"matrix_add_1: \", matrix_add_1)\n\n# 2. Data transformation:\n# Filter rows with even some from a list of lists\ndata = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\nfiltered_data = [ row for row in data if sum(row) % 2 == 0 ]\nprint(\"filtered_data: \", filtered_data)\n\n# 3. Flattening lists of lists:\nnested_lists = [[1, 2], [3, 4], [5, 6]]\nflattened_list = [ item for sublist in nested_lists for item in sublist ]\nprint(\"flattened_list: \", flattened_list)\n\n# 4. Combining data:\n# Create all possible pairs (in tuple) from two lists - Different from element-wise pairing using zip()\nlist1 = [1, 2, 3]\nlist2 = ['a', 'b', 'c']\ncombinations = [ (x, y) for x in list1 for y in list2 ]\nprint(\"combinations: \", combinations)\n\n# 5. Conditional filtering:\n# Filter rows containing 'John' from a list of lists\ndata = [['Alice', 25], ['John', 30], ['Bob', 35]]\nfiltered_data = [ list for list in data if 'John' in list ]\nprint(\"filtered_data: \", filtered_data)\n\n# 6. Transposing data:\n# Transpose a given matrix (switching rows and columns)\nmatrix = [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]]\ntransposed_matrix = [[ (row[i], print(\"row[i]: \", row[i]), print(\"processing row: \", row)) for row in matrix ] for i in range(len(matrix[0]))]\n#print(\"transposed_matrix: \", transposed_matrix)\n#print(len(matrix[0]))\n#print(range(len(matrix[0])))\n\nmatrix_add_1:  [[2, 3, 4], [5, 6, 7], [8, 9, 10]]\nfiltered_data:  [[1, 2, 3], [7, 8, 9]]\nflattened_list:  [1, 2, 3, 4, 5, 6]\ncombinations:  [(1, 'a'), (1, 'b'), (1, 'c'), (2, 'a'), (2, 'b'), (2, 'c'), (3, 'a'), (3, 'b'), (3, 'c')]\nfiltered_data:  [['John', 30]]\nrow[i]:  1\nprocessing row:  [1, 2, 3, 4]\nrow[i]:  5\nprocessing row:  [5, 6, 7, 8]\nrow[i]:  9\nprocessing row:  [9, 10, 11, 12]\nrow[i]:  2\nprocessing row:  [1, 2, 3, 4]\nrow[i]:  6\nprocessing row:  [5, 6, 7, 8]\nrow[i]:  10\nprocessing row:  [9, 10, 11, 12]\nrow[i]:  3\nprocessing row:  [1, 2, 3, 4]\nrow[i]:  7\nprocessing row:  [5, 6, 7, 8]\nrow[i]:  11\nprocessing row:  [9, 10, 11, 12]\nrow[i]:  4\nprocessing row:  [1, 2, 3, 4]\nrow[i]:  8\nprocessing row:  [5, 6, 7, 8]\nrow[i]:  12\nprocessing row:  [9, 10, 11, 12]\n\n\n\n\n\nFunctions in Python are a cornerstone of the language, offering powerful tools for structuring and modularizing code. Python functions come with several unique features that distinguish them from functions in other programming languages.\n\nVersatile and Expressive: Python functions support both positional and keyword arguments, enabling flexible and expressive function calls.\nMultiple Return Values: Python functions can return multiple values, simplifying the packaging and unpacking of results.\nDefault Argument Values: Python functions allow for default argument values, making function usage more straightforward by providing sensible defaults when arguments are omitted.\nLambda Functions: Python features lambda functions for concise and anonymous function definitions, particularly useful for simple operations.\nFirst-Class Functions: Python treats functions as first-class citizens, allowing them to be assigned to variables, passed as arguments, and returned from other functions. This flexibility enhances code modularity, maintainability, and readability.\nModular and Reusable: Python’s function-centric approach encourages the creation of clean, reusable, and modular code, making it a crucial topic for all Python programmers to master.\n\n\n# simple declaration and calling\ndef my_function(x,y):\n  return x + y\n\nret = my_function(1, 2)\nprint(ret)\n\n# Return None when no retorn statement is encountered\ndef funciton_without_return(x):\n  print(x)\nresult = funciton_without_return(\"hello!\")\nprint(result)\n\n# positional and keyword arguments\ndef my_function2(x, y, z=1.5):  # z as keyword argument with default value\n  if z &gt; 1:\n    return z * (x + y)\n  else:\n    return z / (x + y)\n\n# Naespace, scope and local functions\n\n\nprint(my_function2(5, 6, z=0.7))  # no need to put arg names, keword arg optional\nprint(my_function2(3.14, 7, 3.5))  # no need to specify name for kewoord arguments\nprint(my_function2(10, 20))   # keyword arg optional\n\n\na = []\ndef func():\n  for i in range(5):\n    a.append(i)\n\nfunc()\n\n3\nhello!\nNone\n0.06363636363636363\n35.49\n45.0\n\n\n\n# Assigining variable outside the function's scope\n\na = None\ndef bind_a_variable():\n  global a\n  a = []\n  \nbind_a_variable()\nprint(a)\n\n# multiple returns\ndef f():\n  a = 5\n  b = 6\n  c = 7\n  return a, b, c\n\na, b, c = f()\nprint(a, b)\n\n[]\n5 6\n\n\nFunctions Are Objects\nIn Python, functions are first-class objects, which means they are treated like any other object, such as integers, strings, or lists. This concept is a fundamental part of the Python language and has several implications and practical uses.\n\nFunctions can be assigned to variables:\n\n\n# Functions can be assigned to variables:\n\ndef greet(name):\n    return f\"Hello, {name}!\"\n\ngreeting = greet  # function assigned to variable \nprint(greeting(\"Alice\"))  # calling the function using the assigned variable\n\nprint(id(greet), id(greeting)) # both variable and function references the same object\n\nHello, Alice!\n1808218897312 1808218897312\n\n\n\nFunctions can be passed as arguments: This is particularly useful for functions that require a callback or custom behavior.\n\n\n# Functions can be passed as arguments\n\ndef apply(func, value):\n  return func(value)\n\ndef double(x):\n  return x * 2\n\nresult = apply(double, 5)\nprint(result)\n\n10\n\n\n\nFunctions can be returned from other functions: This enables dynamic function generation.\n\n\n# Functinos can be returned from other functions\ndef create_multiplier(factor):\n  \"\"\"\n  Returns a FUNCTION that produce the result of given factor * x\n  \"\"\"\n  def multiplier(x):\n    return x * factor\n  return multiplier    # return the inner function\n\ndouble = create_multiplier(2)\nprint(double(200))  # Result is a function returned by 'created_multiplier'\nprint(double(400))\n\n400\n800\n\n\nFunctions can be stored in data structures\nFunctions can be stored in data structures like lists, dictionaries, or sets, making it possible to manage and manipulate functions dynamically.\n\n# Functinos can be stored in data structures\n\ndef square(x):\n  return x**2\n\ndef cube(x):\n  return x**3\n\nmath_functions = [square, cube]\nresult = math_functions[1](3)  # access and call the 'cube' function, give 3 to the parameter\nprint(result)\n\n\n# Using a list of functinos for cleaning strings from survey data\nanswer_states = [\"   alabama \", \"georgia!\", \"Georgia\",  \\\n          \"georgia\", \"flOrIda\", \"south   carolina##\",   \\\n          \"West virginia?\"]\nprint(answer_states)\n          \ndef remove_punctuation(value):\n  return re.sub(\"[!#?]\", \"\", value)\n\nclean_ops = [str.strip, remove_punctuation, str.title] # 3 functinos in list for cleaning operation\n\nimport re\n\ndef clean_strings(strings, ops):\n    result = []\n    for value in strings:\n        for func in ops:\n            value = func(value)\n        result.append(value)\n    return result\n  \nprint(\"strings_cleaned: \", clean_strings(answer_states, clean_ops))\n\nprint(\"-\"*55)\n\n\n# Using map() to apply a function as argument to a sequence\nfor x in map(remove_punctuation, answer_states):\n  print(x)\n\n27\n['   alabama ', 'georgia!', 'Georgia', 'georgia', 'flOrIda', 'south   carolina##', 'West virginia?']\nstrings_cleaned:  ['Alabama', 'Georgia', 'Georgia', 'Georgia', 'Florida', 'South   Carolina', 'West Virginia']\n-------------------------------------------------------\n   alabama \ngeorgia\nGeorgia\ngeorgia\nflOrIda\nsouth   carolina\nWest virginia\n\n\nAnonymous (Lambda) Functions:\nAnonymous functions, often referred to as “lambda functions,” are a concise way to create small, inline functions without giving them a formal name. In Python, lambda functions are defined using the lambda keyword, followed by parameters and an expression. While they are limited in scope compared to regular functions, they offer several benefits:\nConciseness: Lambda functions are compact and allow you to define simple operations in a single line of code, making them particularly useful for short, one-off functions.\nReadability: When used appropriately, lambda functions can improve code readability by encapsulating a specific operation right where it’s needed, reducing the need for named functions or temporary variables.\nFunctional Programming: Lambda functions are a key component of functional programming in Python. They can be used with higher-order functions like map(), filter(), and reduce() to perform operations on collections of data.\n\n# sort a list of tuples by the second element:\ndata = [(1, 5), (3, 2), (2, 8)]\nsorted_data = sorted(data, key=lambda x: x[1])  # extracts the second element (index 1) of each tuple in the data list\nprint(sorted_data)\n\n[(3, 2), (1, 5), (2, 8)]\n\n\n\n# filter even numbers from a list\nnumbers = [1, 2, 3, 4, 5, 6]\neven_numbers = list(filter(lambda x: x % 2 == 0, numbers))  # filtering function, iterables\nprint(even_numbers)\n\n[2, 4, 6]\n\n\n\n# Mapping a Function to a List\n\nvalues = [1, 2, 3, 4, 5]\nsquared_values = list(map(lambda x: x**2, values))\nprint(squared_values)\n\n[1, 4, 9, 16, 25]\n\n\n\ndef short_function(x):\n  return x * 2\nprint(short_function(100))\n\nequiv_amon = lambda x: x * 2  # assign a function to variable\nprint(type(equiv_amon))\nprint(equiv_amon(100))  # produces the same result\nprint(\"-\"*55)\n\n# use a lambda function for the second argument\ndef apply_to_list(some_list, f):\n  \"\"\"\n  Apply the given function to the given list\n  \"\"\"\n  return [f(x) for x in some_list]\nints = [4, 0, 1, 5, 6]\n\nret = apply_to_list(ints, lambda x: x*2)\nprint(ret)\n\n# sort the list of strings based on the number of unique charaters for each string.\n\n200\n&lt;class 'function'&gt;\n200\n-------------------------------------------------------\n[8, 0, 2, 10, 12]"
  }
]