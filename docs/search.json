[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "Albert Joon Park",
    "section": "",
    "text": "Albert Joonyoung Park is an aspiring and dedicated independent data analyst with a diverse background spanning entrepreneurship, eCommerce, manufacturing operations, and database application development. With a strong focus on delivering valuable insights, he collaborates closely with clients to extract meaningful information from diverse datasets across various industries. Additionally, Albert has recently ventured into mortgage brokering, aiming to leverage his data skills to assist individuals in identifying optimal financial solutions tailored to their specific needs. Beyond his professional pursuits, Albert finds joy in spending quality time with his spouse, continuously expanding his expertise in data science, actively participating in the church choir, and honing his piano-playing skills."
  },
  {
    "objectID": "blog.html",
    "href": "blog.html",
    "title": "Blog Posts",
    "section": "",
    "text": "[4] Arrays and Vectorized Computation\n\n\nA series of posts, exploring data analysis using the book - Python for Data Analysis, 3E by Wes McKinney\n\n\n\n\n\n\nSeptember 21, 2023\n\n\n18 min\n\n\n\n\n\n\n  \n\n\n\n\n[3] Built-In Data Structures, Functions, and Files\n\n\nA series of posts, exploring data analysis using the book - Python for Data Analysis, 3E by Wes McKinney\n\n\n\n\n\n\nSeptember 11, 2023\n\n\n27 min\n\n\n\n\n\n\n  \n\n\n\n\nExploring Polar Coordinate Plot in Python Using Matplotlib\n\n\nMetplotlib - Polar coordinate plot.\n\n\n\n\n\n\nAugust 22, 2023\n\n\n3 min\n\n\n\n\n\n\n  \n\n\n\n\nPython Setup in R with Reticulate\n\n\nMetplotlib - Polar coordinate plot.\n\n\n\n\n\n\nAugust 22, 2023\n\n\n2 min\n\n\n\n\n\n\n  \n\n\n\n\nA Demo Blog Post Using Quarto\n\n\nWhat Quarto can do for your blog posts.\n\n\n\n\n\n\nJune 1, 2022\n\n\n4 min\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Greetings from Albert Joonyoung Park",
    "section": "",
    "text": "Welcome to my personal website, where I share my selected examples and blogs on data analysis. The primary aim is to share my enriching journey in data analysis and its multitude of benefits. When data is harnessed and interpreted effectively, it has the remarkable ability to reveal concealed paths that guide decision-making, be it in our personal lives or the business world. To fully unlock its potential, I invite you to don your\"Curiosity Hat\" and explore the stories that lie within the data. Brace yourself, for the results have the potential to transcend mere significance—they possess the inherent power to shape and transform.\n  \n  \n  \n    Albert Joonyoung Park"
  },
  {
    "objectID": "posts/my-first-blog.html",
    "href": "posts/my-first-blog.html",
    "title": "A Demo Blog Post Using Quarto",
    "section": "",
    "text": "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nam suscipit est nec dui eleifend, at dictum elit ullamcorper. Aliquam feugiat dictum bibendum. Praesent fermentum laoreet quam, cursus volutpat odio dapibus in. Fusce luctus porttitor vehicula. Donec ac tortor nisi. Donec at lectus tortor. Morbi tempor, nibh non euismod viverra, metus arcu aliquet elit, sed fringilla urna leo vel purus.\n\n\nLorem ipsum dolor sit amet, consectetur adipiscing elit. Nam suscipit est nec dui eleifend, at dictum elit ullamcorper. Aliquam feugiat dictum bibendum. Praesent fermentum laoreet quam, cursus volutpat odio dapibus in. Fusce luctus porttitor vehicula. Donec ac tortor nisi. Donec at lectus tortor. Morbi tempor, nibh non euismod viverra, metus arcu aliquet elit, sed fringilla urna leo vel purus.\n\n\nThis is inline code plus a small code chunk.\n\nlibrary(tidyverse)\n\nggplot(mpg) +\n    geom_jitter(aes(cty, hwy), size = 4, alpha = 0.5)\n\n\n\n\n\n\n\n\nTransforming OLS estimatesMaximizing likelihood\n\n\n\n\nCode\npreds_lm %&gt;%\n    ggplot(aes(body_mass_g, bill_length_mm, col = correct)) +\n    geom_jitter(size = 4, alpha = 0.6) +\n    facet_wrap(vars(species)) +\n    scale_color_manual(values = c(\"grey60\", thematic::okabe_ito(3)[3])) +\n    scale_x_continuous(breaks = seq(3000, 6000, 1000)) +\n    theme_minimal(base_size = 12) +\n    theme(\n        legend.position = \"top\",\n        panel.background = element_rect(color = \"black\"),\n        panel.grid.minor = element_blank()\n    ) +\n    labs(\n        x = \"Body mass (in g)\",\n        y = \"Bill length (in mm)\"\n    )\n\n\n\n\n\n\n\n\n\nCode\nglm.mod &lt;- glm(sex ~ body_mass_g + bill_length_mm + species, family = binomial, data = dat)\n\npreds &lt;- dat %&gt;% \n  mutate(\n    prob.fit = glm.mod$fitted.values,\n    prediction = if_else(prob.fit &gt; 0.5, 'male', 'female'),\n    correct = if_else(sex == prediction, 'correct', 'incorrect')\n  )\n\n\npreds %&gt;% \n  ggplot(aes(body_mass_g, bill_length_mm, col = correct)) +\n  geom_jitter(size = 4, alpha = 0.6) +\n  facet_wrap(vars(species)) +\n  scale_x_continuous(breaks = seq(3000, 6000, 1000)) +\n  scale_color_manual(values = c('grey60', thematic::okabe_ito(3)[3])) +\n  theme_minimal(base_size = 10) +\n  theme(\n    legend.position = 'top', \n    panel.background = element_rect(color = 'black'),\n    panel.grid.minor = element_blank()\n  ) +\n  labs(\n    x = 'Body mass (in g)',\n    y = 'Bill length (in mm)'\n  )\n\n\n\n\n\n\n\n\n\n\n\n\\int_0^1 f(x) \\ dx\n\n\n\n\n\n\n\n\n\ngeom_density(\n  mapping = NULL,\n  data = NULL,\n  stat = \"density\",\n  position = \"identity\",\n  ...,\n  na.rm = FALSE,\n  orientation = NA,\n  show.legend = NA,\n  inherit.aes = TRUE,\n  outline.type = \"upper\"\n)\n\n\nstat_density(\n  mapping = NULL,\n  data = NULL,\n  geom = \"area\",\n  position = \"stack\",\n  ...,\n  bw = \"nrd0\",\n  adjust = 1,\n  kernel = \"gaussian\",\n  n = 512,\n  trim = FALSE,\n  na.rm = FALSE,\n  orientation = NA,\n  show.legend = NA,\n  inherit.aes = TRUE\n)\n\n\n\n\n\n\n\nggplot(data = gapminder::gapminder, mapping = aes(x = lifeExp, fill = continent)) +\n    stat_density(position = \"identity\", alpha = 0.5)\n\n\n\n\nBla bla bla. This is a caption in the margin. Super cool isn’t it?"
  },
  {
    "objectID": "posts/my-first-blog.html#merriweather",
    "href": "posts/my-first-blog.html#merriweather",
    "title": "A Demo Blog Post Using Quarto",
    "section": "",
    "text": "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nam suscipit est nec dui eleifend, at dictum elit ullamcorper. Aliquam feugiat dictum bibendum. Praesent fermentum laoreet quam, cursus volutpat odio dapibus in. Fusce luctus porttitor vehicula. Donec ac tortor nisi. Donec at lectus tortor. Morbi tempor, nibh non euismod viverra, metus arcu aliquet elit, sed fringilla urna leo vel purus.\n\n\nThis is inline code plus a small code chunk.\n\nlibrary(tidyverse)\n\nggplot(mpg) +\n    geom_jitter(aes(cty, hwy), size = 4, alpha = 0.5)\n\n\n\n\n\n\n\n\nTransforming OLS estimatesMaximizing likelihood\n\n\n\n\nCode\npreds_lm %&gt;%\n    ggplot(aes(body_mass_g, bill_length_mm, col = correct)) +\n    geom_jitter(size = 4, alpha = 0.6) +\n    facet_wrap(vars(species)) +\n    scale_color_manual(values = c(\"grey60\", thematic::okabe_ito(3)[3])) +\n    scale_x_continuous(breaks = seq(3000, 6000, 1000)) +\n    theme_minimal(base_size = 12) +\n    theme(\n        legend.position = \"top\",\n        panel.background = element_rect(color = \"black\"),\n        panel.grid.minor = element_blank()\n    ) +\n    labs(\n        x = \"Body mass (in g)\",\n        y = \"Bill length (in mm)\"\n    )\n\n\n\n\n\n\n\n\n\nCode\nglm.mod &lt;- glm(sex ~ body_mass_g + bill_length_mm + species, family = binomial, data = dat)\n\npreds &lt;- dat %&gt;% \n  mutate(\n    prob.fit = glm.mod$fitted.values,\n    prediction = if_else(prob.fit &gt; 0.5, 'male', 'female'),\n    correct = if_else(sex == prediction, 'correct', 'incorrect')\n  )\n\n\npreds %&gt;% \n  ggplot(aes(body_mass_g, bill_length_mm, col = correct)) +\n  geom_jitter(size = 4, alpha = 0.6) +\n  facet_wrap(vars(species)) +\n  scale_x_continuous(breaks = seq(3000, 6000, 1000)) +\n  scale_color_manual(values = c('grey60', thematic::okabe_ito(3)[3])) +\n  theme_minimal(base_size = 10) +\n  theme(\n    legend.position = 'top', \n    panel.background = element_rect(color = 'black'),\n    panel.grid.minor = element_blank()\n  ) +\n  labs(\n    x = 'Body mass (in g)',\n    y = 'Bill length (in mm)'\n  )\n\n\n\n\n\n\n\n\n\n\n\n\\int_0^1 f(x) \\ dx"
  },
  {
    "objectID": "posts/my-first-blog.html#columns",
    "href": "posts/my-first-blog.html#columns",
    "title": "A Demo Blog Post Using Quarto",
    "section": "",
    "text": "geom_density(\n  mapping = NULL,\n  data = NULL,\n  stat = \"density\",\n  position = \"identity\",\n  ...,\n  na.rm = FALSE,\n  orientation = NA,\n  show.legend = NA,\n  inherit.aes = TRUE,\n  outline.type = \"upper\"\n)\n\n\nstat_density(\n  mapping = NULL,\n  data = NULL,\n  geom = \"area\",\n  position = \"stack\",\n  ...,\n  bw = \"nrd0\",\n  adjust = 1,\n  kernel = \"gaussian\",\n  n = 512,\n  trim = FALSE,\n  na.rm = FALSE,\n  orientation = NA,\n  show.legend = NA,\n  inherit.aes = TRUE\n)"
  },
  {
    "objectID": "posts/my-first-blog.html#margin-captions",
    "href": "posts/my-first-blog.html#margin-captions",
    "title": "A Demo Blog Post Using Quarto",
    "section": "",
    "text": "ggplot(data = gapminder::gapminder, mapping = aes(x = lifeExp, fill = continent)) +\n    stat_density(position = \"identity\", alpha = 0.5)\n\n\n\n\nBla bla bla. This is a caption in the margin. Super cool isn’t it?"
  },
  {
    "objectID": "projects/cyclistic-bike-share-analysis.html#characters-and-teams",
    "href": "projects/cyclistic-bike-share-analysis.html#characters-and-teams",
    "title": "The Cyclistic Bike-share Analysis Case Study",
    "section": "Characters and teams",
    "text": "Characters and teams\n\nCyclistic: A bike-share program that features more than 5,800 bicycles and 600 docking stations. Cyclistic sets itself apart by also offering reclining bikes, hand tricycles, and cargo bikes, making bike-share more inclusive to people with disabilities and riders who can’t use a standard two-wheeled bike. The majority of riders opt for traditional bikes; about 8% of riders use the assistive options. Cyclistic users are more likely to ride for leisure, but about 30% use them to commute to work each day.\nLily Moreno: The director of marketing and your manager. Moreno is responsible for the development of campaigns and initiatives to promote the bike-share program. These may include email, social media, and other channels.\nCyclistic marketing analytics team: A team of data analysts who are responsible for collecting, analyzing, and reporting data that helps guide Cyclistic marketing strategy. You joined this team six months ago and have been busy learning about Cyclistic’s mission and business goals — as well as how you, as a junior data analyst, can help Cyclistic achieve them.\nCyclistic executive team: The notoriously detail-oriented executive team will decide whether to approve the recommended marketing program."
  },
  {
    "objectID": "projects/cyclistic-bike-share-analysis.html#about-the-company",
    "href": "projects/cyclistic-bike-share-analysis.html#about-the-company",
    "title": "The Cyclistic Bike-share Analysis Case Study",
    "section": "About the company",
    "text": "About the company\nIn 2016, Cyclistic launched a successful bike-share offering. Since then, the program has grown to a fleet of 5,824 bicycles that are geotracked and locked into a network of 692 stations across Chicago. The bikes can be unlocked from one station and returned to any other station in the system anytime.\nUntil now, Cyclistic’s marketing strategy relied on building general awareness and appealing to broad consumer segments. One approach that helped make these things possible was the flexibility of its pricing plans: single-ride passes, full-day passes, and annual memberships. Customers who purchase single-ride or full-day passes are referred to as casual riders. Customers who purchase annual memberships are Cyclistic members.\nCyclistic’s finance analysts have concluded that annual members are much more profitable than casual riders. Although the pricing flexibility helps Cyclistic attract more customers, Moreno believes that maximizing the number of annual members will be key to future growth. Rather than creating a marketing campaign that targets all-new customers, Moreno believes there is a very good chance to convert casual riders into members. She notes that casual riders are already aware of the Cyclistic program and have chosen Cyclistic for their mobility needs.\nMoreno has set a clear goal: Design marketing strategies aimed at converting casual riders into annual members. In order to do that, however, the marketing analyst team needs to better understand how annual members and casual riders differ, why casual riders would buy a membership, and how digital media could affect their marketing tactics. Moreno and her team are interested in analyzing the Cyclistic historical bike trip data to identify trends."
  },
  {
    "objectID": "projects/cyclistic-bike-share-analysis.html#project-deliverables",
    "href": "projects/cyclistic-bike-share-analysis.html#project-deliverables",
    "title": "The Cyclistic Bike-share Analysis Case Study",
    "section": "Project deliverables",
    "text": "Project deliverables\nProduce a report with the following deliverables:\n\n\nA clear statement of the business task.\nA description of all data sources used.\nDocumentation of any cleaning or manipulation of data.\nA summary of your analysis.\nSupporting visualizations and key findings.\nYour top three recommendations based on your analysis."
  },
  {
    "objectID": "projects/cyclistic-bike-share-analysis.html#key-findings",
    "href": "projects/cyclistic-bike-share-analysis.html#key-findings",
    "title": "The Cyclistic Bike-share Analysis Case Study",
    "section": "Key findings",
    "text": "Key findings\n\nThe bikes were used by members more frequently than casual users, with a 24.12% higher usage rate in the last 12 months.\nHowever, casual riders had longer ride duration compared to members, with an average difference of 4-7 minutes.\nFrom a quarterly perspective, the third and second quarters of the year were the most popular seasons for casual riders.\nCasual riders exhibited a preference for riding bikes on Fridays, Saturdays, and Sundays, and they had longer trip duration during these days.\nAmong the rideable types, classic bikes were the most popular choice among casual riders.\nCasual riders were the only user group that utilized docked bikes.\n“Streeter Dr & Grand Ave” and “DuSable Lake Shore Dr & Monroe St” were the most common starting stations for casual users."
  },
  {
    "objectID": "projects/cyclistic-bike-share-analysis.html#three-recommendations",
    "href": "projects/cyclistic-bike-share-analysis.html#three-recommendations",
    "title": "The Cyclistic Bike-share Analysis Case Study",
    "section": "Three recommendations",
    "text": "Three recommendations\n\nCreate a marketing campaign that educates casual riders on their long-ride trips and invites them to a membership that can cater to their riding needs year-round. The campaign can be advertised both online and offline, with a focus on regions where the most popular stations for casual riders are located. This recommendation is supported by the data analysis, which highlights the long ride durations of casual riders and emphasizes the value of a membership that can provide continuous benefits.\nConsider creating a specialty membership specifically designed for docked-bike users. This targeted approach can be an effective way to engage casual riders who prefer docked bikes. However, instead of offering a separate membership, it may be more beneficial to incorporate docked-bike usage as an additional feature within the existing full-scale membership. This way, casual riders can experience the benefits of membership without creating a distinct membership category.\nDevelop a special introductory membership for the months between April and September or for the days of the week (Friday to Sunday). This limited-time membership can serve as a trial period, offering casual riders the opportunity to experience the benefits of a membership during the most popular seasons or days. Following the introductory period, you can then transition these riders to a regular yearly membership."
  },
  {
    "objectID": "projects.html",
    "href": "projects.html",
    "title": "Projects",
    "section": "",
    "text": "The Cyclistic Bike-share Analysis Case Study\n\n\n\n\n\n\n\n\n\nFebruary 5, 2023\n\n\nAlbert Joonyoung Park\n\n\n25 min\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/document.html",
    "href": "posts/document.html",
    "title": "Exploring Polar Coordinate Plots in Python Using Matplotlib",
    "section": "",
    "text": "A polar plot is a type of graph that presents data in a circular format, offering a fresh perspective beyond the conventional Cartesian coordinate system. In a polar plot, data points are represented using radial distance from a central point and angular positions, creating a distinct visual representation that emphasizes patterns and relationships in a unique way. This type of plot is particularly suitable for data that exhibits directional or cyclic patterns, such as time series data, circular data (e.g., wind direction), or any data with inherent periodicity. Polar plots excel at revealing cyclical trends and variations that might go unnoticed on traditional scatter plots. They allow us to easily observe changes in data values as they evolve over angles, providing insights into periodic behaviors, phase shifts, and synchronization. Whether in the realms of engineering, meteorology, or scientific research, polar plots offer a valuable tool for gaining deeper insights from complex datasets that might otherwise remain hidden in a sea of numbers.\nFor a demonstration of a line plot on a polar axis, see Figure 1.\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Define an array of values for the radial distance\nr = np.arange(0, 2, 0.01)\n\n# Convert the radial distance into angles\ntheta = 2 * np.pi * r\n\n# Create a figure and axis with polar projection\nfig, ax = plt.subplots(subplot_kw={'projection': 'polar'})\n\n# Plot the data points on the polar axis\nax.plot(theta, r)\n\n# Customize the radial ticks to enhance readability\nax.set_rticks([0.5, 1, 1.5, 2])\n\n# Add grid lines for a clear reference\nax.grid(True)\n\n# Display the enchanting plot\nplt.show()\n\n\n\n\nFigure 1: A line plot on a polar axis"
  },
  {
    "objectID": "projects/bellabeat-analysis.html#characters-and-products",
    "href": "projects/bellabeat-analysis.html#characters-and-products",
    "title": "Bellabeat Analysis Case Study",
    "section": "Characters and products",
    "text": "Characters and products\n\nCharacters\n\nUrška Sršen: Bellabeat’s cofounder and Chief Creative Officer\nSando Mur: Mathematician and Bellabeat’s cofounder; key member of the Bellabeat executive team\nBellabeat marketing analytics team: A team of data analysts responsible for collecting, analyzing, and reporting data that helps guide Bellabeat’s marketing strategy. You joined this team six months ago and have been busy learning about Bellabeat’’s mission and business goals — as well as how you, as a junior data analyst, can help Bellabeat achieve them.\n\nProducts\n\nBellabeat app: The Bellabeat app provides users with health data related to their activity, sleep, stress, menstrual cycle, and mindfulness habits. This data can help users better understand their current habits and make healthy decisions. The Bellabeat app connects to their line of smart wellness products.\nLeaf: Bellabeat’s classic wellness tracker can be worn as a bracelet, necklace, or clip. The Leaf tracker connects to the Bellabeat app to track activity, sleep, and stress.\nTime: This wellness watch combines the timeless look of a classic timepiece with smart technology to track user activity, sleep, and stress. The Time watch connects to the Bellabeat app to provide you with insights into your daily wellness.\nSpring: This is a water bottle that tracks daily water intake using smart technology to ensure that you are appropriately hydrated throughout the day. The Spring bottle connects to the Bellabeat app to track your hydration levels.\nBellabeat membership: Bellabeat also offers a subscription-based membership program for users. Membership gives users 24/7 access to fully personalized guidance on nutrition, activity, sleep, health and beauty, and mindfulness based on their lifestyle and goals."
  },
  {
    "objectID": "projects/bellabeat-analysis.html#about-the-company",
    "href": "projects/bellabeat-analysis.html#about-the-company",
    "title": "Bellabeat Analysis Case Study",
    "section": "About the company",
    "text": "About the company\nUrška Sršen and Sando Mur founded Bellabeat, a high-tech company that manufactures health-focused smart products. Sršen used her background as an artist to develop beautifully designed technology that informs and inspires women around the world. Collecting data on activity, sleep, stress, and reproductive health has allowed Bellabeat to empower women with knowledge about their own health and habits. Since it was founded in 2013, Bellabeat has grown rapidly and quickly positioned itself as a tech-driven wellness company for women.\nBy 2016, Bellabeat had opened offices around the world and launched multiple products. Bellabeat products became available through a growing number of online retailers in addition to their own e-commerce channel on their website. The company has invested in traditional advertising media, such as radio, out-of-home billboards, print, and television, but focuses on digital marketing extensively. Bellabeat invests year-round in Google Search, maintaining active Facebook and Instagram pages, and consistently engages consumers on Twitter. Additionally, Bellabeat runs video ads on Youtube and display ads on the Google Display Network to support campaigns around key marketing dates.\nSršen knows that an analysis of Bellabeat’s available consumer data would reveal more opportunities for growth. She has asked the marketing analytics team to focus on a Bellabeat product and analyze smart device usage data in order to gain insight into how people are already using their smart devices. Then, using this information, she would like high-level recommendations for how these trends can inform Bellabeat marketing strategy."
  },
  {
    "objectID": "projects/bellabeat-analysis.html#project-deliverables",
    "href": "projects/bellabeat-analysis.html#project-deliverables",
    "title": "Bellabeat Analysis Case Study",
    "section": "Project deliverables",
    "text": "Project deliverables\nProduce a report with the following deliverables:\n\n\nA clear statement of the business task.\nA description of all data sources used.\nDocumentation of any cleaning or manipulation of data.\nA summary of your analysis.\nSupporting visualizations and key findings.\nYour top three recommendations based on your analysis."
  },
  {
    "objectID": "projects/bellabeat-analysis.html#key-findings",
    "href": "projects/bellabeat-analysis.html#key-findings",
    "title": "Bellabeat Analysis Case Study",
    "section": "Key findings",
    "text": "Key findings\n\nThe bikes were used by members more frequently than casual users, with a 24.12% higher usage rate in the last 12 months.\nHowever, casual riders had longer ride duration compared to members, with an average difference of 4-7 minutes.\nFrom a quarterly perspective, the third and second quarters of the year were the most popular seasons for casual riders.\nCasual riders exhibited a preference for riding bikes on Fridays, Saturdays, and Sundays, and they had longer trip duration during these days.\nAmong the rideable types, classic bikes were the most popular choice among casual riders.\nCasual riders were the only user group that utilized docked bikes.\n“Streeter Dr & Grand Ave” and “DuSable Lake Shore Dr & Monroe St” were the most common starting stations for casual users."
  },
  {
    "objectID": "projects/bellabeat-analysis.html#three-recommendations",
    "href": "projects/bellabeat-analysis.html#three-recommendations",
    "title": "Bellabeat Analysis Case Study",
    "section": "Three recommendations",
    "text": "Three recommendations\n\nCreate a marketing campaign that educates casual riders on their long-ride trips and invites them to a membership that can cater to their riding needs year-round. The campaign can be advertised both online and offline, with a focus on regions where the most popular stations for casual riders are located. This recommendation is supported by the data analysis, which highlights the long ride durations of casual riders and emphasizes the value of a membership that can provide continuous benefits.\nConsider creating a specialty membership specifically designed for docked-bike users. This targeted approach can be an effective way to engage casual riders who prefer docked bikes. However, instead of offering a separate membership, it may be more beneficial to incorporate docked-bike usage as an additional feature within the existing full-scale membership. This way, casual riders can experience the benefits of membership without creating a distinct membership category.\nDevelop a special introductory membership for the months between April and September or for the days of the week (Friday to Sunday). This limited-time membership can serve as a trial period, offering casual riders the opportunity to experience the benefits of a membership during the most popular seasons or days. Following the introductory period, you can then transition these riders to a regular yearly membership."
  },
  {
    "objectID": "posts/document.html#polar-plot",
    "href": "posts/document.html#polar-plot",
    "title": "Exploring Polar Coordinate Plots in Python Using Matplotlib",
    "section": "",
    "text": "A polar plot is a type of graph that presents data in a circular format, offering a fresh perspective beyond the conventional Cartesian coordinate system. In a polar plot, data points are represented using radial distance from a central point and angular positions, creating a distinct visual representation that emphasizes patterns and relationships in a unique way. This type of plot is particularly suitable for data that exhibits directional or cyclic patterns, such as time series data, circular data (e.g., wind direction), or any data with inherent periodicity. Polar plots excel at revealing cyclical trends and variations that might go unnoticed on traditional scatter plots. They allow us to easily observe changes in data values as they evolve over angles, providing insights into periodic behaviors, phase shifts, and synchronization. Whether in the realms of engineering, meteorology, or scientific research, polar plots offer a valuable tool for gaining deeper insights from complex datasets that might otherwise remain hidden in a sea of numbers.\nFor a demonstration of a line plot on a polar axis, see Figure 1.\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Define an array of values for the radial distance\nr = np.arange(0, 2, 0.01)\n\n# Convert the radial distance into angles\ntheta = 2 * np.pi * r\n\n# Create a figure and axis with polar projection\nfig, ax = plt.subplots(subplot_kw={'projection': 'polar'})\n\n# Plot the data points on the polar axis\nax.plot(theta, r)\n\n# Customize the radial ticks to enhance readability\nax.set_rticks([0.5, 1, 1.5, 2])\n\n# Add grid lines for a clear reference\nax.grid(True)\n\n# Display the enchanting plot\nplt.show()\n\n\n\n\nFigure 1: A line plot on a polar axis"
  },
  {
    "objectID": "posts/document.html#decoding-the-code",
    "href": "posts/document.html#decoding-the-code",
    "title": "Exploring Polar Coordinate Plots in Python Using Matplotlib",
    "section": "Decoding the Code",
    "text": "Decoding the Code\nImporting Libraries: We start by importing the NumPy and Matplotlib libraries. These are our trusty tools for handling numerical calculations and creating visual wonders.\nDefining Radial Values: The r array represents the radial distance from the center. We use NumPy’s arange() function to generate values from 0 to 2 in increments of 0.01. This gives us the varying distances from the center.\nConverting to Angles: Here comes the magic! We calculate the corresponding angles in radians using the formula 2 * pi * r. This establishes the circular motion around the center point.\nCreating the Plotting Canvas: With Matplotlib’s help, we create a figure and axis with a polar projection. This sets the stage for our polar coordinate plot.\nPlotting the Data: Using the plot() function, we unveil our plot to the world! The theta values represent the angles, and the r values dictate the distance from the center. As we connect the dots, a beautiful pattern unfolds.\nRadial Ticks and Grid: To make our plot more user-friendly, we customize the radial ticks to show values of 0.5, 1, 1.5, and 2. We also add grid lines to assist in interpreting the plot.\nShowcasing the Masterpiece: Finally, we display our creation using plt.show(). Behold the captivating polar coordinate plot!"
  },
  {
    "objectID": "posts/document.html#your-voyage-into-polar-coordinates",
    "href": "posts/document.html#your-voyage-into-polar-coordinates",
    "title": "Exploring Polar Coordinate Plots in Python Using Matplotlib",
    "section": "Your Voyage into Polar Coordinates",
    "text": "Your Voyage into Polar Coordinates\nCongratulations! You’ve just embarked on a visual adventure that combines mathematics and artistry. Through a few lines of Python code, you’ve created a stunning polar coordinate plot using Matplotlib. As you delve deeper into the world of programming and data visualization, remember that every line of code has the potential to bring your imagination to life.\nSo go ahead, experiment with different values, and let your creativity flourish. The world of data visualization is at your fingertips, waiting for you to explore and innovate. Happy coding and plotting!"
  },
  {
    "objectID": "posts/document.html#lets-break-it-down-decoding-the-code",
    "href": "posts/document.html#lets-break-it-down-decoding-the-code",
    "title": "Exploring Polar Coordinate Plots in Python Using Matplotlib",
    "section": "Let’s Break It Down: Decoding the Code",
    "text": "Let’s Break It Down: Decoding the Code\n1. Importing Libraries: We start by importing the NumPy and Matplotlib libraries. These are our trusty tools for handling numerical calculations and creating visual wonders.\n2. Defining Radial Values: The r array represents the radial distance from the center. We use NumPy’s arange() function to generate values from 0 to 2 in increments of 0.01. This gives us the varying distances from the center.\n3. Converting to Angles: Here comes the magic! We calculate the corresponding angles in radians using the formula 2 * pi * r. This establishes the circular motion around the center point.\n4. Creating the Plotting Canvas: With Matplotlib’s help, we create a figure and axis with a polar projection. This sets the stage for our polar coordinate plot.\n5. Plotting the Data: Using the plot() function, we unveil our plot to the world! The theta values represent the angles, and the r values dictate the distance from the center. As we connect the dots, a beautiful pattern unfolds.\n6. Radial Ticks and Grid: To make our plot more user-friendly, we customize the radial ticks to show values of 0.5, 1, 1.5, and 2. We also add grid lines to assist in interpreting the plot.\n7. Showcasing the Masterpiece: Finally, we display our creation using plt.show(). Behold the captivating polar coordinate plot!"
  },
  {
    "objectID": "posts/document.html#conclusion-your-voyage-into-polar-coordinates",
    "href": "posts/document.html#conclusion-your-voyage-into-polar-coordinates",
    "title": "Exploring Polar Coordinate Plots in Python Using Matplotlib",
    "section": "Conclusion: Your Voyage into Polar Coordinates",
    "text": "Conclusion: Your Voyage into Polar Coordinates\nCongratulations! You’ve just embarked on a visual adventure that combines mathematics and artistry. Through a few lines of Python code, you’ve created a stunning polar coordinate plot using Matplotlib. As you delve deeper into the world of programming and data visualization, remember that every line of code has the potential to bring your imagination to life.\nSo go ahead, experiment with different values, and let your creativity flourish. The world of data visualization is at your fingertips, waiting for you to explore and innovate. Happy coding and plotting!"
  },
  {
    "objectID": "posts/matplotlib.html",
    "href": "posts/matplotlib.html",
    "title": "Exploring Polar Coordinate Plot in Python Using Matplotlib",
    "section": "",
    "text": "A polar plot is a type of graph that presents data in a circular format, offering a fresh perspective beyond the conventional Cartesian coordinate system. In a polar plot, data points are represented using radial distance from a central point and angular positions, creating a distinct visual representation that emphasizes patterns and relationships in a unique way. This type of plot is particularly suitable for data that exhibits directional or cyclic patterns, such as time series data, circular data (e.g., wind direction), or any data with inherent periodicity. Polar plots excel at revealing cyclical trends and variations that might go unnoticed on traditional scatter plots. They allow us to easily observe changes in data values as they evolve over angles, providing insights into periodic behaviors, phase shifts, and synchronization. Whether in the realms of engineering, meteorology, or scientific research, polar plots offer a valuable tool for gaining deeper insights from complex datasets that might otherwise remain hidden in a sea of numbers.\nFor a demonstration of a line plot on a polar axis, see Figure 1.\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Define an array of values for the radial distance\nr = np.arange(0, 2, 0.01)\n\n# Convert the radial distance into angles\ntheta = 2 * np.pi * r\n\n# Create a figure and axis with polar projection\nfig, ax = plt.subplots(subplot_kw={'projection': 'polar'})\n\n# Plot the data points on the polar axis\nax.plot(theta, r)\n\n# Customize the radial ticks to enhance readability\nax.set_rticks([0.5, 1, 1.5, 2])\n\n# Add grid lines for a clear reference\nax.grid(True)\n\n# Display the enchanting plot\nplt.show()\n\n\n\n\nFigure 1: A line plot on a polar axis"
  },
  {
    "objectID": "posts/matplotlib.html#polar-plot",
    "href": "posts/matplotlib.html#polar-plot",
    "title": "Exploring Polar Coordinate Plot in Python Using Matplotlib",
    "section": "",
    "text": "A polar plot is a type of graph that presents data in a circular format, offering a fresh perspective beyond the conventional Cartesian coordinate system. In a polar plot, data points are represented using radial distance from a central point and angular positions, creating a distinct visual representation that emphasizes patterns and relationships in a unique way. This type of plot is particularly suitable for data that exhibits directional or cyclic patterns, such as time series data, circular data (e.g., wind direction), or any data with inherent periodicity. Polar plots excel at revealing cyclical trends and variations that might go unnoticed on traditional scatter plots. They allow us to easily observe changes in data values as they evolve over angles, providing insights into periodic behaviors, phase shifts, and synchronization. Whether in the realms of engineering, meteorology, or scientific research, polar plots offer a valuable tool for gaining deeper insights from complex datasets that might otherwise remain hidden in a sea of numbers.\nFor a demonstration of a line plot on a polar axis, see Figure 1.\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Define an array of values for the radial distance\nr = np.arange(0, 2, 0.01)\n\n# Convert the radial distance into angles\ntheta = 2 * np.pi * r\n\n# Create a figure and axis with polar projection\nfig, ax = plt.subplots(subplot_kw={'projection': 'polar'})\n\n# Plot the data points on the polar axis\nax.plot(theta, r)\n\n# Customize the radial ticks to enhance readability\nax.set_rticks([0.5, 1, 1.5, 2])\n\n# Add grid lines for a clear reference\nax.grid(True)\n\n# Display the enchanting plot\nplt.show()\n\n\n\n\nFigure 1: A line plot on a polar axis"
  },
  {
    "objectID": "posts/matplotlib.html#lets-break-it-down-decoding-the-code",
    "href": "posts/matplotlib.html#lets-break-it-down-decoding-the-code",
    "title": "Exploring Polar Coordinate Plot in Python Using Matplotlib",
    "section": "Let’s Break It Down: Decoding the Code",
    "text": "Let’s Break It Down: Decoding the Code\n1. Importing Libraries: We start by importing the NumPy and Matplotlib libraries. These are our trusty tools for handling numerical calculations and creating visual wonders.\n2. Defining Radial Values: The r array represents the radial distance from the center. We use NumPy’s arange() function to generate values from 0 to 2 in increments of 0.01. This gives us the varying distances from the center.\n3. Converting to Angles: Here comes the magic! We calculate the corresponding angles in radians using the formula 2 * pi * r. This establishes the circular motion around the center point.\n4. Creating the Plotting Canvas: With Matplotlib’s help, we create a figure and axis with a polar projection. This sets the stage for our polar coordinate plot.\n5. Plotting the Data: Using the plot() function, we unveil our plot to the world! The theta values represent the angles, and the r values dictate the distance from the center. As we connect the dots, a beautiful pattern unfolds.\n6. Radial Ticks and Grid: To make our plot more user-friendly, we customize the radial ticks to show values of 0.5, 1, 1.5, and 2. We also add grid lines to assist in interpreting the plot.\n7. Showcasing the Masterpiece: Finally, we display our creation using plt.show(). Behold the captivating polar coordinate plot!"
  },
  {
    "objectID": "posts/matplotlib.html#conclusion-your-voyage-into-polar-coordinates",
    "href": "posts/matplotlib.html#conclusion-your-voyage-into-polar-coordinates",
    "title": "Exploring Polar Coordinate Plot in Python Using Matplotlib",
    "section": "Conclusion: Your Voyage into Polar Coordinates",
    "text": "Conclusion: Your Voyage into Polar Coordinates\nCongratulations! You’ve just embarked on a visual adventure that combines mathematics and artistry. Through a few lines of Python code, you’ve created a stunning polar coordinate plot using Matplotlib. As you delve deeper into the world of programming and data visualization, remember that every line of code has the potential to bring your imagination to life.\nSo go ahead, experiment with different values, and let your creativity flourish. The world of data visualization is at your fingertips, waiting for you to explore and innovate. Happy coding and plotting!"
  },
  {
    "objectID": "posts/reticulate.html",
    "href": "posts/reticulate.html",
    "title": "Python Setup in R with Reticulate",
    "section": "",
    "text": "# load r packages, including reticulate\nlibrary(tidyverse)\nlibrary(reticulate)\n\n# list current conda environments\nconda_list()\n# Set conda environment to use\nuse_condaenv(\"pydata-book\", required=TRUE)\n# Confirm the selected conda and python environemtn\npy_config()\n# Run some strings of python codes.\npy_run_string(\"import os as os\")\n\n# Very simple python function and an expression\nprint(\"Hello World!\")\n1+1\n\nHello World!\n\n\n2\n\n\n\n# package import and some data import\n\nimport numpy as np\nimport pandas as pd\n\narr = np.arange(1, 10)\nprint(type(arr))\narr\n\n# data frame creation\ndf = pd.DataFrame(data = {\"sequence\":np.arange(1,20,.01)})\ndf\ndf = df.assign(value=np.sin(df[\"sequence\"]))\ndf\n\n&lt;class 'numpy.ndarray'&gt;\n\n\n\n\n\n\n\n\n\nsequence\nvalue\n\n\n\n\n0\n1.00\n0.841471\n\n\n1\n1.01\n0.846832\n\n\n2\n1.02\n0.852108\n\n\n3\n1.03\n0.857299\n\n\n4\n1.04\n0.862404\n\n\n...\n...\n...\n\n\n1895\n19.95\n0.891409\n\n\n1896\n19.96\n0.895896\n\n\n1897\n19.97\n0.900294\n\n\n1898\n19.98\n0.904602\n\n\n1899\n19.99\n0.908819\n\n\n\n\n1900 rows × 2 columns\n\n\n\nVisualize the data frame using Matplotlib\n\nimport matplotlib.pyplot as plt\n\ndf.plot(x=\"sequence\", y = \"value\", title = \"Matplotlib\")\nplt.show()\n\n\n\n\n\n\n\nfrom sklearn.ensemble import RandomForestClassifier\n\nclf = RandomForestClassifier(random_state=0)\n\nX = [[ 1,  2,  3],  # 2 samples, 3 features\n     [11, 12, 13]]\n\ny = [0, 1]  # classes of each sample\n\nclf.fit(X, y)\n\nRandomForestClassifier(random_state=0)In a Jupyter environment, please rerun this cell to show the HTML representation or trust the notebook. On GitHub, the HTML representation is unable to render, please try loading this page with nbviewer.org.RandomForestClassifierRandomForestClassifier(random_state=0)\n\n\n\n\n\n\nfrom sklearn.cluster import AffinityPropagation\nfrom sklearn.datasets import make_blobs\n\n# #############################################################################\n# Generate sample data\ncenters = [[1, 1], [-1, -1], [1, -1]]\nX, labels_true = make_blobs(n_samples=300, centers=centers, cluster_std=0.5,\n                            random_state=0)\n\n# Compute Affinity Propagation\naf = AffinityPropagation(preference=-50).fit(X)\ncluster_centers_indices = af.cluster_centers_indices_\nlabels = af.labels_\n\nn_clusters_ = len(cluster_centers_indices)\n\n# #############################################################################\n# Plot result\nimport matplotlib.pyplot as plt\nfrom itertools import cycle\n\nplt.close('all')\nplt.figure(1)\nplt.clf()\n\ncolors = cycle('bgrcmykbgrcmykbgrcmykbgrcmyk')\nfor k, col in zip(range(n_clusters_), colors):\n    class_members = labels == k\n    cluster_center = X[cluster_centers_indices[k]]\n    plt.plot(X[class_members, 0], X[class_members, 1], col + '.')\n    plt.plot(cluster_center[0], cluster_center[1], 'o', markerfacecolor=col,\n             markeredgecolor='k', markersize=14)\n    for x in X[class_members]:\n        plt.plot([cluster_center[0], x[0]], [cluster_center[1], x[1]], col)\n\nplt.title('Estimated number of clusters: %d' % n_clusters_)\nplt.show()"
  },
  {
    "objectID": "posts/reticulate.html#scikit-learn---random-forest",
    "href": "posts/reticulate.html#scikit-learn---random-forest",
    "title": "Python Setup in R with Reticulate",
    "section": "",
    "text": "from sklearn.ensemble import RandomForestClassifier\n\nclf = RandomForestClassifier(random_state=0)\n\nX = [[ 1,  2,  3],  # 2 samples, 3 features\n     [11, 12, 13]]\n\ny = [0, 1]  # classes of each sample\n\nclf.fit(X, y)\n\nRandomForestClassifier(random_state=0)In a Jupyter environment, please rerun this cell to show the HTML representation or trust the notebook. On GitHub, the HTML representation is unable to render, please try loading this page with nbviewer.org.RandomForestClassifierRandomForestClassifier(random_state=0)"
  },
  {
    "objectID": "posts/reticulate.html#run-affinity-propagation",
    "href": "posts/reticulate.html#run-affinity-propagation",
    "title": "Python Setup in R with Reticulate",
    "section": "",
    "text": "from sklearn.cluster import AffinityPropagation\nfrom sklearn.datasets import make_blobs\n\n# #############################################################################\n# Generate sample data\ncenters = [[1, 1], [-1, -1], [1, -1]]\nX, labels_true = make_blobs(n_samples=300, centers=centers, cluster_std=0.5,\n                            random_state=0)\n\n# Compute Affinity Propagation\naf = AffinityPropagation(preference=-50).fit(X)\ncluster_centers_indices = af.cluster_centers_indices_\nlabels = af.labels_\n\nn_clusters_ = len(cluster_centers_indices)\n\n# #############################################################################\n# Plot result\nimport matplotlib.pyplot as plt\nfrom itertools import cycle\n\nplt.close('all')\nplt.figure(1)\nplt.clf()\n\ncolors = cycle('bgrcmykbgrcmykbgrcmykbgrcmyk')\nfor k, col in zip(range(n_clusters_), colors):\n    class_members = labels == k\n    cluster_center = X[cluster_centers_indices[k]]\n    plt.plot(X[class_members, 0], X[class_members, 1], col + '.')\n    plt.plot(cluster_center[0], cluster_center[1], 'o', markerfacecolor=col,\n             markeredgecolor='k', markersize=14)\n    for x in X[class_members]:\n        plt.plot([cluster_center[0], x[0]], [cluster_center[1], x[1]], col)\n\nplt.title('Estimated number of clusters: %d' % n_clusters_)\nplt.show()"
  },
  {
    "objectID": "posts/p4da3d-data-types.html",
    "href": "posts/p4da3d-data-types.html",
    "title": "[3] Built-In Data Structures, Functions, and Files",
    "section": "",
    "text": "Python Tuples: Immutable, ordered collections that allow you to store a sequence of elements. Tuples are defined using parentheses and can hold a mix of data types. They offer efficient data storage, are iterable, and can be used as keys in dictionaries. In this blog, we’ll explore the versatility of Python tuples and how to leverage them for various data analysis tasks.\n\n# create some tuples\ntup = (4, 5, 6)\ntup2 = 7, 8, 9\nprint(tup)\nprint(tup2)\nt = (tup, tup2)    # tuple of tuples\nprint(t)\ntype(t)\n\n# convert any sequence or iterator to tuple\nprint(tuple(['a', 'b', 'c']))\nprint(tuple('Some String'))\n\n# access elements\nnested_tup = ((4,5,6), (7,8))\nprint(nested_tup[1])\n\n(4, 5, 6)\n(7, 8, 9)\n((4, 5, 6), (7, 8, 9))\n('a', 'b', 'c')\n('S', 'o', 'm', 'e', ' ', 'S', 't', 'r', 'i', 'n', 'g')\n(7, 8)\n\n\nTuple itself is immutable; however, if an object inside a tuple is mutable, you can modify it in place.\n\ntup = tuple(['The bown ','fox ', 'jumped over the ',['fence.']])\nprint(tup)\n# tup[1] = 'wolf'           # error\ntup[3][0] = 'window '     # ok\nprint(tup)\ntup[3].append('fence')    # ok\nprint(tup)\n\n('The bown ', 'fox ', 'jumped over the ', ['fence.'])\n('The bown ', 'fox ', 'jumped over the ', ['window '])\n('The bown ', 'fox ', 'jumped over the ', ['window ', 'fence'])\n\n\nConcatenation, Variable swap, Unpacking\n\n# concatenation using +\ntup = (4, None, 'foo') + (6, 0) + ('bar',)\nprint(tup)\n\n# Swap\na, b = 1, 2\nprint(a, b)\nb, a = a, b\nprint(a, b)\n\n# Unpacking by iterating over sequences of tuples, lists\nseq = [('a1', 'a2', 'a3'),('b4', 'b5', 'b6'), ('c7', 'c8', 'c9')]\nprint(seq, type(seq))\nfor a, b, c in seq:\n  print(f'a={a}, b={b}, c={c}')\n  \n# unpacking using assignment, not concerning some trailing values\nvalues = 1, 2, 3, 4, 5, 6, 7\na, b, *_ = values     # *rest works the same as *_\nprint (a, b, *_)\n\n# method .count()\na = (1, 2, 2, 2, 3, 4, 2)\nprint(a.count(2))     # number of occurences\n\n(4, None, 'foo', 6, 0, 'bar')\n1 2\n2 1\n[('a1', 'a2', 'a3'), ('b4', 'b5', 'b6'), ('c7', 'c8', 'c9')] &lt;class 'list'&gt;\na=a1, b=a2, c=a3\na=b4, b=b5, c=b6\na=c7, b=c8, c=c9\n1 2 3 4 5 6 7\n4\n\n\n\n\n\nPython Lists: Ordered, mutable collections that allow you to store and manipulate sequences of items. Lists are versatile and can hold various data types. They support methods for adding, removing, and modifying elements, making them a fundamental data structure for data analysis and manipulation in Python.\n\n# create, convert lists\na_list = [2, 3, 7, None]\ntup = (\"foo\", \"bar\", \"baz\")\nb_list = list(tup)\nprint(b_list, type(b_list))\n\n# Access, modify list element\nb_list[1] = \"peekaboo\"\nprint(b_list)\n\n# Materialize an iterator / generator\ngen = range(20) # generator, not materialized yet.\nprint(gen) \nlist(gen) # materialize the generator to list\n\n# Work with the elements\nb_list.append(\"dwarf\")     # add to the end of list\nb_list.append(\"foo\")\nprint(b_list)\nb_list.insert(1, \"RED\")     # insert at specific location, consider using collections.deque for efficiency\nprint(b_list)\nb_list.remove(\"foo\")        # remove the first occurence only\nprint(b_list)\n\n# Check if element in the list\nprint(\"dwarf\" in b_list)\nprint(\"dwarf\" not in b_list)\n\n['foo', 'bar', 'baz'] &lt;class 'list'&gt;\n['foo', 'peekaboo', 'baz']\nrange(0, 20)\n['foo', 'peekaboo', 'baz', 'dwarf', 'foo']\n['foo', 'RED', 'peekaboo', 'baz', 'dwarf', 'foo']\n['RED', 'peekaboo', 'baz', 'dwarf', 'foo']\nTrue\nFalse\n\n\n\n# Concatenate and combine lists\nnew_list = [4, None, \"foo\"] + [7, 8, (2, 3)]\nprint(new_list)\nprint(b_list)\nnew_list.extend(b_list)\nprint(new_list)\n\n# Sorting in place\na = [\"saw\", \"small\", \"He\", \"foxes\", \"six\"]\na.sort() # default\nprint(a)\na.sort(key=len) # sort by key with given function, by the length of each element\nprint(a)\n\n# Sorted copy\na = [\"saw\", \"small\", \"He\", \"foxes\", \"six\"]\nsorted_copy = sorted(a)\nprint(sorted_copy)\n\n[4, None, 'foo', 7, 8, (2, 3)]\n['RED', 'peekaboo', 'baz', 'dwarf', 'foo']\n[4, None, 'foo', 7, 8, (2, 3), 'RED', 'peekaboo', 'baz', 'dwarf', 'foo']\n['He', 'foxes', 'saw', 'six', 'small']\n['He', 'saw', 'six', 'foxes', 'small']\n['He', 'foxes', 'saw', 'six', 'small']\n\n\n\n# Slices\n\nseq = [7, 2, 3, 7, 5, 6, 0, 1]\nprint(seq)\nprint(seq[1:5])   # index:1 - index: 4\nprint(seq[:5])    # index:beginning - index: 4\nprint(seq[5:])    # index:5 - index:last\nprint(seq[-4:])   # Indexing from the last, index:-4 to the end\nprint(seq[-6:-2]) # Indexing from the last, index: -6 to index: -2\n\nprint(\"-\"*30)\n\n# Stepping the list\nprint(seq[::2])     # Extract index 0, 2, 4, 6 ....\nprint(seq[::3])     # Extract index 0, 3, 6 ....\nprint(seq[::-2])    # Extract index -1, -3, -5 .....\nprint(seq[::-1])    # Extract index -1, -2, -3, -4 ... effectively reverse the list or tuple\n\n\nprint(\"-\"*30)\n\n# Slices replacement\nseq[3:5] = ['A','B']\nprint(seq)\n\n[7, 2, 3, 7, 5, 6, 0, 1]\n[2, 3, 7, 5]\n[7, 2, 3, 7, 5]\n[6, 0, 1]\n[5, 6, 0, 1]\n[3, 7, 5, 6]\n------------------------------\n[7, 3, 5, 0]\n[7, 7, 0]\n[1, 6, 7, 2]\n[1, 0, 6, 5, 7, 3, 2, 7]\n------------------------------\n[7, 2, 3, 'A', 'B', 6, 0, 1]\n\n\n\n\n\nPython Dictionaries: Versatile and dynamic data structures that store key-value pairs, allowing for efficient data retrieval and manipulation. Dictionaries are unordered collections that provide a way to map unique keys to associated values, making them invaluable for tasks like data storage, lookup tables, and configuration settings\n\n# Create a Dictionary (aka, hash-map, associative arrays)\n\nempty_dict = {} \nprint(empty_dict)\nd1 = {\"a\": \"some value\", \"b\": [1, 2, 3, 4]}  # key-value pair\nprint(d1)\n\n# Access, insert and set\nd1[7] = \"an integer\"      # 7:\"an integer\" pair\nprint(d1)\nprint(d1[\"b\"])            # lookup with key\n#print(d1[\"address\"])     # KeyError\nprint(\"address\" in d1)    # key exists?\n\nprint(\"-\"*30)\n\n# Delete values\ndel d1[7]              # delete with key\n#del d1[\"country\"]     # KeyError\nprint(d1)\nret = d1.pop(\"b\")      # delete with key and return the value\nprint(ret)\nprint(d1)\n\nprint(\"-\"*30)\n\n# Iteration using keys() values() items()\nd1 = {'a': 'some value', 'b': [1, 2, 3, 4], 7: 'an integer'}\nprint(type(d1.keys()))     # &lt;class 'dict_keys'&gt;\nprint(type(d1.values()))   # &lt;class 'dict_values'&gt;\n\nd1_keys = list(d1.keys())   \nd1_values = list(d1.values())\nd1_items = list(d1.items())  # Gives a list of tuples in (key, value)\nprint(d1_keys)\nprint(d1_values)\nprint(d1_items)  \n\n# iteration\nfor key, value in d1.items():\n  print(f'Key: \\\"{key}\\\" has value of \\\"{value}\\\".')\n\n{}\n{'a': 'some value', 'b': [1, 2, 3, 4]}\n{'a': 'some value', 'b': [1, 2, 3, 4], 7: 'an integer'}\n[1, 2, 3, 4]\nFalse\n------------------------------\n{'a': 'some value', 'b': [1, 2, 3, 4]}\n[1, 2, 3, 4]\n{'a': 'some value'}\n------------------------------\n&lt;class 'dict_keys'&gt;\n&lt;class 'dict_values'&gt;\n['a', 'b', 7]\n['some value', [1, 2, 3, 4], 'an integer']\n[('a', 'some value'), ('b', [1, 2, 3, 4]), (7, 'an integer')]\nKey: \"a\" has value of \"some value\".\nKey: \"b\" has value of \"[1, 2, 3, 4]\".\nKey: \"7\" has value of \"an integer\".\n\n\n\n# Update dictionary with a dictionary of new or changes of key-value pairs\nd1 = {'a': 'some value', 'b': [1, 2, 3, 4], 7: 'an integer'}\nprint(d1)\nd1.update({\"b\": \"foo\", \"c\": 12})\nprint(d1)\n\n{'a': 'some value', 'b': [1, 2, 3, 4], 7: 'an integer'}\n{'a': 'some value', 'b': 'foo', 7: 'an integer', 'c': 12}\n\n\n\n# Create a dictionary from two sequences\n\nlist_country = [\"USA\", \"Canada\", \"England\", \"France\"]\nlist_city = [\"Washigton\", \"Ottawa\", \"London\", \"Paris\"]\nprint(list_country)\nprint(list_city)\n\n# Using for loop - zip and iterate\nprint(zip(list_country, list_city))\n\nmapping = {}\nfor key, value in zip(list_country, list_city):\n  mapping[key] = value\nprint(mapping, type(mapping))\n\n# Using dict() method\ncountry_city_tuples = zip(list_country, list_city)\nprint(country_city_tuples, type(country_city_tuples))\nmapping = dict(country_city_tuples)\nprint(mapping, type(mapping))\n\n['USA', 'Canada', 'England', 'France']\n['Washigton', 'Ottawa', 'London', 'Paris']\n&lt;zip object at 0x000001BD9F64EB00&gt;\n{'USA': 'Washigton', 'Canada': 'Ottawa', 'England': 'London', 'France': 'Paris'} &lt;class 'dict'&gt;\n&lt;zip object at 0x000001BD9F64C2C0&gt; &lt;class 'zip'&gt;\n{'USA': 'Washigton', 'Canada': 'Ottawa', 'England': 'London', 'France': 'Paris'} &lt;class 'dict'&gt;\n\n\n\n# Build a dictionary WUTHOUT using setdefault()\nwords = [\"apple\", \"bat\", \"bar\", \"atom\", \"book\"]\nprint(words, type(words))\n\nby_letter = {}\n\nfor word in words:\n  letter = word[0] # Using the first letter of each word as key\n  if letter not in by_letter:\n    by_letter[letter] = [word]\n  else:\n    by_letter[letter].append(word)\n\nprint(by_letter)\n\nprint(\"-\"*55)\n\n# Simplified version using setdefault()\n\nwords = [\"apple\", \"bat\", \"bar\", \"atom\", \"book\"]\nby_letter = {}\nfor word in words:\n  letter = word[0] # Using the first letter of each word as key\n  by_letter.setdefault(letter, []).append(word) # If the letter (the first letter of the current word) is already a key in the dictionary, it returns the corresponding value (which is a list) for that key. If the key doesn't exist, it initializes an empty list. The append() method is then used to add the current word to the list associated with the letter key.\nprint(by_letter)\n\nprint(\"-\"*55)\n\n# Using defaultdict from collections module\nfrom collections import defaultdict\n\nwords = [\"apple\", \"bat\", \"bar\", \"atom\", \"book\"]\nby_letter = defaultdict(list) # if you access a key that doesn't exist, it will automatically create that key with an empty list as the associated value. This is particularly useful when you want to avoid KeyError exceptions when working with dictionaries.\nprint(by_letter, type(by_letter))\n\nfor word in words:\n  by_letter[word[0]].append(word)\n\nprint(by_letter)\n\n['apple', 'bat', 'bar', 'atom', 'book'] &lt;class 'list'&gt;\n{'a': ['apple', 'atom'], 'b': ['bat', 'bar', 'book']}\n-------------------------------------------------------\n{'a': ['apple', 'atom'], 'b': ['bat', 'bar', 'book']}\n-------------------------------------------------------\ndefaultdict(&lt;class 'list'&gt;, {}) &lt;class 'collections.defaultdict'&gt;\ndefaultdict(&lt;class 'list'&gt;, {'a': ['apple', 'atom'], 'b': ['bat', 'bar', 'book']})\n\n\nUnderstanding Dictionary Key Types\nIn Python, dictionaries are versatile data structures used for mapping keys to corresponding values. While dictionaries allow flexibility in storing values of any Python data type as their values, there are specific requirements and considerations when it comes to selecting suitable key types. This aspect of dictionary design is crucial to ensure efficient and reliable key-value pair lookups and operations.\nKey Characteristics of Dictionary Keys\n\nImmutability Requirement:\nThe primary requirement for dictionary keys is that they should generally be immutable objects. Immutability refers to the property of an object that prevents its state from being modified after it is created.\nExamples of Immutable Key Types:\n\nScalar Types: Examples of immutable scalar types suitable as dictionary keys include integers (int), floating-point numbers (float), and strings (str). These types are inherently immutable, which means once you create a key with a specific value, that key-value pair remains consistent.\nTuples as Composite Keys: Tuples can also serve as dictionary keys, but there’s an important condition: all the objects within the tuple must also be immutable. This ensures the stability of the key, as the tuple itself remains unchanged.\n\n\nThe Significance of Hashability\nThe technical term that ties these requirements together is “hashability.” Hashability refers to an object’s ability to be hashed, which involves converting the object into a fixed-size numerical value, known as a hash code. This hash code is used as an index to efficiently store and retrieve key-value pairs in a dictionary. The key feature of hashable objects is that they produce the same hash code consistently.\nThe Role of the hash() Function\nYou can determine whether an object is hashable and can be used as a dictionary key by utilizing the built-in hash() function. When you apply the hash() function to an object, it returns a hash code if the object is hashable. However, keep in mind that not all Python objects are hashable, particularly mutable objects like lists and dictionaries.\n\n# Using hash() to validate key types in dictionary\n\nhash(\"string\")           # hashable\nhash((1, 2, (2, 3)))     # hashable\n# hash((1, 2, [2, 3]))     # Not hashable due to mutable element - list of [2, 3]\n\n# When in need of list for key, convert it tp tuple, hashable\nd = {}\nd[tuple([1,2,3])] = 5\nprint(d)  # dictionary with a tuple as key\n\n{(1, 2, 3): 5}\n\n\n\n\n\nSets in Python: A Set is an essential data structure that represents an unordered collection of unique elements. Unlike lists or tuples, which allow duplicates, sets only store distinct values. This characteristic makes sets ideal for various tasks, such as removing duplicates from a list, checking for membership, and performing set operations like union, intersection, and difference. One of the most common real-world use cases for sets is in data deduplication, where they excel at efficiently eliminating duplicate records from datasets, ensuring data integrity and enhancing the performance of data processing tasks.\n\n# Create a set\nprint(set([2, 2, 2, 1, 3, 3]))\nprint\n\n# Union, Difference, Intersection and Symmetric Difference\na = {1, 2, 3, 4, 5}\nb = {3, 4, 5, 6, 7, 8}\nprint (\"Set a:\", a, \" Set b:\", b)\n\n# a.union(b) = a | b\nprint(\"a union b: \", a.union(b), a | b)\n# a.intersection(b) = a & b\nprint(\"a intersection b: \", a.intersection(b), a & b)\n# a.difference(b) = a - b\nprint(\"a difference b: \", a.difference(b), a - b)\n# a.symmetric_difference(b)\nprint(\"a.symmetric_difference(b): \", a.symmetric_difference(b), a ^ b)\n\n{1, 2, 3}\nSet a: {1, 2, 3, 4, 5}  Set b: {3, 4, 5, 6, 7, 8}\na union b:  {1, 2, 3, 4, 5, 6, 7, 8} {1, 2, 3, 4, 5, 6, 7, 8}\na intersection b:  {3, 4, 5} {3, 4, 5}\na difference b:  {1, 2} {1, 2}\na.symmetric_difference(b):  {1, 2, 6, 7, 8} {1, 2, 6, 7, 8}\n\n\n\n# Common set operations\na = {1, 2, 3, 4, 5}\n\n# a.add(x) - Add x to the set\na.add(\"Fox\")\nprint(a)\n# a.remove(x) - Remove x from the set\na.remove(\"Fox\")\nprint(a)\n# a.pop() - Remove an element arbitrarily, set must not be empty\nret = a.pop()\nprint(a, ret)\n\n\n\n# a.clear() - reset to empty\nprint(a.clear())  # None - empty\n\n{1, 2, 3, 4, 5, 'Fox'}\n{1, 2, 3, 4, 5}\n{2, 3, 4, 5} 1\nNone\n\n\nBuilt-in Sequence Functions\n\na_list = [7, 1, 2, 6, 0, 3, 2]\n\n# Very useful, use at every opportunities\n\n# enumerate() - no need to write code to track index\nfor index, value in enumerate(a_list):\n  print(index, \" : \", value)  \n\n# sorted() - a new srted list from the elements of any sequence\nprint(sorted(a_list))\nprint(sorted(\"horse race\"))  # string is a sequence\n\n# zip() - pairs up sequences element-wise to create a list\nseq1 = [\"foo\", \"bar\", \"baz\"]\nseq2 = [\"one\", \"two\", \"three\"]\nseq3 = [\"BROWN\", \"FOX\", \"FENCE\", \"JUMP\"]\nzipped = zip(seq1, seq2, seq3)\nprint(list(zipped))  # \"JUMP\" ignored for pariing!\n\n# zip() commonly works with enumerate() for iteration - zip and iterate\nfor index, (a, b) in enumerate(zip(seq1, seq2)):\n  print(f\"{index}: {a}, {b}\")\n\n# reversed()\nreversed(range(10)) # range_iterator object, it's a generator\nprint(list(reversed(range(10)))) # list() materializes the generator\n\n0  :  7\n1  :  1\n2  :  2\n3  :  6\n4  :  0\n5  :  3\n6  :  2\n[0, 1, 2, 2, 3, 6, 7]\n[' ', 'a', 'c', 'e', 'e', 'h', 'o', 'r', 'r', 's']\n[('foo', 'one', 'BROWN'), ('bar', 'two', 'FOX'), ('baz', 'three', 'FENCE')]\n0: foo, one\n1: bar, two\n2: baz, three\n[9, 8, 7, 6, 5, 4, 3, 2, 1, 0]\n\n\n\n\n\nComprehensions in Python offer concise, readable, and often more efficient ways to create lists, sets, and dictionaries. They reduce code verbosity, enhance readability, and promote a functional programming style, ultimately leading to cleaner and more maintainable code.\nList Comprehension:\nList comprehensions provide a concise way to create lists by applying an expression to each item in an iterable (e.g., a list, tuple, or range) and optionally filtering the items based on a condition.\n\n## [exp for value in collection if condition]\n\n# create a list of strings in uppercase only if the string has more than two characters.\nstrings = [\"a\", \"as\", \"bat\", \"car\", \"dove\", \"python\"]\nstrings_2 = [ str.upper() for str in strings if len(str) &gt; 2 ]\nprint(strings_2)\n\n# create a list of squares of even numbers from 0 to 9\neven_squares = [ x ** 2 for x in range(10) if x % 2 == 0 ]\nprint(even_squares)\n\n['BAT', 'CAR', 'DOVE', 'PYTHON']\n[0, 4, 16, 36, 64]\n\n\nSet Comprehension:\nSet comprehensions allow you to create sets in a similar manner to list comprehensions, but with the guarantee of uniqueness among elements.\n\n## set_comp = {expr for value in collection if condition}\n\n# Create a set using strings list above, containing only the lengths of strings.\nstrings = [\"a\", \"as\", \"bat\", \"car\", \"dove\", \"python\"]\nunique_lengths = { len(str) for str in strings } # uniqueness guaranted\nprint(unique_lengths)\n\n# map() - even more powerful\nstrings_map = set(map(len, strings))\nprint(strings_map)\n\n# Create a set of unique even squares from 0 to 9\neven_squares_set = {x ** 2 for x in range(10) if x % 2 == 0}\nprint(even_squares_set)\n\n{1, 2, 3, 4, 6}\n{1, 2, 3, 4, 6}\n{0, 64, 4, 36, 16}\n\n\nDictionary Comprehension:\nDictionary comprehensions enable the creation of dictionaries by defining key-value pairs based on expressions applied to items in an iterable.\n\n## {key_expression: value_expression for item in iterable if condition}\n\n# Create a dictionary, mapping even numbers to their squares from 0 to 9\neven_squares_dict = { x: x**2 for x in range(10) if x % 2 == 0 }\nprint(even_squares_dict)\n\n# Create a dictionary of lookup map of string for the location of each string in the list\nstrings = [\"a\", \"as\", \"bat\", \"car\", \"dove\", \"python\"]\nstring_lookup_dict = { str: index for index, str in enumerate(strings) }\nprint(strings)\nprint(string_lookup_dict)\n\n{0: 0, 2: 4, 4: 16, 6: 36, 8: 64}\n['a', 'as', 'bat', 'car', 'dove', 'python']\n{'a': 0, 'as': 1, 'bat': 2, 'car': 3, 'dove': 4, 'python': 5}\n\n\nNested list comprehensions\nThe order of\n\n# List of lists with some English and Spanish names - List nesting lists\nall_data = [\n  [\"John\", \"Emily\", \"Michael\", \"Mary\", \"Steven\"],\n  [\"Maria\", \"Juan\", \"Javier\", \"Natalia\", \"Pilar\"]\n]\nprint(all_data)\nprint(\"-\"*55)\n\n# Create a list of names contating two of more of 'a'\n# The non-Pythonic apporach using for loop..\nnames_of_interest = []\nfor names in all_data:\n  print(\"Processing:\", names)\n  enough_as = [ name for name in names if name.count(\"a\") &gt;=2 ]\n  print(enough_as)\n  names_of_interest.extend(enough_as)\nprint(\"Results: \", names_of_interest)\n\n# Re-writtine in one-liner using nested list comprehension\nnames_of_interest = [ name for names in all_data for name in names if name.count(\"a\") &gt;=2 ]\nprint(\"Result using Nested List Comprehension: \", names_of_interest)\n\n# Flatten a list of tuples of integers into a simple list of integers using nested list comprehension\nsome_tuples = [(1, 2, 3), (4, 5, 6), (7, 8, 9)]\nprint(some_tuples, type(some_tuples)) # list of tuples with integers\nflattened = [ int for tuple in some_tuples for int in tuple ]\nprint(\"Flattened: \", flattened, type(flattened))  # flattend list\n\n# Readability and valid forms\nflattened = []\nprint(\"Init. flattened list: \", flattened)\nprint(\"some_tuples: \", some_tuples)\nfor tup in some_tuples:\n  for x in tup:\n    flattened.append(x)\nprint(\"flattend from some_tuples: \", flattened)\n\n# list comprehenson inside list comprehension\n# Change list of tuples to a list of lists\nprint(\"Init. list of some_tuples: \", some_tuples)\nnew_list_of_lists = [[ x for x in tup ] for tup in some_tuples ]\nprint(\"List of lists from some_tuples: \", new_list_of_lists)\n\n[['John', 'Emily', 'Michael', 'Mary', 'Steven'], ['Maria', 'Juan', 'Javier', 'Natalia', 'Pilar']]\n-------------------------------------------------------\nProcessing: ['John', 'Emily', 'Michael', 'Mary', 'Steven']\n[]\nProcessing: ['Maria', 'Juan', 'Javier', 'Natalia', 'Pilar']\n['Maria', 'Natalia']\nResults:  ['Maria', 'Natalia']\nResult using Nested List Comprehension:  ['Maria', 'Natalia']\n[(1, 2, 3), (4, 5, 6), (7, 8, 9)] &lt;class 'list'&gt;\nFlattened:  [1, 2, 3, 4, 5, 6, 7, 8, 9] &lt;class 'list'&gt;\nInit. flattened list:  []\nsome_tuples:  [(1, 2, 3), (4, 5, 6), (7, 8, 9)]\nflattend from some_tuples:  [1, 2, 3, 4, 5, 6, 7, 8, 9]\nInit. list of some_tuples:  [(1, 2, 3), (4, 5, 6), (7, 8, 9)]\nList of lists from some_tuples:  [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n\n\n\n# 6 Practical use caes of nested list comprehension\n\n# 1. Matrix operations:\n# Add 1 to each element in a 2D matrix\nmatrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\nmatrix_add_1 = [[ element + 1 for element in row] for row in matrix]\nprint(\"matrix_add_1: \", matrix_add_1)\n\n# 2. Data transformation:\n# Filter rows with even some from a list of lists\ndata = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\nfiltered_data = [ row for row in data if sum(row) % 2 == 0 ]\nprint(\"filtered_data: \", filtered_data)\n\n# 3. Flattening lists of lists:\nnested_lists = [[1, 2], [3, 4], [5, 6]]\nflattened_list = [ item for sublist in nested_lists for item in sublist ]\nprint(\"flattened_list: \", flattened_list)\n\n# 4. Combining data:\n# Create all possible pairs (in tuple) from two lists - Different from element-wise pairing using zip()\nlist1 = [1, 2, 3]\nlist2 = ['a', 'b', 'c']\ncombinations = [ (x, y) for x in list1 for y in list2 ]\nprint(\"combinations: \", combinations)\n\n# 5. Conditional filtering:\n# Filter rows containing 'John' from a list of lists\ndata = [['Alice', 25], ['John', 30], ['Bob', 35]]\nfiltered_data = [ list for list in data if 'John' in list ]\nprint(\"filtered_data: \", filtered_data)\n\n# 6. Transposing data:\n# Transpose a given matrix (switching rows and columns)\nmatrix = [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]]\ntransposed_matrix = [[ (row[i], print(\"row[i]: \", row[i]), print(\"processing row: \", row)) for row in matrix ] for i in range(len(matrix[0]))]\n#print(\"transposed_matrix: \", transposed_matrix)\n#print(len(matrix[0]))\n#print(range(len(matrix[0])))\n\nmatrix_add_1:  [[2, 3, 4], [5, 6, 7], [8, 9, 10]]\nfiltered_data:  [[1, 2, 3], [7, 8, 9]]\nflattened_list:  [1, 2, 3, 4, 5, 6]\ncombinations:  [(1, 'a'), (1, 'b'), (1, 'c'), (2, 'a'), (2, 'b'), (2, 'c'), (3, 'a'), (3, 'b'), (3, 'c')]\nfiltered_data:  [['John', 30]]\nrow[i]:  1\nprocessing row:  [1, 2, 3, 4]\nrow[i]:  5\nprocessing row:  [5, 6, 7, 8]\nrow[i]:  9\nprocessing row:  [9, 10, 11, 12]\nrow[i]:  2\nprocessing row:  [1, 2, 3, 4]\nrow[i]:  6\nprocessing row:  [5, 6, 7, 8]\nrow[i]:  10\nprocessing row:  [9, 10, 11, 12]\nrow[i]:  3\nprocessing row:  [1, 2, 3, 4]\nrow[i]:  7\nprocessing row:  [5, 6, 7, 8]\nrow[i]:  11\nprocessing row:  [9, 10, 11, 12]\nrow[i]:  4\nprocessing row:  [1, 2, 3, 4]\nrow[i]:  8\nprocessing row:  [5, 6, 7, 8]\nrow[i]:  12\nprocessing row:  [9, 10, 11, 12]\n\n\n\n\n\n\nFunctions in Python are a cornerstone of the language, offering powerful tools for structuring and modularizing code. Python functions come with several unique features that distinguish them from functions in other programming languages.\n\nVersatile and Expressive: Python functions support both positional and keyword arguments, enabling flexible and expressive function calls.\nMultiple Return Values: Python functions can return multiple values, simplifying the packaging and unpacking of results.\nDefault Argument Values: Python functions allow for default argument values, making function usage more straightforward by providing sensible defaults when arguments are omitted.\nLambda Functions: Python features lambda functions for concise and anonymous function definitions, particularly useful for simple operations.\nFirst-Class Functions: Python treats functions as first-class citizens, allowing them to be assigned to variables, passed as arguments, and returned from other functions. This flexibility enhances code modularity, maintainability, and readability.\nModular and Reusable: Python’s function-centric approach encourages the creation of clean, reusable, and modular code, making it a crucial topic for all Python programmers to master.\n\n\n# simple declaration and calling\ndef my_function(x,y):\n  return x + y\n\nret = my_function(1, 2)\nprint(ret)\n\n# Return None when no retorn statement is encountered\ndef funciton_without_return(x):\n  print(x)\nresult = funciton_without_return(\"hello!\")\nprint(result)\n\n# positional and keyword arguments\ndef my_function2(x, y, z=1.5):  # z as keyword argument with default value\n  if z &gt; 1:\n    return z * (x + y)\n  else:\n    return z / (x + y)\n\n# Naespace, scope and local functions\n\n\nprint(my_function2(5, 6, z=0.7))  # no need to put arg names, keword arg optional\nprint(my_function2(3.14, 7, 3.5))  # no need to specify name for kewoord arguments\nprint(my_function2(10, 20))   # keyword arg optional\n\n\na = []\ndef func():\n  for i in range(5):\n    a.append(i)\n\nfunc()\n\n3\nhello!\nNone\n0.06363636363636363\n35.49\n45.0\n\n\n\n# Assigining variable outside the function's scope\n\na = None\ndef bind_a_variable():\n  global a\n  a = []\n  \nbind_a_variable()\nprint(a)\n\n# multiple returns\ndef f():\n  a = 5\n  b = 6\n  c = 7\n  return a, b, c\n\na, b, c = f()\nprint(a, b)\n\n[]\n5 6\n\n\n\n\nIn Python, functions are first-class objects, which means they are treated like any other object, such as integers, strings, or lists. This concept is a fundamental part of the Python language and has several implications and practical uses.\n\nFunctions can be assigned to variables:\n\n\n# Functions can be assigned to variables:\n\ndef greet(name):\n    return f\"Hello, {name}!\"\n\ngreeting = greet  # function assigned to variable \nprint(greeting(\"Alice\"))  # calling the function using the assigned variable\n\nprint(id(greet), id(greeting)) # both variable and function references the same object\n\nHello, Alice!\n1913991838304 1913991838304\n\n\n\nFunctions can be passed as arguments: This is particularly useful for functions that require a callback or custom behavior.\n\n\n# Functions can be passed as arguments\n\ndef apply(func, value):\n  return func(value)\n\ndef double(x):\n  return x * 2\n\nresult = apply(double, 5)\nprint(result)\n\n10\n\n\n\nFunctions can be returned from other functions: This enables dynamic function generation.\n\n\n# Functinos can be returned from other functions\ndef create_multiplier(factor):\n  \"\"\"\n  Returns a FUNCTION that produce the result of given factor * x\n  \"\"\"\n  def multiplier(x):\n    return x * factor\n  return multiplier    # return the inner function\n\ndouble = create_multiplier(2)\nprint(double(200))  # Result is a function returned by 'created_multiplier'\nprint(double(400))\n\n400\n800\n\n\n\n\n\nFunctions can be stored in data structures like lists, dictionaries, or sets, making it possible to manage and manipulate functions dynamically.\n\n# Functinos can be stored in data structures\n\ndef square(x):\n  return x**2\n\ndef cube(x):\n  return x**3\n\nmath_functions = [square, cube]\nresult = math_functions[1](3)  # access and call the 'cube' function, give 3 to the parameter\nprint(result)\n\n\n# Using a list of functinos for cleaning strings from survey data\nanswer_states = [\"   alabama \", \"georgia!\", \"Georgia\",  \\\n          \"georgia\", \"flOrIda\", \"south   carolina##\",   \\\n          \"West virginia?\"]\nprint(answer_states)\n          \ndef remove_punctuation(value):\n  return re.sub(\"[!#?]\", \"\", value)\n\nclean_ops = [str.strip, remove_punctuation, str.title] # 3 functinos in list for cleaning operation\n\nimport re\n\ndef clean_strings(strings, ops):\n    result = []\n    for value in strings:\n        for func in ops:\n            value = func(value)\n        result.append(value)\n    return result\n  \nprint(\"strings_cleaned: \", clean_strings(answer_states, clean_ops))\n\nprint(\"-\"*55)\n\n\n# Using map() to apply a function as argument to a sequence\nfor x in map(remove_punctuation, answer_states):\n  print(x)\n\n27\n['   alabama ', 'georgia!', 'Georgia', 'georgia', 'flOrIda', 'south   carolina##', 'West virginia?']\nstrings_cleaned:  ['Alabama', 'Georgia', 'Georgia', 'Georgia', 'Florida', 'South   Carolina', 'West Virginia']\n-------------------------------------------------------\n   alabama \ngeorgia\nGeorgia\ngeorgia\nflOrIda\nsouth   carolina\nWest virginia\n\n\n\n\n\nAnonymous functions, often referred to as “lambda functions,” are a concise way to create a single line, inline functions without giving them a formal name. In Python, lambda functions are defined using the lambda keyword, followed by parameters and an expression. While they are limited in scope compared to regular functions, they offer several benefits:lambda arguments: expression\nStructure: lambda arguments: expression\nConciseness: Lambda functions are compact and allow you to define simple operations in a single line of code, making them particularly useful for short, one-off functions.\nReadability: When used appropriately, lambda functions can improve code readability by encapsulating a specific operation right where it’s needed, reducing the need for named functions or temporary variables.\nFunctional Programming: Lambda functions are a key component of functional programming in Python. They can be used with higher-order functions like map(), filter(), and reduce() to perform operations on collections of data.\n\n# sort a list of tuples by the second element:\ndata = [(1, 5), (3, 2), (2, 8)]\nsorted_data = sorted(data, key=lambda x: x[1])  # extracts the second element (index 1) of each tuple in the data list\nprint(sorted_data)\n\n[(3, 2), (1, 5), (2, 8)]\n\n\n\n# filter even numbers from a list\nnumbers = [1, 2, 3, 4, 5, 6]\neven_numbers = list(filter(lambda x: x % 2 == 0, numbers))  # filtering function, iterables\nprint(even_numbers)\n\n[2, 4, 6]\n\n\n\n# Mapping a Function to a List\n\nvalues = [1, 2, 3, 4, 5]\nsquared_values = list(map(lambda x: x**2, values))\nprint(squared_values)\n\n[1, 4, 9, 16, 25]\n\n\n\ndef short_function(x):\n  return x * 2\nprint(short_function(100))\n\nequiv_amon = lambda x: x * 2  # assign a function to variable\nprint(type(equiv_amon))\nprint(equiv_amon(100))  # produces the same result\nprint(\"-\"*55)\n\n# use a lambda function for the second argument\ndef apply_to_list(some_list, f):\n  \"\"\"\n  Apply the given function to the given list\n  \"\"\"\n  return [f(x) for x in some_list]\nints = [4, 0, 1, 5, 6]\n\nret = apply_to_list(ints, lambda x: x*2)\nprint(ret)\n\n# sort the list of strings based on the number of unique charaters for each string.\nstrings = [\"foo\", \"card\", \"bar\", \"aaaa\", \"abab\"]\nstrings.sort(key=lambda x: len(set(x))) # sort by number of unique characters per string element\nprint(strings)\n\n200\n&lt;class 'function'&gt;\n200\n-------------------------------------------------------\n[8, 0, 2, 10, 12]\n['aaaa', 'foo', 'abab', 'bar', 'card']\n\n\n\n\n\nGenerators are a powerful and memory-efficient feature in Python for working with sequences of data. They allow you to create iterators on the fly, enabling the processing of large data sets or infinite sequences without storing them in memory. Generators are defined using functions but use the yield keyword to produce values one at a time. Many objects in Python support iteration, such as over objects in a list or lines in a file. This is accomplished by means of the iterator protocol, a generic way to make objects iterable.\nCreating a Generator:\n\nGenerators are defined using functions with the yield keyword.\nA function with yield becomes a generator function.\n\n\n# create a simple generator function\ndef count_up_to(n):\n  i = 1\n  while i &lt;= n:\n    yield i  # yield value and pause execution\n    i += 1\n\nprint(count_up_to(7))\n\nfor num in count_up_to(7):  # iterate generator with for\n  print(num)\n\n&lt;generator object count_up_to at 0x000001BD9F67FAC0&gt;\n1\n2\n3\n4\n5\n6\n7\n\n\nGenerator Functions vs. Regular Functions:\n\nGenerator functions use yield to produce values and pause execution.\nRegular functions use return to provide a single result and terminate.\n\nIterating Over a Generator:\n\nYou can iterate over a generator using a for loop, just like any other iterable.\nThe generator produces values one at a time as you iterate.\n\nInfinite Sequences:\n\nGenerators can be used to create infinite sequences without consuming infinite memory.\nFor example, a generator can produce an infinite stream of numbers.\n\n\n# create a generator of infinite sequences\n\ndef infinite_evens():\n  num = 0\n  while True:\n    yield num\n    num +=2\n\n# Using next() with a generator    \ninfinite_evens_generator = infinite_evens()\nprint(next(infinite_evens_generator))  # the first element yielded by generator\nprint(next(infinite_evens_generator))\nprint(next(infinite_evens_generator))\nprint(\"-\"*55)\n\n# Using for with condition with a generator\nfor num in infinite_evens_generator:\n  if num &gt; 10:\n    break\n  print(\"Gen yielded: \", num)\nprint(\"-\"*55)\n  \n# Using next() with a stopping condition\ntry:\n  seq_list = []\n  while True:\n    num = next(infinite_evens_generator)\n    if num &gt; 100:\n      break\n    seq_list.append(num)\nexcept StropIteration:\n  pass\n\nprint(\"Sequence from Gen: \", seq_list)\nprint(\"-\"*55)\n\n0\n2\n4\n-------------------------------------------------------\nGen yielded:  6\nGen yielded:  8\nGen yielded:  10\n-------------------------------------------------------\nSequence from Gen:  [14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48, 50, 52, 54, 56, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 98, 100]\n-------------------------------------------------------\n\n\n\n# Both produces the same results\n\nsome_dict = {\"a\": 1, \"b\": 2, \"c\": 3}\nfor key in some_dict:\n  print(key)\n\ndict_iterator = iter(some_dict)  # get iterator for the given iterable object\nprint(dict_iterator)\nfor item in dict_iterator:\n  print(item)\n\na\nb\nc\n&lt;dict_keyiterator object at 0x000001BD9F6796C0&gt;\na\nb\nc\n\n\n\n# working with an iterator\n \nsome_dict = {\"a\": 1, \"b\": 2, \"c\": 3}\ndict_iterator = iter(some_dict)\nprint(dict_iterator)\nprint(type(dict_iterator))\nprint(\"List created from an iterator: \", list(dict_iterator))\nprint(\"-----------------------------------------------------\")\n\n# create a generator producing squares from 1 to (n**2)\ndef squares(n=10):\n  print(f\"Generator producing squares from 1 to {n**2}\")\n  for i in range(1, n+1):\n    yield i**2\n  \ngen = squares()\nprint(gen)  # when called, generator itself does not execute any code\n\nfor x in gen: # actual code execution through iteration, One at a time, Not all at once\n  print(x, end=\" \")\n\n&lt;dict_keyiterator object at 0x000001BD9F67A9D0&gt;\n&lt;class 'dict_keyiterator'&gt;\nList created from an iterator:  ['a', 'b', 'c']\n-----------------------------------------------------\n&lt;generator object squares at 0x000001BDA2C6FAE0&gt;\nGenerator producing squares from 1 to 100\n1 4 9 16 25 36 49 64 81 100 \n\n\nGenerator express: Parentheses instead of brackets in comprehensions - list, set, dictionary, instead of list comprehension style.\n\n# generator expression, one-liner, less verbose than generator function definition\ngen = (x**2 for x in range(100))\nprint(gen)\n\n# generator expression as function argument\nprint(sum(x**2 for x in range(100))) # argument for sum() function\nprint( dict((i, i ** 2) for i in range(5)) )\n\n&lt;generator object &lt;genexpr&gt; at 0x000001BD9F67F2A0&gt;\n328350\n{0: 0, 1: 1, 2: 4, 3: 9, 4: 16}\n\n\nitertools module (standard library), collection of generators for common data algorithms.\nitertools.groupby(iterable, key=None)\nThis is a function from the itertools module in Python. It’s used for grouping elements from an iterable into consecutive keys that share a common characteristic, as determined by a key function. The elements in the iterable are expected to be sorted based on the same key function for groupby() to work effectively.\niterable: This is the iterable (e.g., a list, tuple, or iterator) containing the elements you want to group.\nkey: This is an optional argument that specifies a function to extract a key from each element in the iterable. The elements in the iterable are grouped by the values returned by this key function.\nThe function returns an iterator that produces pairs of a key and an iterator over the elements in the group.\n\nimport itertools\n\nwords = [\"apple\", \"banana\", \"bat\", \"cat\", \"dog\", \"elephant\"]\n\n# Sort the words by their first letter\nsorted_words = sorted(words, key=lambda x: x[0])\nprint(sorted_words)\n\n# Use groupby to group words by their first letter (consecutive words with same first letter)\ngroups = itertools.groupby(sorted_words, key=lambda x: x[0])\nprint(groups)\n\n# iterate through the groups and print each group, very useful dealing with sorted data\nfor key, group in groups:\n  print(f\"Words starting with '{key}': {list(group)}\") #list() required to convert generator\n\n['apple', 'banana', 'bat', 'cat', 'dog', 'elephant']\n&lt;itertools.groupby object at 0x000001BDA2CE5DA0&gt;\nWords starting with 'a': ['apple']\nWords starting with 'b': ['banana', 'bat']\nWords starting with 'c': ['cat']\nWords starting with 'd': ['dog']\nWords starting with 'e': ['elephant']\n\n\nitertools.chain(*iterables):\nGenerates a sequence by chaining iterators together. Once elements from the first iterator are exhausted, elements form the next iterator are returned, and so on.\n\n# chain multiple iterators for continuous iteration\nfrom itertools import chain\n\n# Three lists\nlist1 = [1, 2, 3]\nlist2 = ['a', 'b', 'c']\nlist3 = [10, 20, 30]\n\n# chain them into a single iterable\ncombined = chain(list1, list2, list3)\nprint(combined, type(combined))\n\n# continuous iteration\nfor item in combined:\n  print(item, end=\" \")\n\n&lt;itertools.chain object at 0x000001BD9F676F20&gt; &lt;class 'itertools.chain'&gt;\n1 2 3 a b c 10 20 30 \n\n\nitertools.combinations(iterable, k):\nIt generates all possible combinations of ‘k’ number of elements from an iterable. Each combination is a tuple, and the function returns an iterator. It is very useful when exploring various subsets or combinations of elements from a collection. It generate only unique combination regardless of order of the elements.\n\nfrom itertools import combinations\n\n# generate all possible combinations of 2 elements from a given list\n\nelements = [1, 2, 3, 4]\ncombos = combinations(elements, 2)\n\n# iterate the generator\nfor combo in combos:\n  print(combo)\n  # or do something else, more...\n\n(1, 2)\n(1, 3)\n(1, 4)\n(2, 3)\n(2, 4)\n(3, 4)\n\n\nitertools.permutations(iterable, k):\nIt generates all possible combinations of ‘k’ number of elements from an iterable. The order of elements in a permuation matters, so different orders are considered distinct. It cna produce more output than ‘combinations()’ when ‘k’ is less than the lenght of the iterable since it considers all possible arrangements. The result is an iterator of tuples, each representing a unique permutation of the elements.\n\nfrom itertools import permutations\n\nelements = [1, 2, 3, 4]\nperms = permutations(elements, 2)\nfor perm in perms:\n  print(perm)\n\n(1, 2)\n(1, 3)\n(1, 4)\n(2, 1)\n(2, 3)\n(2, 4)\n(3, 1)\n(3, 2)\n(3, 4)\n(4, 1)\n(4, 2)\n(4, 3)\n\n\nitertools.product(*iterables, repeat=1):\nThe function is used to generate the Cartesian product of multiple input iterables . The Cartesian product is a set of all possible combinations of elements from the input iterables, where each combination consists of one element from each input iterable.\n\n# Cartesian product of iterables\nfrom itertools import product\n\niterable1 = [1, 2]\niterable2 = ['a','b']\n\n# Generate the Cartesian product of the two iterables\nresult = product(iterable1, iterable2)\n\n# Iterate through the product and print the combinations\nfor combo in result:\n  print(combo)\nprint(\"------------------------\")\n\n# set number of times to rpeat the each input iterable\nresult = product(iterable1, iterable2, repeat=2) # repeating 2 times\nfor combo in result:\n  print(combo)\n\n(1, 'a')\n(1, 'b')\n(2, 'a')\n(2, 'b')\n------------------------\n(1, 'a', 1, 'a')\n(1, 'a', 1, 'b')\n(1, 'a', 2, 'a')\n(1, 'a', 2, 'b')\n(1, 'b', 1, 'a')\n(1, 'b', 1, 'b')\n(1, 'b', 2, 'a')\n(1, 'b', 2, 'b')\n(2, 'a', 1, 'a')\n(2, 'a', 1, 'b')\n(2, 'a', 2, 'a')\n(2, 'a', 2, 'b')\n(2, 'b', 1, 'a')\n(2, 'b', 1, 'b')\n(2, 'b', 2, 'a')\n(2, 'b', 2, 'b')\n\n\n\n\n\nThis is an important part of building robust programs. In data applications, many functions work only on certain kinds of input.\n\n# function throwing error\nprint(float(\"1.2345\"))  # convert proper string input to float value\n# print(float(\"1,2345\"))  # throwing error with improper input\n\n1.2345\n\n\n\n# Failing gracefully\ndef attempt_float(x):\n  try:\n    return float(x)\n  except:\n    return x  # return input value gracefully(?) when 'try' failed, exception raised\n\nprint(attempt_float(\"1,2345\"))\n\n1,2345\n\n\n\n# suppressing a specific error\ndef attempt_float(x):\n  try:\n    return float(x)\n  except ValueError:\n    return x\n\n# attempt_float((1, 2))  # this caused an error other than ValueError\n\n\n# suppressing multiple errors\ndef attempt_float(x):\n  try:\n    return float(x)\n  except (TypeError, ValueError):  # now added TypeError to supress it too.\n    return x\n\nattempt_float((1, 2)) # failed, and gracefully return the input value as defined in try-execept, errors suppressed.\n\n(1, 2)\n\n\n\n# 'finally' lets you execute some codes regardless the success of try-block.\n\nf = open(\"./try-finally.txt\", mode=\"w\")\ntry:\n  write_to_file(f)\nexcept:\n  print(\"Failed\")\nelse:\n  print(\"Succeeded\")\nfinally:\n  f.close()\n\nFailed\n\n\n\n\n\n\nWorking with files and the operating system is a fundamental aspect of programming in Python. Python provides powerful tools and libraries to manipulate files, read and write data, and interact with the underlying file system\n\n\n\n# writing to a text file\nwith open('file_test.txt', 'w') as file:\n  file.write(\"Hello, world!\")\n  file.write(\"Brown fox jumped over the fence.\")\n  file.write(\"Handling file with text in Python is very straight forward.\")\n\n\n# opening and reading a text file\nwith open('file_test.txt', 'r') as file:\n  content = file.read()\nprint(content)\n\nHello, world!Brown fox jumped over the fence.Handling file with text in Python is very straight forward.\n\n\n\n# appending to a text file\nwith open('file_test.txt', 'a') as file:\n  file.write('\\nAppended line 1')\n  file.write('\\nAppended line 2')\n  file.write('\\nAppended line 3')\n  file.write('\\nAppended line 4')\n  \nwith open('file_test.txt', 'r') as file:\n  content = file.read()\nprint(content)\n\nHello, world!Brown fox jumped over the fence.Handling file with text in Python is very straight forward.\nAppended line 1\nAppended line 2\nAppended line 3\nAppended line 4\n\n\n\n\n\n\n# Listing files in a directory\n\nimport os\n\nfiles = os.listdir('../') # files in upper directory\nprint(files)\n\n['.git', '.gitignore', '.nojekyll', '.quarto', '.RData', '.Rhistory', '.Rproj.user', 'about.qmd', 'albert-joonyoung-park.github.io.Rproj', 'blog.qmd', 'data', 'docs', 'images', 'index.qmd', 'posts', 'profile.jpg', 'projects', 'projects.qmd', 'reports', 'styles.css', '_freeze', '_quarto.yml']\n\n\n\nimport os\n\npath = \"examples/segismundo.txt\"\n\n# open file with given encoding, \"r\" mode by default\nf = open(path, encoding=\"utf-8\") # default Unicode encoding is platform-specific\n\n# iterate the file object and print line with EOL marker intact\nfor line in f:\n  print(line)\n\n# close the file\nf.close()\n\nSueña el rico en su riqueza,\n\nque más cuidados le ofrece;\n\n\n\nsueña el pobre que padece\n\nsu miseria y su pobreza;\n\n\n\nsueña el que a medrar empieza,\n\nsueña el que afana y pretende,\n\nsueña el que agravia y ofende,\n\n\n\ny en el mundo, en conclusión,\n\ntodos sueñan lo que son,\n\naunque ninguno lo entiende.\n\n\n\n\n\n\nimport os\n\npath = \"examples/segismundo.txt\"\n\n# EOL-free list of lines in a file\nwith open(path, encoding=\"utf-8\") as f:\n  lines = [x.rstrip() for x in f]\nprint(lines)\n\n['Sueña el rico en su riqueza,', 'que más cuidados le ofrece;', '', 'sueña el pobre que padece', 'su miseria y su pobreza;', '', 'sueña el que a medrar empieza,', 'sueña el que afana y pretende,', 'sueña el que agravia y ofende,', '', 'y en el mundo, en conclusión,', 'todos sueñan lo que son,', 'aunque ninguno lo entiende.', '']\n\n\n\n# read, seek and tell\n\n# read moves the file object position by the number of bytes read after reading character or bytes\nf1 = open(path)\nprint(f1.read(10)) # read 10 characters with the encoding used for this file operation\n\nf2 = open(path, mode=\"rb\")  # open with binary mode\nprint(f2.read(10)) # read 10 bytes\n\n# tell current file object position\nprint(f1.tell())\nprint(f2.tell())\n\nimport sys\nprint(sys.getdefaultencoding())  # this is the default encoding of the platform in use.\n\n# seek changes the file position to the indicated byte in the file\n\nprint(f1.seek(3))\nprint(f1.read(1))\nprint(f1.tell())\n\nprint(f2.seek(3))\nprint(f2.read(1))\nprint(f2.tell())\n\n# close the files\nf1.close()\nf2.close()\n\nSueÃ±a el \nb'Sue\\xc3\\xb1a el '\n10\n10\nutf-8\n3\nÃ\n4\n3\nb'\\xc3'\n4\n\n\n\nimport os\n\nprint(os.getcwd())\n\npath = \"examples/segismundo.txt\"\nprint(path)\n\n# create a new file from path, remove blank lines\n\nwith open(\"examples/tmp.txt\", mode=\"w\") as handle:\n  handle.writelines(x for x in open(path) if len(x) &gt; 1)\n\nC:\\Users\\Joon\\git\\albert-joonyoung-park.github.io\\posts\nexamples/segismundo.txt\n\n\n\n# Open the new file and read\nwith open(\"examples/tmp.txt\") as f:\n  lines = f.readlines()\n\nlines\n\n['SueÃ±a el rico en su riqueza,\\n',\n 'que mÃ¡s cuidados le ofrece;\\n',\n 'sueÃ±a el pobre que padece\\n',\n 'su miseria y su pobreza;\\n',\n 'sueÃ±a el que a medrar empieza,\\n',\n 'sueÃ±a el que afana y pretende,\\n',\n 'sueÃ±a el que agravia y ofende,\\n',\n 'y en el mundo, en conclusiÃ³n,\\n',\n 'todos sueÃ±an lo que son,\\n',\n 'aunque ninguno lo entiende.\\n']\n\n\n\n\n\n\npath = \"examples/segismundo.txt\"\n\n# default file behavior - text mode\nwith open(path) as f:\n  chars = f.read(10) # read eough bytes to decode 10 characters, if utf-8 in use by the platform\n\nprint(chars)\nprint(len(chars))\n\n# binary mode\nwith open(path, mode=\"rb\") as f:  # append b to the mode\n  data = f.read(10) # read exact 10 bytes\nprint(data)\n\n# try and decode the bytes to a string object\nprint(data.decode(\"utf-8\")) # works only if each of the encoded Unicode characters is fully formed\n# print(data[:4].decode(\"utf-8\")) # error - not fully formed\nprint(data[:5].decode(\"utf-8\")) # worked, fully formed by the given range\n\nSueÃ±a el \n10\nb'Sue\\xc3\\xb1a el '\nSueña el \nSueñ\n\n\n\n# Use encoding option with open() to covert Unicode encoding to another\n\n# Create a new file converting encoding of segismundo.txt to iso-8859-1\n\npath = \"examples/segismundo.txt\"\nsink_path = \"examples/sink.txt\"\nwith open(path) as source:\n  with open(sink_path, \"w\", encoding=\"iso-8859-1\") as target:\n    target.write(source.read())\n\nwith open(sink_path, encoding=\"iso-8859-1\") as f:\n  print(f.read(10))\n\nSueÃ±a el"
  },
  {
    "objectID": "posts/p4da3d-data-types.html#built-in-data-structures-functions-and-files",
    "href": "posts/p4da3d-data-types.html#built-in-data-structures-functions-and-files",
    "title": "3. Built-In Data Structures, Functions, and Files",
    "section": "",
    "text": "Python Tuples: Immutable, ordered collections that allow you to store a sequence of elements. Tuples are defined using parentheses and can hold a mix of data types. They offer efficient data storage, are iterable, and can be used as keys in dictionaries. In this blog, we’ll explore the versatility of Python tuples and how to leverage them for various data analysis tasks.\n\n# create some tuples\ntup = (4, 5, 6)\ntup2 = 7, 8, 9\ntup\ntup2\ntup, tup2     # tuple of tuples\ntype(tup2)\n\n# convert any sequence or iterator to tuple\ntuple(['a', 'b', 'c'])\ntuple('Some String')\n\n('S', 'o', 'm', 'e', ' ', 'S', 't', 'r', 'i', 'n', 'g')"
  },
  {
    "objectID": "posts/p4da3d-data-types.html#chapter-3-built-in-data-structures-functions-and-files",
    "href": "posts/p4da3d-data-types.html#chapter-3-built-in-data-structures-functions-and-files",
    "title": "[3] Built-In Data Structures, Functions, and Files",
    "section": "",
    "text": "Python Tuples: Immutable, ordered collections that allow you to store a sequence of elements. Tuples are defined using parentheses and can hold a mix of data types. They offer efficient data storage, are iterable, and can be used as keys in dictionaries. In this blog, we’ll explore the versatility of Python tuples and how to leverage them for various data analysis tasks.\n\n# create some tuples\ntup = (4, 5, 6)\ntup2 = 7, 8, 9\nprint(tup)\nprint(tup2)\nt = (tup, tup2)    # tuple of tuples\nprint(t)\ntype(t)\n\n# convert any sequence or iterator to tuple\nprint(tuple(['a', 'b', 'c']))\nprint(tuple('Some String'))\n\n# access elements\nnested_tup = ((4,5,6), (7,8))\nprint(nested_tup)\n\n(4, 5, 6)\n(7, 8, 9)\n((4, 5, 6), (7, 8, 9))\n('a', 'b', 'c')\n('S', 'o', 'm', 'e', ' ', 'S', 't', 'r', 'i', 'n', 'g')\n((4, 5, 6), (7, 8))"
  },
  {
    "objectID": "posts/p4da3d-data-types.html#data-structures-and-sequences",
    "href": "posts/p4da3d-data-types.html#data-structures-and-sequences",
    "title": "[3] Built-In Data Structures, Functions, and Files",
    "section": "Data Structures and Sequences",
    "text": "Data Structures and Sequences\n\nTuple\nPython Tuples: Immutable, ordered collections that allow you to store a sequence of elements. Tuples are defined using parentheses and can hold a mix of data types. They offer efficient data storage, are iterable, and can be used as keys in dictionaries. In this blog, we’ll explore the versatility of Python tuples and how to leverage them for various data analysis tasks.\n\n# create some tuples\ntup = (4, 5, 6)\ntup2 = 7, 8, 9\nprint(tup)\nprint(tup2)\nt = (tup, tup2)    # tuple of tuples\nprint(t)\ntype(t)\n\n# convert any sequence or iterator to tuple\nprint(tuple(['a', 'b', 'c']))\nprint(tuple('Some String'))\n\n# access elements\nnested_tup = ((4,5,6), (7,8))\nprint(nested_tup[1])\n\n(4, 5, 6)\n(7, 8, 9)\n((4, 5, 6), (7, 8, 9))\n('a', 'b', 'c')\n('S', 'o', 'm', 'e', ' ', 'S', 't', 'r', 'i', 'n', 'g')\n(7, 8)\n\n\nTuple itself is immutable; however, if an object inside a tuple is mutable, you can modify it in place.\n\ntup = tuple(['The bown ','fox ', 'jumped over the ',['fence.']])\nprint(tup)\n# tup[1] = 'wolf'           # error\ntup[3][0] = 'window '     # ok\nprint(tup)\ntup[3].append('fence')    # ok\nprint(tup)\n\n('The bown ', 'fox ', 'jumped over the ', ['fence.'])\n('The bown ', 'fox ', 'jumped over the ', ['window '])\n('The bown ', 'fox ', 'jumped over the ', ['window ', 'fence'])\n\n\nConcatenation, Variable swap, Unpacking\n\n# concatenation using +\ntup = (4, None, 'foo') + (6, 0) + ('bar',)\nprint(tup)\n\n# Swap\na, b = 1, 2\nprint(a, b)\nb, a = a, b\nprint(a, b)\n\n# Unpacking by iterating over sequences of tuples, lists\nseq = [('a1', 'a2', 'a3'),('b4', 'b5', 'b6'), ('c7', 'c8', 'c9')]\nprint(seq, type(seq))\nfor a, b, c in seq:\n  print(f'a={a}, b={b}, c={c}')\n  \n# unpacking using assignment, not concerning some trailing values\nvalues = 1, 2, 3, 4, 5, 6, 7\na, b, *_ = values     # *rest works the same as *_\nprint (a, b, *_)\n\n# method .count()\na = (1, 2, 2, 2, 3, 4, 2)\nprint(a.count(2))     # number of occurences\n\n(4, None, 'foo', 6, 0, 'bar')\n1 2\n2 1\n[('a1', 'a2', 'a3'), ('b4', 'b5', 'b6'), ('c7', 'c8', 'c9')] &lt;class 'list'&gt;\na=a1, b=a2, c=a3\na=b4, b=b5, c=b6\na=c7, b=c8, c=c9\n1 2 3 4 5 6 7\n4\n\n\n\n\nList\nPython Lists: Ordered, mutable collections that allow you to store and manipulate sequences of items. Lists are versatile and can hold various data types. They support methods for adding, removing, and modifying elements, making them a fundamental data structure for data analysis and manipulation in Python.\n\n# create, convert lists\na_list = [2, 3, 7, None]\ntup = (\"foo\", \"bar\", \"baz\")\nb_list = list(tup)\nprint(b_list, type(b_list))\n\n# Access, modify list element\nb_list[1] = \"peekaboo\"\nprint(b_list)\n\n# Materialize an iterator / generator\ngen = range(20) # generator, not materialized yet.\nprint(gen) \nlist(gen) # materialize the generator to list\n\n# Work with the elements\nb_list.append(\"dwarf\")     # add to the end of list\nb_list.append(\"foo\")\nprint(b_list)\nb_list.insert(1, \"RED\")     # insert at specific location, consider using collections.deque for efficiency\nprint(b_list)\nb_list.remove(\"foo\")        # remove the first occurence only\nprint(b_list)\n\n# Check if element in the list\nprint(\"dwarf\" in b_list)\nprint(\"dwarf\" not in b_list)\n\n['foo', 'bar', 'baz'] &lt;class 'list'&gt;\n['foo', 'peekaboo', 'baz']\nrange(0, 20)\n['foo', 'peekaboo', 'baz', 'dwarf', 'foo']\n['foo', 'RED', 'peekaboo', 'baz', 'dwarf', 'foo']\n['RED', 'peekaboo', 'baz', 'dwarf', 'foo']\nTrue\nFalse\n\n\n\n# Concatenate and combine lists\nnew_list = [4, None, \"foo\"] + [7, 8, (2, 3)]\nprint(new_list)\nprint(b_list)\nnew_list.extend(b_list)\nprint(new_list)\n\n# Sorting in place\na = [\"saw\", \"small\", \"He\", \"foxes\", \"six\"]\na.sort() # default\nprint(a)\na.sort(key=len) # sort by key with given function, by the length of each element\nprint(a)\n\n# Sorted copy\na = [\"saw\", \"small\", \"He\", \"foxes\", \"six\"]\nsorted_copy = sorted(a)\nprint(sorted_copy)\n\n[4, None, 'foo', 7, 8, (2, 3)]\n['RED', 'peekaboo', 'baz', 'dwarf', 'foo']\n[4, None, 'foo', 7, 8, (2, 3), 'RED', 'peekaboo', 'baz', 'dwarf', 'foo']\n['He', 'foxes', 'saw', 'six', 'small']\n['He', 'saw', 'six', 'foxes', 'small']\n['He', 'foxes', 'saw', 'six', 'small']\n\n\n\n# Slices\n\nseq = [7, 2, 3, 7, 5, 6, 0, 1]\nprint(seq)\nprint(seq[1:5])   # index:1 - index: 4\nprint(seq[:5])    # index:beginning - index: 4\nprint(seq[5:])    # index:5 - index:last\nprint(seq[-4:])   # Indexing from the last, index:-4 to the end\nprint(seq[-6:-2]) # Indexing from the last, index: -6 to index: -2\n\nprint(\"-\"*30)\n\n# Stepping the list\nprint(seq[::2])     # Extract index 0, 2, 4, 6 ....\nprint(seq[::3])     # Extract index 0, 3, 6 ....\nprint(seq[::-2])    # Extract index -1, -3, -5 .....\nprint(seq[::-1])    # Extract index -1, -2, -3, -4 ... effectively reverse the list or tuple\n\n\nprint(\"-\"*30)\n\n# Slices replacement\nseq[3:5] = ['A','B']\nprint(seq)\n\n[7, 2, 3, 7, 5, 6, 0, 1]\n[2, 3, 7, 5]\n[7, 2, 3, 7, 5]\n[6, 0, 1]\n[5, 6, 0, 1]\n[3, 7, 5, 6]\n------------------------------\n[7, 3, 5, 0]\n[7, 7, 0]\n[1, 6, 7, 2]\n[1, 0, 6, 5, 7, 3, 2, 7]\n------------------------------\n[7, 2, 3, 'A', 'B', 6, 0, 1]\n\n\n\n\nDictionary\nPython Dictionaries: Versatile and dynamic data structures that store key-value pairs, allowing for efficient data retrieval and manipulation. Dictionaries are unordered collections that provide a way to map unique keys to associated values, making them invaluable for tasks like data storage, lookup tables, and configuration settings\n\n# Create a Dictionary (aka, hash-map, associative arrays)\n\nempty_dict = {} \nprint(empty_dict)\nd1 = {\"a\": \"some value\", \"b\": [1, 2, 3, 4]}  # key-value pair\nprint(d1)\n\n# Access, insert and set\nd1[7] = \"an integer\"      # 7:\"an integer\" pair\nprint(d1)\nprint(d1[\"b\"])            # lookup with key\n#print(d1[\"address\"])     # KeyError\nprint(\"address\" in d1)    # key exists?\n\nprint(\"-\"*30)\n\n# Delete values\ndel d1[7]              # delete with key\n#del d1[\"country\"]     # KeyError\nprint(d1)\nret = d1.pop(\"b\")      # delete with key and return the value\nprint(ret)\nprint(d1)\n\nprint(\"-\"*30)\n\n# Iteration using keys() values() items()\nd1 = {'a': 'some value', 'b': [1, 2, 3, 4], 7: 'an integer'}\nprint(type(d1.keys()))     # &lt;class 'dict_keys'&gt;\nprint(type(d1.values()))   # &lt;class 'dict_values'&gt;\n\nd1_keys = list(d1.keys())   \nd1_values = list(d1.values())\nd1_items = list(d1.items())  # Gives a list of tuples in (key, value)\nprint(d1_keys)\nprint(d1_values)\nprint(d1_items)  \n\n# iteration\nfor key, value in d1.items():\n  print(f'Key: \\\"{key}\\\" has value of \\\"{value}\\\".')\n\n{}\n{'a': 'some value', 'b': [1, 2, 3, 4]}\n{'a': 'some value', 'b': [1, 2, 3, 4], 7: 'an integer'}\n[1, 2, 3, 4]\nFalse\n------------------------------\n{'a': 'some value', 'b': [1, 2, 3, 4]}\n[1, 2, 3, 4]\n{'a': 'some value'}\n------------------------------\n&lt;class 'dict_keys'&gt;\n&lt;class 'dict_values'&gt;\n['a', 'b', 7]\n['some value', [1, 2, 3, 4], 'an integer']\n[('a', 'some value'), ('b', [1, 2, 3, 4]), (7, 'an integer')]\nKey: \"a\" has value of \"some value\".\nKey: \"b\" has value of \"[1, 2, 3, 4]\".\nKey: \"7\" has value of \"an integer\".\n\n\n\n# Update dictionary with a dictionary of new or changes of key-value pairs\nd1 = {'a': 'some value', 'b': [1, 2, 3, 4], 7: 'an integer'}\nprint(d1)\nd1.update({\"b\": \"foo\", \"c\": 12})\nprint(d1)\n\n{'a': 'some value', 'b': [1, 2, 3, 4], 7: 'an integer'}\n{'a': 'some value', 'b': 'foo', 7: 'an integer', 'c': 12}\n\n\n\n# Create a dictionary from two sequences\n\nlist_country = [\"USA\", \"Canada\", \"England\", \"France\"]\nlist_city = [\"Washigton\", \"Ottawa\", \"London\", \"Paris\"]\nprint(list_country)\nprint(list_city)\n\n# Using for loop - zip and iterate\nprint(zip(list_country, list_city))\n\nmapping = {}\nfor key, value in zip(list_country, list_city):\n  mapping[key] = value\nprint(mapping, type(mapping))\n\n# Using dict() method\ncountry_city_tuples = zip(list_country, list_city)\nprint(country_city_tuples, type(country_city_tuples))\nmapping = dict(country_city_tuples)\nprint(mapping, type(mapping))\n\n['USA', 'Canada', 'England', 'France']\n['Washigton', 'Ottawa', 'London', 'Paris']\n&lt;zip object at 0x000002993D9B1640&gt;\n{'USA': 'Washigton', 'Canada': 'Ottawa', 'England': 'London', 'France': 'Paris'} &lt;class 'dict'&gt;\n&lt;zip object at 0x000002993D9B2A40&gt; &lt;class 'zip'&gt;\n{'USA': 'Washigton', 'Canada': 'Ottawa', 'England': 'London', 'France': 'Paris'} &lt;class 'dict'&gt;\n\n\n\n# Build a dictionary WUTHOUT using setdefault()\nwords = [\"apple\", \"bat\", \"bar\", \"atom\", \"book\"]\nprint(words, type(words))\n\nby_letter = {}\n\nfor word in words:\n  letter = word[0] # Using the first letter of each word as key\n  if letter not in by_letter:\n    by_letter[letter] = [word]\n  else:\n    by_letter[letter].append(word)\n\nprint(by_letter)\n\nprint(\"-\"*55)\n\n# Simplified version using setdefault()\n\nwords = [\"apple\", \"bat\", \"bar\", \"atom\", \"book\"]\nby_letter = {}\nfor word in words:\n  letter = word[0] # Using the first letter of each word as key\n  by_letter.setdefault(letter, []).append(word) # If the letter (the first letter of the current word) is already a key in the dictionary, it returns the corresponding value (which is a list) for that key. If the key doesn't exist, it initializes an empty list. The append() method is then used to add the current word to the list associated with the letter key.\nprint(by_letter)\n\nprint(\"-\"*55)\n\n# Using defaultdict from collections module\nfrom collections import defaultdict\n\nwords = [\"apple\", \"bat\", \"bar\", \"atom\", \"book\"]\nby_letter = defaultdict(list) # if you access a key that doesn't exist, it will automatically create that key with an empty list as the associated value. This is particularly useful when you want to avoid KeyError exceptions when working with dictionaries.\nprint(by_letter, type(by_letter))\n\nfor word in words:\n  by_letter[word[0]].append(word)\n\nprint(by_letter)\n\n['apple', 'bat', 'bar', 'atom', 'book'] &lt;class 'list'&gt;\n{'a': ['apple', 'atom'], 'b': ['bat', 'bar', 'book']}\n-------------------------------------------------------\n{'a': ['apple', 'atom'], 'b': ['bat', 'bar', 'book']}\n-------------------------------------------------------\ndefaultdict(&lt;class 'list'&gt;, {}) &lt;class 'collections.defaultdict'&gt;\ndefaultdict(&lt;class 'list'&gt;, {'a': ['apple', 'atom'], 'b': ['bat', 'bar', 'book']})\n\n\nUnderstanding Dictionary Key Types\nIn Python, dictionaries are versatile data structures used for mapping keys to corresponding values. While dictionaries allow flexibility in storing values of any Python data type as their values, there are specific requirements and considerations when it comes to selecting suitable key types. This aspect of dictionary design is crucial to ensure efficient and reliable key-value pair lookups and operations.\nKey Characteristics of Dictionary Keys\n\nImmutability Requirement:\nThe primary requirement for dictionary keys is that they should generally be immutable objects. Immutability refers to the property of an object that prevents its state from being modified after it is created.\nExamples of Immutable Key Types:\n\nScalar Types: Examples of immutable scalar types suitable as dictionary keys include integers (int), floating-point numbers (float), and strings (str). These types are inherently immutable, which means once you create a key with a specific value, that key-value pair remains consistent.\nTuples as Composite Keys: Tuples can also serve as dictionary keys, but there’s an important condition: all the objects within the tuple must also be immutable. This ensures the stability of the key, as the tuple itself remains unchanged.\n\n\nThe Significance of Hashability\nThe technical term that ties these requirements together is “hashability.” Hashability refers to an object’s ability to be hashed, which involves converting the object into a fixed-size numerical value, known as a hash code. This hash code is used as an index to efficiently store and retrieve key-value pairs in a dictionary. The key feature of hashable objects is that they produce the same hash code consistently.\nThe Role of the hash() Function\nYou can determine whether an object is hashable and can be used as a dictionary key by utilizing the built-in hash() function. When you apply the hash() function to an object, it returns a hash code if the object is hashable. However, keep in mind that not all Python objects are hashable, particularly mutable objects like lists and dictionaries.\n\n# Using hash() to validate key types in dictionary\n\nhash(\"string\")           # hashable\nhash((1, 2, (2, 3)))     # hashable\n# hash((1, 2, [2, 3]))     # Not hashable due to mutable element - list of [2, 3]\n\n# When in need of list for key, convert it tp tuple, hashable\nd = {}\nd[tuple([1,2,3])] = 5\nprint(d)  # dictionary with a tuple as key\n\n{(1, 2, 3): 5}\n\n\n\n\nSet\nSets in Python: A Set is an essential data structure that represents an unordered collection of unique elements. Unlike lists or tuples, which allow duplicates, sets only store distinct values. This characteristic makes sets ideal for various tasks, such as removing duplicates from a list, checking for membership, and performing set operations like union, intersection, and difference. One of the most common real-world use cases for sets is in data deduplication, where they excel at efficiently eliminating duplicate records from datasets, ensuring data integrity and enhancing the performance of data processing tasks.\n\n# Create a set\nprint(set([2, 2, 2, 1, 3, 3]))\nprint\n\n# Union, Difference, Intersection and Symmetric Difference\na = {1, 2, 3, 4, 5}\nb = {3, 4, 5, 6, 7, 8}\nprint (\"Set a:\", a, \" Set b:\", b)\n\n# a.union(b) = a | b\nprint(\"a union b: \", a.union(b), a | b)\n# a.intersection(b) = a & b\nprint(\"a intersection b: \", a.intersection(b), a & b)\n# a.difference(b) = a - b\nprint(\"a difference b: \", a.difference(b), a - b)\n# a.symmetric_difference(b)\nprint(\"a.symmetric_difference(b): \", a.symmetric_difference(b), a ^ b)\n\n{1, 2, 3}\nSet a: {1, 2, 3, 4, 5}  Set b: {3, 4, 5, 6, 7, 8}\na union b:  {1, 2, 3, 4, 5, 6, 7, 8} {1, 2, 3, 4, 5, 6, 7, 8}\na intersection b:  {3, 4, 5} {3, 4, 5}\na difference b:  {1, 2} {1, 2}\na.symmetric_difference(b):  {1, 2, 6, 7, 8} {1, 2, 6, 7, 8}\n\n\n\n# Common set operations\na = {1, 2, 3, 4, 5}\n\n# a.add(x) - Add x to the set\na.add(\"Fox\")\nprint(a)\n# a.remove(x) - Remove x from the set\na.remove(\"Fox\")\nprint(a)\n# a.pop() - Remove an element arbitrarily, set must not be empty\nret = a.pop()\nprint(a, ret)\n\n\n\n# a.clear() - reset to empty\nprint(a.clear())  # None - empty\n\n{1, 2, 3, 4, 5, 'Fox'}\n{1, 2, 3, 4, 5}\n{2, 3, 4, 5} 1\nNone\n\n\nBuilt-in Sequence Functions\n\na_list = [7, 1, 2, 6, 0, 3, 2]\n\n# Very useful, use at every opportunities\n\n# enumerate() - no need to write code to track index\nfor index, value in enumerate(a_list):\n  print(index, \" : \", value)  \n\n# sorted() - a new srted list from the elements of any sequence\nprint(sorted(a_list))\nprint(sorted(\"horse race\"))  # string is a sequence\n\n# zip() - pairs up sequences element-wise to create a list\nseq1 = [\"foo\", \"bar\", \"baz\"]\nseq2 = [\"one\", \"two\", \"three\"]\nseq3 = [\"BROWN\", \"FOX\", \"FENCE\", \"JUMP\"]\nzipped = zip(seq1, seq2, seq3)\nprint(list(zipped))  # \"JUMP\" ignored for pariing!\n\n# zip() commonly works with enumerate() for iteration - zip and iterate\nfor index, (a, b) in enumerate(zip(seq1, seq2)):\n  print(f\"{index}: {a}, {b}\")\n\n# reversed()\nreversed(range(10)) # range_iterator object, it's a generator\nprint(list(reversed(range(10)))) # list() materializes the generator\n\n0  :  7\n1  :  1\n2  :  2\n3  :  6\n4  :  0\n5  :  3\n6  :  2\n[0, 1, 2, 2, 3, 6, 7]\n[' ', 'a', 'c', 'e', 'e', 'h', 'o', 'r', 'r', 's']\n[('foo', 'one', 'BROWN'), ('bar', 'two', 'FOX'), ('baz', 'three', 'FENCE')]\n0: foo, one\n1: bar, two\n2: baz, three\n[9, 8, 7, 6, 5, 4, 3, 2, 1, 0]\n\n\n\n\nList, Set and Dictionary Comprehensions\nComprehensions in Python offer concise, readable, and often more efficient ways to create lists, sets, and dictionaries. They reduce code verbosity, enhance readability, and promote a functional programming style, ultimately leading to cleaner and more maintainable code.\nList Comprehension:\nList comprehensions provide a concise way to create lists by applying an expression to each item in an iterable (e.g., a list, tuple, or range) and optionally filtering the items based on a condition.\n\n## [exp for value in collection if condition]\n\n# create a list of strings in uppercase only if the string has more than two characters.\nstrings = [\"a\", \"as\", \"bat\", \"car\", \"dove\", \"python\"]\nstrings_2 = [ str.upper() for str in strings if len(str) &gt; 2 ]\nprint(strings_2)\n\n# create a list of squares of even numbers from 0 to 9\neven_squares = [ x ** 2 for x in range(10) if x % 2 == 0 ]\nprint(even_squares)\n\n['BAT', 'CAR', 'DOVE', 'PYTHON']\n[0, 4, 16, 36, 64]\n\n\nSet Comprehension:\nSet comprehensions allow you to create sets in a similar manner to list comprehensions, but with the guarantee of uniqueness among elements.\n\n## set_comp = {expr for value in collection if condition}\n\n# Create a set using strings list above, containing only the lengths of strings.\nstrings = [\"a\", \"as\", \"bat\", \"car\", \"dove\", \"python\"]\nunique_lengths = { len(str) for str in strings } # uniqueness guaranted\nprint(unique_lengths)\n\n# map() - even more powerful\nstrings_map = set(map(len, strings))\nprint(strings_map)\n\n# Create a set of unique even squares from 0 to 9\neven_squares_set = {x ** 2 for x in range(10) if x % 2 == 0}\nprint(even_squares_set)\n\n{1, 2, 3, 4, 6}\n{1, 2, 3, 4, 6}\n{0, 64, 4, 36, 16}\n\n\nDictionary Comprehension:\nDictionary comprehensions enable the creation of dictionaries by defining key-value pairs based on expressions applied to items in an iterable.\n\n## {key_expression: value_expression for item in iterable if condition}\n\n# Create a dictionary, mapping even numbers to their squares from 0 to 9\neven_squares_dict = { x: x**2 for x in range(10) if x % 2 == 0 }\nprint(even_squares_dict)\n\n# Create a dictionary of lookup map of string for the location of each string in the list\nstrings = [\"a\", \"as\", \"bat\", \"car\", \"dove\", \"python\"]\nstring_lookup_dict = { str: index for index, str in enumerate(strings) }\nprint(strings)\nprint(string_lookup_dict)\n\n{0: 0, 2: 4, 4: 16, 6: 36, 8: 64}\n['a', 'as', 'bat', 'car', 'dove', 'python']\n{'a': 0, 'as': 1, 'bat': 2, 'car': 3, 'dove': 4, 'python': 5}\n\n\nNested list comprehensions\nThe order of\n\n# List of lists with some English and Spanish names - List nesting lists\nall_data = [\n  [\"John\", \"Emily\", \"Michael\", \"Mary\", \"Steven\"],\n  [\"Maria\", \"Juan\", \"Javier\", \"Natalia\", \"Pilar\"]\n]\nprint(all_data)\nprint(\"-\"*55)\n\n# Create a list of names contating two of more of 'a'\n# The non-Pythonic apporach using for loop..\nnames_of_interest = []\nfor names in all_data:\n  print(\"Processing:\", names)\n  enough_as = [ name for name in names if name.count(\"a\") &gt;=2 ]\n  print(enough_as)\n  names_of_interest.extend(enough_as)\nprint(\"Results: \", names_of_interest)\n\n# Re-writtine in one-liner using nested list comprehension\nnames_of_interest = [ name for names in all_data for name in names if name.count(\"a\") &gt;=2 ]\nprint(\"Result using Nested List Comprehension: \", names_of_interest)\n\n# Flatten a list of tuples of integers into a simple list of integers using nested list comprehension\nsome_tuples = [(1, 2, 3), (4, 5, 6), (7, 8, 9)]\nprint(some_tuples, type(some_tuples)) # list of tuples with integers\nflattened = [ int for tuple in some_tuples for int in tuple ]\nprint(\"Flattened: \", flattened, type(flattened))  # flattend list\n\n# Readability and valid forms\nflattened = []\nprint(\"Init. flattened list: \", flattened)\nprint(\"some_tuples: \", some_tuples)\nfor tup in some_tuples:\n  for x in tup:\n    flattened.append(x)\nprint(\"flattend from some_tuples: \", flattened)\n\n# list comprehenson inside list comprehension\n# Change list of tuples to a list of lists\nprint(\"Init. list of some_tuples: \", some_tuples)\nnew_list_of_lists = [[ x for x in tup ] for tup in some_tuples ]\nprint(\"List of lists from some_tuples: \", new_list_of_lists)\n\n[['John', 'Emily', 'Michael', 'Mary', 'Steven'], ['Maria', 'Juan', 'Javier', 'Natalia', 'Pilar']]\n-------------------------------------------------------\nProcessing: ['John', 'Emily', 'Michael', 'Mary', 'Steven']\n[]\nProcessing: ['Maria', 'Juan', 'Javier', 'Natalia', 'Pilar']\n['Maria', 'Natalia']\nResults:  ['Maria', 'Natalia']\nResult using Nested List Comprehension:  ['Maria', 'Natalia']\n[(1, 2, 3), (4, 5, 6), (7, 8, 9)] &lt;class 'list'&gt;\nFlattened:  [1, 2, 3, 4, 5, 6, 7, 8, 9] &lt;class 'list'&gt;\nInit. flattened list:  []\nsome_tuples:  [(1, 2, 3), (4, 5, 6), (7, 8, 9)]\nflattend from some_tuples:  [1, 2, 3, 4, 5, 6, 7, 8, 9]\nInit. list of some_tuples:  [(1, 2, 3), (4, 5, 6), (7, 8, 9)]\nList of lists from some_tuples:  [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n\n\n\n# 6 Practical use caes of nested list comprehension\n\n# 1. Matrix operations:\n# Add 1 to each element in a 2D matrix\nmatrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\nmatrix_add_1 = [[ element + 1 for element in row] for row in matrix]\nprint(\"matrix_add_1: \", matrix_add_1)\n\n# 2. Data transformation:\n# Filter rows with even some from a list of lists\ndata = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\nfiltered_data = [ row for row in data if sum(row) % 2 == 0 ]\nprint(\"filtered_data: \", filtered_data)\n\n# 3. Flattening lists of lists:\nnested_lists = [[1, 2], [3, 4], [5, 6]]\nflattened_list = [ item for sublist in nested_lists for item in sublist ]\nprint(\"flattened_list: \", flattened_list)\n\n# 4. Combining data:\n# Create all possible pairs (in tuple) from two lists - Different from element-wise pairing using zip()\nlist1 = [1, 2, 3]\nlist2 = ['a', 'b', 'c']\ncombinations = [ (x, y) for x in list1 for y in list2 ]\nprint(\"combinations: \", combinations)\n\n# 5. Conditional filtering:\n# Filter rows containing 'John' from a list of lists\ndata = [['Alice', 25], ['John', 30], ['Bob', 35]]\nfiltered_data = [ list for list in data if 'John' in list ]\nprint(\"filtered_data: \", filtered_data)\n\n# 6. Transposing data:\n# Transpose a given matrix (switching rows and columns)\nmatrix = [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]]\ntransposed_matrix = [[ (row[i], print(\"row[i]: \", row[i]), print(\"processing row: \", row)) for row in matrix ] for i in range(len(matrix[0]))]\n#print(\"transposed_matrix: \", transposed_matrix)\n#print(len(matrix[0]))\n#print(range(len(matrix[0])))\n\nmatrix_add_1:  [[2, 3, 4], [5, 6, 7], [8, 9, 10]]\nfiltered_data:  [[1, 2, 3], [7, 8, 9]]\nflattened_list:  [1, 2, 3, 4, 5, 6]\ncombinations:  [(1, 'a'), (1, 'b'), (1, 'c'), (2, 'a'), (2, 'b'), (2, 'c'), (3, 'a'), (3, 'b'), (3, 'c')]\nfiltered_data:  [['John', 30]]\nrow[i]:  1\nprocessing row:  [1, 2, 3, 4]\nrow[i]:  5\nprocessing row:  [5, 6, 7, 8]\nrow[i]:  9\nprocessing row:  [9, 10, 11, 12]\nrow[i]:  2\nprocessing row:  [1, 2, 3, 4]\nrow[i]:  6\nprocessing row:  [5, 6, 7, 8]\nrow[i]:  10\nprocessing row:  [9, 10, 11, 12]\nrow[i]:  3\nprocessing row:  [1, 2, 3, 4]\nrow[i]:  7\nprocessing row:  [5, 6, 7, 8]\nrow[i]:  11\nprocessing row:  [9, 10, 11, 12]\nrow[i]:  4\nprocessing row:  [1, 2, 3, 4]\nrow[i]:  8\nprocessing row:  [5, 6, 7, 8]\nrow[i]:  12\nprocessing row:  [9, 10, 11, 12]"
  },
  {
    "objectID": "posts/p4da3d-data-types.html#functions",
    "href": "posts/p4da3d-data-types.html#functions",
    "title": "[3] Built-In Data Structures, Functions, and Files",
    "section": "Functions",
    "text": "Functions\nFunctions in Python are a cornerstone of the language, offering powerful tools for structuring and modularizing code. Python functions come with several unique features that distinguish them from functions in other programming languages.\n\nVersatile and Expressive: Python functions support both positional and keyword arguments, enabling flexible and expressive function calls.\nMultiple Return Values: Python functions can return multiple values, simplifying the packaging and unpacking of results.\nDefault Argument Values: Python functions allow for default argument values, making function usage more straightforward by providing sensible defaults when arguments are omitted.\nLambda Functions: Python features lambda functions for concise and anonymous function definitions, particularly useful for simple operations.\nFirst-Class Functions: Python treats functions as first-class citizens, allowing them to be assigned to variables, passed as arguments, and returned from other functions. This flexibility enhances code modularity, maintainability, and readability.\nModular and Reusable: Python’s function-centric approach encourages the creation of clean, reusable, and modular code, making it a crucial topic for all Python programmers to master.\n\n\n# simple declaration and calling\ndef my_function(x,y):\n  return x + y\n\nret = my_function(1, 2)\nprint(ret)\n\n# Return None when no retorn statement is encountered\ndef funciton_without_return(x):\n  print(x)\nresult = funciton_without_return(\"hello!\")\nprint(result)\n\n# positional and keyword arguments\ndef my_function2(x, y, z=1.5):  # z as keyword argument with default value\n  if z &gt; 1:\n    return z * (x + y)\n  else:\n    return z / (x + y)\n\n# Naespace, scope and local functions\n\n\nprint(my_function2(5, 6, z=0.7))  # no need to put arg names, keword arg optional\nprint(my_function2(3.14, 7, 3.5))  # no need to specify name for kewoord arguments\nprint(my_function2(10, 20))   # keyword arg optional\n\n\na = []\ndef func():\n  for i in range(5):\n    a.append(i)\n\nfunc()\n\n3\nhello!\nNone\n0.06363636363636363\n35.49\n45.0\n\n\n\n# Assigining variable outside the function's scope\n\na = None\ndef bind_a_variable():\n  global a\n  a = []\n  \nbind_a_variable()\nprint(a)\n\n# multiple returns\ndef f():\n  a = 5\n  b = 6\n  c = 7\n  return a, b, c\n\na, b, c = f()\nprint(a, b)\n\n[]\n5 6\n\n\n\nFunctions Are Objects\nIn Python, functions are first-class objects, which means they are treated like any other object, such as integers, strings, or lists. This concept is a fundamental part of the Python language and has several implications and practical uses.\n\nFunctions can be assigned to variables:\n\n\n# Functions can be assigned to variables:\n\ndef greet(name):\n    return f\"Hello, {name}!\"\n\ngreeting = greet  # function assigned to variable \nprint(greeting(\"Alice\"))  # calling the function using the assigned variable\n\nprint(id(greet), id(greeting)) # both variable and function references the same object\n\nHello, Alice!\n2857186802272 2857186802272\n\n\n\nFunctions can be passed as arguments: This is particularly useful for functions that require a callback or custom behavior.\n\n\n# Functions can be passed as arguments\n\ndef apply(func, value):\n  return func(value)\n\ndef double(x):\n  return x * 2\n\nresult = apply(double, 5)\nprint(result)\n\n10\n\n\n\nFunctions can be returned from other functions: This enables dynamic function generation.\n\n\n# Functinos can be returned from other functions\ndef create_multiplier(factor):\n  \"\"\"\n  Returns a FUNCTION that produce the result of given factor * x\n  \"\"\"\n  def multiplier(x):\n    return x * factor\n  return multiplier    # return the inner function\n\ndouble = create_multiplier(2)\nprint(double(200))  # Result is a function returned by 'created_multiplier'\nprint(double(400))\n\n400\n800\n\n\n\n\nFunctions can be stored in data structures\nFunctions can be stored in data structures like lists, dictionaries, or sets, making it possible to manage and manipulate functions dynamically.\n\n# Functinos can be stored in data structures\n\ndef square(x):\n  return x**2\n\ndef cube(x):\n  return x**3\n\nmath_functions = [square, cube]\nresult = math_functions[1](3)  # access and call the 'cube' function, give 3 to the parameter\nprint(result)\n\n\n# Using a list of functinos for cleaning strings from survey data\nanswer_states = [\"   alabama \", \"georgia!\", \"Georgia\",  \\\n          \"georgia\", \"flOrIda\", \"south   carolina##\",   \\\n          \"West virginia?\"]\nprint(answer_states)\n          \ndef remove_punctuation(value):\n  return re.sub(\"[!#?]\", \"\", value)\n\nclean_ops = [str.strip, remove_punctuation, str.title] # 3 functinos in list for cleaning operation\n\nimport re\n\ndef clean_strings(strings, ops):\n    result = []\n    for value in strings:\n        for func in ops:\n            value = func(value)\n        result.append(value)\n    return result\n  \nprint(\"strings_cleaned: \", clean_strings(answer_states, clean_ops))\n\nprint(\"-\"*55)\n\n\n# Using map() to apply a function as argument to a sequence\nfor x in map(remove_punctuation, answer_states):\n  print(x)\n\n27\n['   alabama ', 'georgia!', 'Georgia', 'georgia', 'flOrIda', 'south   carolina##', 'West virginia?']\nstrings_cleaned:  ['Alabama', 'Georgia', 'Georgia', 'Georgia', 'Florida', 'South   Carolina', 'West Virginia']\n-------------------------------------------------------\n   alabama \ngeorgia\nGeorgia\ngeorgia\nflOrIda\nsouth   carolina\nWest virginia\n\n\n\n\nAnonymous (Lambda) Functions:\nAnonymous functions, often referred to as “lambda functions,” are a concise way to create a single line, inline functions without giving them a formal name. In Python, lambda functions are defined using the lambda keyword, followed by parameters and an expression. While they are limited in scope compared to regular functions, they offer several benefits:lambda arguments: expression\nStructure: lambda arguments: expression\nConciseness: Lambda functions are compact and allow you to define simple operations in a single line of code, making them particularly useful for short, one-off functions.\nReadability: When used appropriately, lambda functions can improve code readability by encapsulating a specific operation right where it’s needed, reducing the need for named functions or temporary variables.\nFunctional Programming: Lambda functions are a key component of functional programming in Python. They can be used with higher-order functions like map(), filter(), and reduce() to perform operations on collections of data.\n\n# sort a list of tuples by the second element:\ndata = [(1, 5), (3, 2), (2, 8)]\nsorted_data = sorted(data, key=lambda x: x[1])  # extracts the second element (index 1) of each tuple in the data list\nprint(sorted_data)\n\n[(3, 2), (1, 5), (2, 8)]\n\n\n\n# filter even numbers from a list\nnumbers = [1, 2, 3, 4, 5, 6]\neven_numbers = list(filter(lambda x: x % 2 == 0, numbers))  # filtering function, iterables\nprint(even_numbers)\n\n[2, 4, 6]\n\n\n\n# Mapping a Function to a List\n\nvalues = [1, 2, 3, 4, 5]\nsquared_values = list(map(lambda x: x**2, values))\nprint(squared_values)\n\n[1, 4, 9, 16, 25]\n\n\n\ndef short_function(x):\n  return x * 2\nprint(short_function(100))\n\nequiv_amon = lambda x: x * 2  # assign a function to variable\nprint(type(equiv_amon))\nprint(equiv_amon(100))  # produces the same result\nprint(\"-\"*55)\n\n# use a lambda function for the second argument\ndef apply_to_list(some_list, f):\n  \"\"\"\n  Apply the given function to the given list\n  \"\"\"\n  return [f(x) for x in some_list]\nints = [4, 0, 1, 5, 6]\n\nret = apply_to_list(ints, lambda x: x*2)\nprint(ret)\n\n# sort the list of strings based on the number of unique charaters for each string.\nstrings = [\"foo\", \"card\", \"bar\", \"aaaa\", \"abab\"]\nstrings.sort(key=lambda x: len(set(x))) # sort by number of unique characters per string element\nprint(strings)\n\n200\n&lt;class 'function'&gt;\n200\n-------------------------------------------------------\n[8, 0, 2, 10, 12]\n['aaaa', 'foo', 'abab', 'bar', 'card']\n\n\n\n\nGenerators\nGenerators are a powerful and memory-efficient feature in Python for working with sequences of data. They allow you to create iterators on the fly, enabling the processing of large data sets or infinite sequences without storing them in memory. Generators are defined using functions but use the yield keyword to produce values one at a time. Many objects in Python support iteration, such as over objects in a list or lines in a file. This is accomplished by means of the iterator protocol, a generic way to make objects iterable.\nCreating a Generator:\n\nGenerators are defined using functions with the yield keyword.\nA function with yield becomes a generator function.\n\n\n# create a simple generator function\ndef count_up_to(n):\n  i = 1\n  while i &lt;= n:\n    yield i  # yield value and pause execution\n    i += 1\n\nprint(count_up_to(7))\n\nfor num in count_up_to(7):  # iterate generator with for\n  print(num)\n\n&lt;generator object count_up_to at 0x000002993A35FAC0&gt;\n1\n2\n3\n4\n5\n6\n7\n\n\nGenerator Functions vs. Regular Functions:\n\nGenerator functions use yield to produce values and pause execution.\nRegular functions use return to provide a single result and terminate.\n\nIterating Over a Generator:\n\nYou can iterate over a generator using a for loop, just like any other iterable.\nThe generator produces values one at a time as you iterate.\n\nInfinite Sequences:\n\nGenerators can be used to create infinite sequences without consuming infinite memory.\nFor example, a generator can produce an infinite stream of numbers.\n\n\n# create a generator of infinite sequences\n\ndef infinite_evens():\n  num = 0\n  while True:\n    yield num\n    num +=2\n\n# Using next() with a generator    \ninfinite_evens_generator = infinite_evens()\nprint(next(infinite_evens_generator))  # the first element yielded by generator\nprint(next(infinite_evens_generator))\nprint(next(infinite_evens_generator))\nprint(\"-\"*55)\n\n# Using for with condition with a generator\nfor num in infinite_evens_generator:\n  if num &gt; 10:\n    break\n  print(\"Gen yielded: \", num)\nprint(\"-\"*55)\n  \n# Using next() with a stopping condition\ntry:\n  seq_list = []\n  while True:\n    num = next(infinite_evens_generator)\n    if num &gt; 100:\n      break\n    seq_list.append(num)\nexcept StropIteration:\n  pass\n\nprint(\"Sequence from Gen: \", seq_list)\nprint(\"-\"*55)\n\n0\n2\n4\n-------------------------------------------------------\nGen yielded:  6\nGen yielded:  8\nGen yielded:  10\n-------------------------------------------------------\nSequence from Gen:  [14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48, 50, 52, 54, 56, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 98, 100]\n-------------------------------------------------------\n\n\n\n# Both produces the same results\n\nsome_dict = {\"a\": 1, \"b\": 2, \"c\": 3}\nfor key in some_dict:\n  print(key)\n\ndict_iterator = iter(some_dict)  # get iterator for the given iterable object\nprint(dict_iterator)\nfor item in dict_iterator:\n  print(item)\n\na\nb\nc\n&lt;dict_keyiterator object at 0x000002993D9BA930&gt;\na\nb\nc\n\n\n\n# working with an iterator\n \nsome_dict = {\"a\": 1, \"b\": 2, \"c\": 3}\ndict_iterator = iter(some_dict)\nprint(dict_iterator)\nprint(type(dict_iterator))\nprint(\"List created from an iterator: \", list(dict_iterator))\nprint(\"-----------------------------------------------------\")\n\n# create a generator producing squares from 1 to (n**2)\ndef squares(n=10):\n  print(f\"Generator producing squares from 1 to {n**2}\")\n  for i in range(1, n+1):\n    yield i**2\n  \ngen = squares()\nprint(gen)  # when called, generator itself does not execute any code\n\nfor x in gen: # actual code execution through iteration, One at a time, Not all at once\n  print(x, end=\" \")\n\n&lt;dict_keyiterator object at 0x000002993D9D6110&gt;\n&lt;class 'dict_keyiterator'&gt;\nList created from an iterator:  ['a', 'b', 'c']\n-----------------------------------------------------\n&lt;generator object squares at 0x000002993D93FAE0&gt;\nGenerator producing squares from 1 to 100\n1 4 9 16 25 36 49 64 81 100 \n\n\nGenerator express: Parentheses instead of brackets in comprehensions - list, set, dictionary, instead of list comprehension style.\n\n# generator expression, one-liner, less verbose than generator function definition\ngen = (x**2 for x in range(100))\nprint(gen)\n\n# generator expression as function argument\nprint(sum(x**2 for x in range(100))) # argument for sum() function\nprint( dict((i, i ** 2) for i in range(5)) )\n\n&lt;generator object &lt;genexpr&gt; at 0x000002993A35F2A0&gt;\n328350\n{0: 0, 1: 1, 2: 4, 3: 9, 4: 16}\n\n\nitertools module (standard library), collection of generators for common data algorithms.\nitertools.groupby(iterable, key=None)\nThis is a function from the itertools module in Python. It’s used for grouping elements from an iterable into consecutive keys that share a common characteristic, as determined by a key function. The elements in the iterable are expected to be sorted based on the same key function for groupby() to work effectively.\niterable: This is the iterable (e.g., a list, tuple, or iterator) containing the elements you want to group.\nkey: This is an optional argument that specifies a function to extract a key from each element in the iterable. The elements in the iterable are grouped by the values returned by this key function.\nThe function returns an iterator that produces pairs of a key and an iterator over the elements in the group.\n\nimport itertools\n\nwords = [\"apple\", \"banana\", \"bat\", \"cat\", \"dog\", \"elephant\"]\n\n# Sort the words by their first letter\nsorted_words = sorted(words, key=lambda x: x[0])\nprint(sorted_words)\n\n# Use groupby to group words by their first letter (consecutive words with same first letter)\ngroups = itertools.groupby(sorted_words, key=lambda x: x[0])\nprint(groups)\n\n# iterate through the groups and print each group, very useful dealing with sorted data\nfor key, group in groups:\n  print(f\"Words starting with '{key}': {list(group)}\") #list() required to convert generator\n\n['apple', 'banana', 'bat', 'cat', 'dog', 'elephant']\n&lt;itertools.groupby object at 0x000002993D9BB790&gt;\nWords starting with 'a': ['apple']\nWords starting with 'b': ['banana', 'bat']\nWords starting with 'c': ['cat']\nWords starting with 'd': ['dog']\nWords starting with 'e': ['elephant']\n\n\nitertools.chain(*iterables):\nGenerates a sequence by chaining iterators together. Once elements from the first iterator are exhausted, elements form the next iterator are returned, and so on.\n\n# chain multiple iterators for continuous iteration\nfrom itertools import chain\n\n# Three lists\nlist1 = [1, 2, 3]\nlist2 = ['a', 'b', 'c']\nlist3 = [10, 20, 30]\n\n# chain them into a single iterable\ncombined = chain(list1, list2, list3)\nprint(combined, type(combined))\n\n# continuous iteration\nfor item in combined:\n  print(item, end=\" \")\n\n&lt;itertools.chain object at 0x000002993A355780&gt; &lt;class 'itertools.chain'&gt;\n1 2 3 a b c 10 20 30 \n\n\nitertools.combinations(iterable, k):\nIt generates all possible combinations of ‘k’ number of elements from an iterable. Each combination is a tuple, and the function returns an iterator. It is very useful when exploring various subsets or combinations of elements from a collection. It generate only unique combination regardless of order of the elements.\n\nfrom itertools import combinations\n\n# generate all possible combinations of 2 elements from a given list\n\nelements = [1, 2, 3, 4]\ncombos = combinations(elements, 2)\n\n# iterate the generator\nfor combo in combos:\n  print(combo)\n  # or do something else, more...\n\n(1, 2)\n(1, 3)\n(1, 4)\n(2, 3)\n(2, 4)\n(3, 4)\n\n\nitertools.permutations(iterable, k):\nIt generates all possible combinations of ‘k’ number of elements from an iterable. The order of elements in a permuation matters, so different orders are considered distinct. It cna produce more output than ‘combinations()’ when ‘k’ is less than the lenght of the iterable since it considers all possible arrangements. The result is an iterator of tuples, each representing a unique permutation of the elements.\n\nfrom itertools import permutations\n\nelements = [1, 2, 3, 4]\nperms = permutations(elements, 2)\nfor perm in perms:\n  print(perm)\n\n(1, 2)\n(1, 3)\n(1, 4)\n(2, 1)\n(2, 3)\n(2, 4)\n(3, 1)\n(3, 2)\n(3, 4)\n(4, 1)\n(4, 2)\n(4, 3)\n\n\nitertools.product(*iterables, repeat=1):\nThe function is used to generate the Cartesian product of multiple input iterables . The Cartesian product is a set of all possible combinations of elements from the input iterables, where each combination consists of one element from each input iterable.\n\n# Cartesian product of iterables\nfrom itertools import product\n\niterable1 = [1, 2]\niterable2 = ['a','b']\n\n# Generate the Cartesian product of the two iterables\nresult = product(iterable1, iterable2)\n\n# Iterate through the product and print the combinations\nfor combo in result:\n  print(combo)\nprint(\"------------------------\")\n\n# set number of times to rpeat the each input iterable\nresult = product(iterable1, iterable2, repeat=2) # repeating 2 times\nfor combo in result:\n  print(combo)\n\n(1, 'a')\n(1, 'b')\n(2, 'a')\n(2, 'b')\n------------------------\n(1, 'a', 1, 'a')\n(1, 'a', 1, 'b')\n(1, 'a', 2, 'a')\n(1, 'a', 2, 'b')\n(1, 'b', 1, 'a')\n(1, 'b', 1, 'b')\n(1, 'b', 2, 'a')\n(1, 'b', 2, 'b')\n(2, 'a', 1, 'a')\n(2, 'a', 1, 'b')\n(2, 'a', 2, 'a')\n(2, 'a', 2, 'b')\n(2, 'b', 1, 'a')\n(2, 'b', 1, 'b')\n(2, 'b', 2, 'a')\n(2, 'b', 2, 'b')\n\n\n\n\nErrors and Exception Handling\nThis is an important part of building robust programs. In data applications, many functions work only on certain kinds of input.\n\n# function throwing error\nprint(float(\"1.2345\"))  # convert proper string input to float value\n# print(float(\"1,2345\"))  # throwing error with improper input\n\n1.2345\n\n\n\n# Failing gracefully\ndef attempt_float(x):\n  try:\n    return float(x)\n  except:\n    return x  # return input value gracefully(?) when 'try' failed, exception raised\n\nprint(attempt_float(\"1,2345\"))\n\n1,2345\n\n\n\n# suppressing a specific error\ndef attempt_float(x):\n  try:\n    return float(x)\n  except ValueError:\n    return x\n\n# attempt_float((1, 2))  # this caused an error other than ValueError\n\n\n# suppressing multiple errors\ndef attempt_float(x):\n  try:\n    return float(x)\n  except (TypeError, ValueError):  # now added TypeError to supress it too.\n    return x\n\nattempt_float((1, 2)) # failed, and gracefully return the input value as defined in try-execept, errors suppressed.\n\n(1, 2)\n\n\n\n# 'finally' lets you execute some codes regardless the success of try-block.\n\nf = open(\"./try-finally.txt\", mode=\"w\")\ntry:\n  write_to_file(f)\nexcept:\n  print(\"Failed\")\nelse:\n  print(\"Succeeded\")\nfinally:\n  f.close()\n\nFailed"
  },
  {
    "objectID": "posts/p4da3d-data-types.html#files-and-the-operating-system",
    "href": "posts/p4da3d-data-types.html#files-and-the-operating-system",
    "title": "[3] Built-In Data Structures, Functions, and Files",
    "section": "Files and the Operating System",
    "text": "Files and the Operating System\nWorking with files and the operating system is a fundamental aspect of programming in Python. Python provides powerful tools and libraries to manipulate files, read and write data, and interact with the underlying file system\n\nFile handling basics:\n\n# writing to a text file\nwith open('file_test.txt', 'w') as file:\n  file.write(\"Hello, world!\")\n  file.write(\"Brown fox jumped over the fence.\")\n  file.write(\"Handling file with text in Python is very straight forward.\")\n\n\n# opening and reading a text file\nwith open('file_test.txt', 'r') as file:\n  content = file.read()\nprint(content)\n\nHello, world!Brown fox jumped over the fence.Handling file with text in Python is very straight forward.\n\n\n\n# appending to a text file\nwith open('file_test.txt', 'a') as file:\n  file.write('\\nAppended line 1')\n  file.write('\\nAppended line 2')\n  file.write('\\nAppended line 3')\n  file.write('\\nAppended line 4')\n  \nwith open('file_test.txt', 'r') as file:\n  content = file.read()\nprint(content)\n\nHello, world!Brown fox jumped over the fence.Handling file with text in Python is very straight forward.\nAppended line 1\nAppended line 2\nAppended line 3\nAppended line 4\n\n\n\n\nFile Navigation and Operations:\n\n# Listing files in a directory\n\nimport os\n\nfiles = os.listdir('../') # files in upper directory\nprint(files)\n\n['.git', '.gitignore', '.nojekyll', '.quarto', '.RData', '.Rhistory', '.Rproj.user', 'about.qmd', 'albert-joonyoung-park.github.io.Rproj', 'blog.qmd', 'data', 'docs', 'images', 'index.qmd', 'posts', 'profile.jpg', 'projects', 'projects.qmd', 'reports', 'styles.css', '_freeze', '_quarto.yml']\n\n\n\nimport os\n\npath = \"examples/segismundo.txt\"\n\n# open file with given encoding, \"r\" mode by default\nf = open(path, encoding=\"utf-8\") # default Unicode encoding is platform-specific\n\n# iterate the file object and print line with EOL marker intact\nfor line in f:\n  print(line)\n\n# close the file\nf.close()\n\nSueña el rico en su riqueza,\n\nque más cuidados le ofrece;\n\n\n\nsueña el pobre que padece\n\nsu miseria y su pobreza;\n\n\n\nsueña el que a medrar empieza,\n\nsueña el que afana y pretende,\n\nsueña el que agravia y ofende,\n\n\n\ny en el mundo, en conclusión,\n\ntodos sueñan lo que son,\n\naunque ninguno lo entiende.\n\n\n\n\n\n\nimport os\n\npath = \"examples/segismundo.txt\"\n\n# EOL-free list of lines in a file\nwith open(path, encoding=\"utf-8\") as f:\n  lines = [x.rstrip() for x in f]\nprint(lines)\n\n['Sueña el rico en su riqueza,', 'que más cuidados le ofrece;', '', 'sueña el pobre que padece', 'su miseria y su pobreza;', '', 'sueña el que a medrar empieza,', 'sueña el que afana y pretende,', 'sueña el que agravia y ofende,', '', 'y en el mundo, en conclusión,', 'todos sueñan lo que son,', 'aunque ninguno lo entiende.', '']\n\n\n\n# read, seek and tell\n\n# read moves the file object position by the number of bytes read after reading character or bytes\nf1 = open(path)\nprint(f1.read(10)) # read 10 characters with the encoding used for this file operation\n\nf2 = open(path, mode=\"rb\")  # open with binary mode\nprint(f2.read(10)) # read 10 bytes\n\n# tell current file object position\nprint(f1.tell())\nprint(f2.tell())\n\nimport sys\nprint(sys.getdefaultencoding())  # this is the default encoding of the platform in use.\n\n# seek changes the file position to the indicated byte in the file\n\nprint(f1.seek(3))\nprint(f1.read(1))\nprint(f1.tell())\n\nprint(f2.seek(3))\nprint(f2.read(1))\nprint(f2.tell())\n\n# close the files\nf1.close()\nf2.close()\n\nSueÃ±a el \nb'Sue\\xc3\\xb1a el '\n10\n10\nutf-8\n3\nÃ\n4\n3\nb'\\xc3'\n4\n\n\n\nimport os\n\nprint(os.getcwd())\n\npath = \"examples/segismundo.txt\"\nprint(path)\n\n# create a new file from path, remove blank lines\n\nwith open(\"examples/tmp.txt\", mode=\"w\") as handle:\n  handle.writelines(x for x in open(path) if len(x) &gt; 1)\n\nC:\\Users\\Joon\\git\\albert-joonyoung-park.github.io\\posts\nexamples/segismundo.txt\n\n\n\n# Open the new file and read\nwith open(\"examples/tmp.txt\") as f:\n  lines = f.readlines()\n\nlines\n\n['SueÃ±a el rico en su riqueza,\\n',\n 'que mÃ¡s cuidados le ofrece;\\n',\n 'sueÃ±a el pobre que padece\\n',\n 'su miseria y su pobreza;\\n',\n 'sueÃ±a el que a medrar empieza,\\n',\n 'sueÃ±a el que afana y pretende,\\n',\n 'sueÃ±a el que agravia y ofende,\\n',\n 'y en el mundo, en conclusiÃ³n,\\n',\n 'todos sueÃ±an lo que son,\\n',\n 'aunque ninguno lo entiende.\\n']\n\n\n\n\nBytes and Unicode with Files\n\npath = \"examples/segismundo.txt\"\n\n# default file behavior - text mode\nwith open(path) as f:\n  chars = f.read(10) # read eough bytes to decode 10 characters, if utf-8 in use by the platform\n\nprint(chars)\nprint(len(chars))\n\n# binary mode\nwith open(path, mode=\"rb\") as f:  # append b to the mode\n  data = f.read(10) # read exact 10 bytes\nprint(data)\n\n# try and decode the bytes to a string object\nprint(data.decode(\"utf-8\")) # works only if each of the encoded Unicode characters is fully formed\n# print(data[:4].decode(\"utf-8\")) # error - not fully formed\nprint(data[:5].decode(\"utf-8\")) # worked, fully formed by the given range\n\nSueÃ±a el \n10\nb'Sue\\xc3\\xb1a el '\nSueña el \nSueñ\n\n\n\n# Use encoding option with open() to covert Unicode encoding to another\n\n# Create a new file converting encoding of segismundo.txt to iso-8859-1\n\npath = \"examples/segismundo.txt\"\nsink_path = \"examples/sink.txt\"\nwith open(path) as source:\n  with open(sink_path, \"w\", encoding=\"iso-8859-1\") as target:\n    target.write(source.read())\n\nwith open(sink_path, encoding=\"iso-8859-1\") as f:\n  print(f.read(10))\n\nSueÃ±a el"
  },
  {
    "objectID": "posts/p4da3d-numpy.html#pseudorandom-number-generation",
    "href": "posts/p4da3d-numpy.html#pseudorandom-number-generation",
    "title": "[4] Arrays and Vectorized Computation",
    "section": "Pseudorandom Number Generation",
    "text": "Pseudorandom Number Generation\nThe numpy.random module supplements the built-in Python random module with functions for efficiently generating whole arrays of sample value from many kinds of probability distributions.\n\n# Generates 4x4 random numbers from a standard normal distribution (mean = 0, standard deviation = 1)\n\nsamples = np.random.standard_normal(size=(4, 4))\nprint(samples)\n\n[[ 0.02438752  0.3888968  -0.25353428  0.50565954]\n [ 0.69382098 -0.36495474  0.4066921  -0.47840471]\n [-0.88659672  1.19854012 -0.34464064 -0.62669276]\n [-0.01201135 -0.49104672 -0.04240425  2.90625971]]\n\n\n\n# Set to use explicit generator using seed\nrng = np.random.default_rng(seed=12345)\ndata = rng.standard_normal((2, 3))\nprint(data)\ndata2 = rng.standard_normal((2, 3))\nprint(data2)\ndata3 = rng.standard_normal((2, 3))\nprint(data3)\nprint(type(rng))\n\n[[-1.42382504  1.26372846 -0.87066174]\n [-0.25917323 -0.07534331 -0.74088465]]\n[[-1.3677927   0.6488928   0.36105811]\n [-1.95286306  2.34740965  0.96849691]]\n[[-0.75938718  0.90219827 -0.46695317]\n [-0.06068952  0.78884434 -1.25666813]]\n&lt;class 'numpy.random._generator.Generator'&gt;\n\n\nnumpy.random._generator.Generator class\npermutation: Returns a random permutation of a sequences - list, array, shuffles the elements\n\nimport numpy as np\n\n# Some array\narr = np.array([1, 2, 3, 4, 5])\n# Generate a random permutation of the array\npermuted_arr = np.random.permutation(arr)\nprint(permuted_arr)\n\n[3 4 1 2 5]\n\n\nshuffles: Shuffles elements by modifying the original in place\n\n# some array\narr = np.array([1, 2, 3, 4, 5])\n# shuffle the array in place\nnp.random.shuffle(arr)\nprint(arr)\nnp.random.shuffle(arr)\nprint(arr)\nnp.random.shuffle(arr)\nprint(arr)\n\n[3 5 4 1 2]\n[5 3 2 4 1]\n[4 5 1 3 2]\n\n\nuniform: Equal Probability Occuring, Generate random numbers from a uniform distriubution within a specified range.\n\n# generate random numbers in uniform between 0 and 1\n\nimport numpy as np\n\nrandom_nums = np.random.uniform(0, 1, size=7)\nprint(random_nums)\n\n[0.2830613  0.79880075 0.58422251 0.01745402 0.66536846 0.21399967\n 0.19575847]\n\n\nrandint: Generate random integers within a specified range\n\n# Generate random integers within a specified range.\nimport numpy as np\nrandom_ints = np.random.randint(1, 11, size=7)\nprint(random_ints)\n\n[5 2 2 3 5 3 6]\n\n\nstandard_normal: Generate random numbers from a standard normal distribution (mean=0, standard deviation=1)\n\n# generate random numbers from a standard normal distribution\n\nimport numpy as np\n\nrandom_nums = np.random.standard_normal(size=7)\nprint(random_nums)\nprint(np.mean(random_nums))  # close to 0\nprint(np.std(random_nums))  # close to 1\n\n[ 0.41237087 -0.68778692  0.77539471  1.15493846 -1.07059758  1.2746338\n  0.10654032]\n0.2807848089726647\n0.8288167933552584\n\n\nbinomial: Generates random numbers from a binomial distribution (two possible outcomes, success or failure - Bernoulli trials)\n\nimport numpy as np\n\n# Generate random numbers from a binomial distribution\nrandom_nums = np.random.binomial(n=10, p=0.5, size=5)\nprint(random_nums)\n\n# interpretation of the result\n\"\"\"\nThe code generates 5 random numbers, each representing the number of successful outcomes in 10 independent trials where each trial has a 50% chance of success.\n\nThe possible values for each of these random numbers range from 0 to 10 because you can have 0 to 10 successful outcomes in 10 trials.\n\nThe specific numbers you obtained, [7, 5, 8, 3, 7], represent the results of 5 separate random experiments. For example, in the first experiment, you got 7 successful outcomes out of 10 trials, and in the second experiment, you got 5 successful outcomes, and so on.\n\nThe result will vary each time you run the code because it's based on random sampling, but the numbers are generated according to a binomial distribution with the specified parameters (10 trials with a 50% chance of success on each trial).\n\"\"\"\n\n[5 5 5 5 2]\n\n\n\"\\nThe code generates 5 random numbers, each representing the number of successful outcomes in 10 independent trials where each trial has a 50% chance of success.\\n\\nThe possible values for each of these random numbers range from 0 to 10 because you can have 0 to 10 successful outcomes in 10 trials.\\n\\nThe specific numbers you obtained, [7, 5, 8, 3, 7], represent the results of 5 separate random experiments. For example, in the first experiment, you got 7 successful outcomes out of 10 trials, and in the second experiment, you got 5 successful outcomes, and so on.\\n\\nThe result will vary each time you run the code because it's based on random sampling, but the numbers are generated according to a binomial distribution with the specified parameters (10 trials with a 50% chance of success on each trial).\\n\"\n\n\nnormal: Generates random numbers from a normal distribution with specified mean and standard deviation.\n\nimport numpy as np\n\n# Generate random numbers from a normal distribution\nrandom_nums = np.random.normal(loc=0, scale=1, size=100)  # loc: mean(center peak),scale: standard deviation, size: number of random numbers to generate\n\nprint(random_nums)\n\n[-0.00696454  0.0214189  -1.42455243  0.36136736 -0.61930816 -0.31244649\n  1.39291758  0.98820841 -0.51702993  0.59563007  0.24867064  1.34785811\n -0.69594826  0.09236997  0.24227799 -0.5922411   2.26783981  0.16404388\n -0.25167976  1.22072294  0.52205938 -1.69107276  0.10705041 -0.67858279\n  0.99601737  1.28758256 -0.82151763 -1.15386979  0.0211763  -0.86365435\n  0.28562624  0.27583518  0.36980757  0.23285048  0.01086876  0.60453358\n -0.7103104   0.82039425 -0.12596228 -0.53830311  0.03426621 -1.77197059\n  1.48829227  0.53860449 -1.15945694  0.62534058  0.69087205  1.27406982\n  1.58980275 -0.92830126  0.979448    0.56596988 -0.77310244 -2.01179695\n -0.22836684  0.0935332   0.87793864  0.52128948 -0.35862365  0.01452477\n  0.10494151 -0.50833713 -0.13354027  2.13108755  0.5016837   1.10169622\n  1.32947346 -0.67884005 -1.00460594 -0.33893047  0.87737814  0.32742269\n  0.12677347 -2.47772429 -0.22611494 -1.57731021  0.77216936  0.52837262\n  3.38936433 -0.34167377  0.32182606 -0.37863225  0.92298595 -2.043062\n -1.1717948  -0.09791369  0.38802381 -0.10557425 -0.78998972 -0.3727696\n -1.95957704  1.70569364  0.47251256  0.14704871  0.58025787  1.75071261\n -0.38211577  0.83111002  0.09054014  0.35010363]\n\n\n\n# draw s simple plot with the array\nimport matplotlib.pyplot as plt\n\nplt.clf() # clear any previous figure with plt.\n\n# histogram plot\nplt.hist(random_nums, bins=50, density=True, alpha=0.7, color='red', edgecolor='black')\nplt.xlabel('Value')\nplt.ylabel('Frequency')\nplt.title('Histogram of Random Numbers from Standard Normal Distribution')\nplt.show()\n\n\n\n\n\n# KDE (Kernel Density Estimate)\n\nimport seaborn as sns\nimport matplotlib.pyplot as plt\n\nplt.clf() # clear any previous figure with plt.\n\nsns.kdeplot(random_nums, color='green', fill=True)\nplt.xlabel('Value')\nplt.ylabel('Density')\nplt.title('KDE Plot of Random Numbers from Standard Normal Distribution')\nplt.show()\n\n\n\n\n\nimport matplotlib.pyplot as plt\n\nplt.clf() # clear any previous figure with plt.\n\n# Create a box plot\nplt.boxplot(random_nums)\n\n# Add labels and title\nplt.xlabel('Value')\nplt.ylabel('Distribution')\nplt.title('Box Plot of Random Numbers from Standard Normal Distribution')\n\n# Show the plot\nplt.show()\n\n\n\n\n\n# ECDF Plot (Empirical Cumulative Distribution Function): how the data accumulates moving along the x-axis, representing the cumulative distribution\n\nplt.clf() # clear any previous figure with plt.\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Create an ECDF plot\nsorted_nums = np.sort(random_nums)\nprint(len(sorted_nums))\ny = np.arange(1, len(sorted_nums) + 1) / len(sorted_nums)\nplt.plot(sorted_nums, y, marker='.', linestyle='none')\n\n# Add labels and title\nplt.xlabel('Value')\nplt.ylabel('ECDF')\nplt.title('ECDF Plot of Random Numbers from Standard Normal Distribution')\n\n# Show the plot\nplt.grid(True)\nplt.show()\n\n100\n\n\n\n\n\nbeta: Generates random numbers from a beta distribution.\n\nimport numpy as np\n\n# Generate random numbers from a beta distribution\nrandom_nums = np.random.beta(a=2, b=5, size=5)\nprint(random_nums)\n\n[0.24908806 0.22241801 0.03200077 0.35978889 0.45460631]\n\n\nchisquare: Generates random numbers from a chi-squared distribution\n\nimport numpy as np\n\n# Generate random numbers from a chi-squared distribution\nrandom_nums = np.random.chisquare(df=3, size=5)\nprint(random_nums)\n\n[3.49405042 2.55796782 5.23348605 0.93066636 3.13663889]\n\n\ngamma: Generates random numbers from a gamma distribution\n\nimport numpy as np\n\n# Generate random numbers from a gamma distribution\nrandom_nums = np.random.gamma(shape=2, scale=2, size=5)\nprint(random_nums)\n\n[2.236189   3.12003875 0.38688417 1.59182572 1.4935085 ]"
  },
  {
    "objectID": "posts/p4da3d-numpy.html#universal-functions-fast-element-wise-array-functions",
    "href": "posts/p4da3d-numpy.html#universal-functions-fast-element-wise-array-functions",
    "title": "[4] Arrays and Vectorized Computation",
    "section": "Universal Functions: Fast Element-Wise Array Functions",
    "text": "Universal Functions: Fast Element-Wise Array Functions\nufunc, a function taht performs element-wise operatinos on data in ndarrays\n\n# unary ufunc\n\narr = np.arange(10)\nprint(arr, type(arr))\nprint(np.sqrt(arr))  # sqrt on each element\nprint(np.exp(arr))   # exp on each element\nprint(\"-\"*60)\n\n# binary ufunc\nx = rng.standard_normal(8)\ny = rng.standard_normal(8)\nprint(x)\nprint(y)\nprint(np.maximum(x, y))  # element-wise maximum from x, y\n\narr = rng.standard_normal(7) * 5\nprint(arr)\nfractional_part, integral_part = np.modf(arr)  # returning two arrays\nprint(fractional_part)\nprint(integral_part) \n\n[0 1 2 3 4 5 6 7 8 9] &lt;class 'numpy.ndarray'&gt;\n[0.         1.         1.41421356 1.73205081 2.         2.23606798\n 2.44948974 2.64575131 2.82842712 3.        ]\n[1.00000000e+00 2.71828183e+00 7.38905610e+00 2.00855369e+01\n 5.45981500e+01 1.48413159e+02 4.03428793e+02 1.09663316e+03\n 2.98095799e+03 8.10308393e+03]\n------------------------------------------------------------\n[ 0.57585751  1.39897899  1.32229806 -0.29969852  0.90291934 -1.62158273\n -0.15818926  0.44948393]\n[-1.34360107 -0.08168759  1.72473993  2.61815943  0.77736134  0.8286332\n -0.95898831 -1.20938829]\n[ 0.57585751  1.39897899  1.72473993  2.61815943  0.90291934  0.8286332\n -0.15818926  0.44948393]\n[-7.06146007  2.70773415  3.75969698 -3.2938016  -6.14337493  1.28778884\n  1.56451459]\n[-0.06146007  0.70773415  0.75969698 -0.2938016  -0.14337493  0.28778884\n  0.56451459]\n[-7.  2.  3. -3. -6.  1.  1.]\n\n\nUniversal functions(ufunc)"
  },
  {
    "objectID": "posts/p4da3d-numpy.html#array-oriented-programming-with-arrays",
    "href": "posts/p4da3d-numpy.html#array-oriented-programming-with-arrays",
    "title": "[4] Arrays and Vectorized Computation",
    "section": "Array-Oriented Programming with Arrays",
    "text": "Array-Oriented Programming with Arrays\nEvaluate a function using with an array, not for loop\nnumpy.meshgrid()\n\n# mumpy.meshgrid\n\npoints = np.arange(-5, 5, 0.01)\n#print(points)\nprint(points.size) # array size\nxs, ys = np.meshgrid(points, points) # create a comple grid for coordinates\n#print(xs)\n#print(ys)\n\n# evaluate the function\nz = np.sqrt(xs**2 + ys**2)\n#print(\"z: \", z)\n\n# create a plot - colorbar\nimport matplotlib.pyplot as plt\n\nplt.clf() # clear any previous figure\n\n# using imghow() function\nplt.imshow(z, cmap=plt.cm.gray, extent=[-5, 5, -5, 5])\nplt.colorbar()\nplt.title(\"Image plot of $\\sqrt{x^2 + y^2}$ for a grid of values\")\nplt.show()\n\n1000\n\n\n\n\n\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Generate the same grid as before\npoints = np.arange(-5, 5, 0.01)\nxs, ys = np.meshgrid(points, points)\nz = np.sqrt(xs**2 + ys**2)\n\n# Create a line chart by taking values along a horizontal line (e.g., y=0)\nline_values = z[len(points)//2, :]\n\n# Create an array of x-values for the line chart\nx_values = points\n\n# Create a line chart\nplt.clf()\nplt.plot(x_values, line_values, label='Line Chart')\nplt.xlabel('X')\nplt.ylabel('Function Value')\nplt.title('Line Chart of Function Values along y=0')\nplt.legend()\nplt.grid(True)\n\n# Show the plot\nplt.show()\n\n\n\n\n\nExpressing conditional logicas Array Operations\nnumpy.where - vectorized version fo ternary expression x if condition else y\n\nxarr = np.array([1.1, 1.2, 1.3, 1.4, 1.5])\nyarr = np.array([2.1, 2.2, 2.3, 2.4, 2.5])\n# Boolean arrary to use as conditional value for xarr, yarr\ncond = np.array([True, False, True, True, False])\n\nprint(\"xarr: \", xarr)\nprint(\"yarr: \", yarr)\nprint(\"cond: \", cond)\n\n# Generate an array to take a value for xarr when corresponding boolean array is True, otherwise take the value form yarr.\nprint(\"Generate an array to take a value for xarr when corresponding boolean array is True, otherwise take the value form yarr.\")\n\n# Using conventional list conprehension.\nresult_list_comprehension = [ (x if c else y)for x, y, c in zip(xarr, yarr, cond) ]\nprint(\"Result using list comprehension: \", result_list_comprehension)\nprint(\"Issues: 1. Slow 2. Won't work with multi-dimensional arrays\")\n\n# Using numpy.where(cond, xarr, yarr) - no need to be arrays for the 2nd and 3rd argument\nprint(\"Using numpy.where(cond, xarr, yarr) - no need to be arrays for the 2nd and 3rd argument.\")\nresult_numpy_where = np.where(cond, xarr, yarr)\nprint(\"result_numpy_where: \", result_numpy_where)\n\nxarr:  [1.1 1.2 1.3 1.4 1.5]\nyarr:  [2.1 2.2 2.3 2.4 2.5]\ncond:  [ True False  True  True False]\nGenerate an array to take a value for xarr when corresponding boolean array is True, otherwise take the value form yarr.\nResult using list comprehension:  [1.1, 2.2, 1.3, 1.4, 2.5]\nIssues: 1. Slow 2. Won't work with multi-dimensional arrays\nUsing numpy.where(cond, xarr, yarr) - no need to be arrays for the 2nd and 3rd argument.\nresult_numpy_where:  [1.1 2.2 1.3 1.4 2.5]\n\n\nWrite code: Generate a matrix with random data, and replace all positive values with 2 and all negative values with -2\n\nimport numpy as np\n\n# create a random number generator\nrng = np.random.default_rng(seed=12345)\n\n# generate an array of random numbers in 4x4, using standard_normal here,\narr = rng.standard_normal((4, 4))\nprint(\"arr using standard_normal): \", arr)\n\n# generate a conditional boolean array by checking condition\n# generate an array according to the condition and operations\nprint(\"arr &gt; 0: \", arr &gt; 0)\nprint(\"np.where(arr &gt; 0, 2, -2): \", np.where(arr &gt; 0, 2, -2)) # using scalar values\nprint(\"original arr: \", arr)\n\n# generatate an array using boolean condition, scalars and arrays\n# replace all positive values in arr with 2, if not, don't do anything\nprint(\"mix of scalar and array: \", np.where(arr &gt; 0, 2, arr)) # set only positive values to 2, otherwise untouched\n\narr using standard_normal):  [[-1.42382504  1.26372846 -0.87066174 -0.25917323]\n [-0.07534331 -0.74088465 -1.3677927   0.6488928 ]\n [ 0.36105811 -1.95286306  2.34740965  0.96849691]\n [-0.75938718  0.90219827 -0.46695317 -0.06068952]]\narr &gt; 0:  [[False  True False False]\n [False False False  True]\n [ True False  True  True]\n [False  True False False]]\nnp.where(arr &gt; 0, 2, -2):  [[-2  2 -2 -2]\n [-2 -2 -2  2]\n [ 2 -2  2  2]\n [-2  2 -2 -2]]\noriginal arr:  [[-1.42382504  1.26372846 -0.87066174 -0.25917323]\n [-0.07534331 -0.74088465 -1.3677927   0.6488928 ]\n [ 0.36105811 -1.95286306  2.34740965  0.96849691]\n [-0.75938718  0.90219827 -0.46695317 -0.06068952]]\nmix of scalar and array:  [[-1.42382504  2.         -0.87066174 -0.25917323]\n [-0.07534331 -0.74088465 -1.3677927   2.        ]\n [ 2.         -1.95286306  2.          2.        ]\n [-0.75938718  2.         -0.46695317 -0.06068952]]\n\n\n\n\nMathematical and Statistical Methods\nNumPy provides array methods and functions for statistical computations like sum, mean, and std. These can be applied to entire arrays or along specific axes. Methods are called on array instances, while functions like numpy.sum take the array as the first argument.\nWrite code: Generate some normally distributed random data, and apply reduction (aggregation) functions to the array - average, total, standard deviation, standard variance, minimum, maximum, indices of minimum and maximum, cumulative sum, cumulative product.\n\nimport numpy as np\n\n# create a random number generator using normal distributionin 5x4 array\nrng = np.random.default_rng(seed=12345)\narr = rng.standard_normal((5, 4))\nprint(\"Random number array: \", arr)\nprint(\"Average of array - array.mean(): \", arr.mean()) # call on array\nprint(\"Average of array - numpy.mean(): \", np.mean(arr)) # pass array\n\n# compute avearge over columns\nprint(\"Average along columns: \", arr.mean(axis=1)) \n\n# compute total over rows\nprint(\"Total along the rows: \", arr.sum(axis=0)) \n\n# standard deviation and variance\nprint(\"Standard variance: \", np.var(arr))\nprint(\"Standard deviation: \", np.std(arr)) # sqrt(standard_variance)\n\n# maximum value\nprint(\"Maximum: \", np.max(arr), \"Indice of max element: \", np.argmax(arr))\n\n# minimum value\nprint(\"Minimum: \", np.min(arr),  \"Indice of min element: \", np.argmin(arr))\n\n# cumulative sum of elements - flattened\nprint(\"Cumulative sum: \", arr.cumsum())\n\n# cumulative sum of elements (axis=1, columns)\nprint(\"Cumulative sum(cols): \", arr.cumsum(axis=1))\n\n# cumulative sum of elements (axis=0, rows)\nprint(\"Cumulative sum(rows): \", arr.cumsum(axis=0))\n\n# cumulative product of elements\nprint(\"Cumulative product: \", arr.cumprod())\n\nRandom number array:  [[-1.42382504  1.26372846 -0.87066174 -0.25917323]\n [-0.07534331 -0.74088465 -1.3677927   0.6488928 ]\n [ 0.36105811 -1.95286306  2.34740965  0.96849691]\n [-0.75938718  0.90219827 -0.46695317 -0.06068952]\n [ 0.78884434 -1.25666813  0.57585751  1.39897899]]\nAverage of array - array.mean():  0.0010611661248891013\nAverage of array - numpy.mean():  0.0010611661248891013\nAverage along columns:  [-0.32248289 -0.38378196  0.4310254  -0.0962079   0.37675318]\nTotal along the rows:  [-1.10865307 -1.78448912  0.21785956  2.69650595]\nStandard variance:  1.1895475864268188\nStandard deviation:  1.0906638283297099\nMaximum:  2.347409654378852 Indice of max element:  10\nMinimum:  -1.95286306301219 Indice of min element:  9\nCumulative sum:  [-1.42382504 -0.16009658 -1.03075832 -1.28993155 -1.36527486 -2.10615951\n -3.47395221 -2.82505941 -2.4640013  -4.41686436 -2.06945471 -1.1009578\n -1.86034498 -0.95814671 -1.42509988 -1.4857894  -0.69694505 -1.95361319\n -1.37775567  0.02122332]\nCumulative sum(cols):  [[-1.42382504 -0.16009658 -1.03075832 -1.28993155]\n [-0.07534331 -0.81622796 -2.18402066 -1.53512786]\n [ 0.36105811 -1.59180495  0.7556047   1.72410161]\n [-0.75938718  0.14281109 -0.32414208 -0.3848316 ]\n [ 0.78884434 -0.46782379  0.10803373  1.50701272]]\nCumulative sum(rows):  [[-1.42382504  1.26372846 -0.87066174 -0.25917323]\n [-1.49916834  0.52284381 -2.23845444  0.38971957]\n [-1.13811023 -1.43001926  0.10895521  1.35821647]\n [-1.89749741 -0.52782098 -0.35799796  1.29752695]\n [-1.10865307 -1.78448912  0.21785956  2.69650595]]\nCumulative product:  [-1.42382504e+00 -1.79932822e+00  1.56660623e+00 -4.06022405e-01\n  3.05910707e-02 -2.26644548e-02  3.10002759e-02  2.01158559e-02\n  7.26299297e-03 -1.41836307e-02 -3.32947916e-02 -3.22459027e-02\n  2.44871251e-02  2.20922420e-02 -1.03160425e-02  6.26075655e-04\n  4.93876240e-04 -6.20638532e-04 -3.57399363e-04 -4.99994201e-04]\n\n\n\n\nMethods for Boolean Arrays\nWrite code: Generate an array of random numbers, them count the positive numbers and negative numbers.\n\nprint(\"sum() can be used as a way of counting Treu/False values in an Boolean array due to its coerced feature to 1 / 0\")\n\nimport numpy as np\n\n# Get a random number generator\nrng = np.random.default_rng(seed=12345)\narr = rng.standard_normal(50)\nprint(\"Original arr: \", arr)\n\n# Evaluate the array for positive elements\narr_bool = arr &gt; 0\nprint(\"Element eval for positiveness: \", arr_bool)\nprint(\"Count the True's: \", sum(arr_bool))\n\n# Evaluate if any or all of the array is True\nprint(\"Is any element in array True? : \", arr_bool.any())\nprint(\"Are all elemtns in array True?: \", arr_bool.all())\n\nsum() can be used as a way of counting Treu/False values in an Boolean array due to its coerced feature to 1 / 0\nOriginal arr:  [-1.42382504  1.26372846 -0.87066174 -0.25917323 -0.07534331 -0.74088465\n -1.3677927   0.6488928   0.36105811 -1.95286306  2.34740965  0.96849691\n -0.75938718  0.90219827 -0.46695317 -0.06068952  0.78884434 -1.25666813\n  0.57585751  1.39897899  1.32229806 -0.29969852  0.90291934 -1.62158273\n -0.15818926  0.44948393 -1.34360107 -0.08168759  1.72473993  2.61815943\n  0.77736134  0.8286332  -0.95898831 -1.20938829 -1.41229201  0.54154683\n  0.7519394  -0.65876032 -1.22867499  0.25755777  0.31290292 -0.13081169\n  1.26998312 -0.09296246 -0.06615089 -1.10821447  0.13595685  1.34707776\n  0.06114402  0.0709146 ]\nElement eval for positiveness:  [False  True False False False False False  True  True False  True  True\n False  True False False  True False  True  True  True False  True False\n False  True False False  True  True  True  True False False False  True\n  True False False  True  True False  True False False False  True  True\n  True  True]\nCount the True's:  25\nIs any element in array True? :  True\nAre all elemtns in array True?:  False\n\n\n\n\nSorting\nWrite code: Generate an array of random numbers and sort them in place along the columns and rows\n\n# Create a random number generator and an array of random numbers from it.\nrng = np.random.default_rng(seed=12345)\narr = rng.standard_normal(6)\nprint(\"Original array: \", arr)\n\n# sort the array in place\narr.sort()\nprint(\"Array sorted: \", arr)\n\n# Create a 3x3 array and sort them aloing columns and rows\narr = rng.standard_normal((3,3))\nprint(\"Orginal array: \", arr)\narr.sort(axis=0)\nprint(\"Array each column sorted in place: \", arr)\narr.sort(axis=1)\nprint(\"Array each row sorted in place: \", arr)\n\n# Get a copy of sorted array\narr2 = np.array([5, 10, 7, 1, 0, 3])\nsorted_arr2 = np.sort(arr2)\nprint(\"Sorted copy: \", sorted_arr2)\nprint(\"Original: \", arr2)\n\nOriginal array:  [-1.42382504  1.26372846 -0.87066174 -0.25917323 -0.07534331 -0.74088465]\nArray sorted:  [-1.42382504 -0.87066174 -0.74088465 -0.25917323 -0.07534331  1.26372846]\nOrginal array:  [[-1.3677927   0.6488928   0.36105811]\n [-1.95286306  2.34740965  0.96849691]\n [-0.75938718  0.90219827 -0.46695317]]\nArray each column sorted in place:  [[-1.95286306  0.6488928  -0.46695317]\n [-1.3677927   0.90219827  0.36105811]\n [-0.75938718  2.34740965  0.96849691]]\nArray each row sorted in place:  [[-1.95286306 -0.46695317  0.6488928 ]\n [-1.3677927   0.36105811  0.90219827]\n [-0.75938718  0.96849691  2.34740965]]\nSorted copy:  [ 0  1  3  5  7 10]\nOriginal:  [ 5 10  7  1  0  3]\n\n\n\n\nUnique and Other Set Logic\nWrite code: Create a numpy 1-d array with arbitrary names, and create an array with unique elements\n\n# create 1-d array\nnames = np.array([\"Bob\", \"Will\", \"Joe\", \"Bob\", \"Will\", \"Joe\", \"Joe\"])\nprint(\"names: \", names)\n\n# create an array of unique elements\nun = np.unique(names)\nprint(un, type(un)) # numpy.ndarray\n\n# equivalent built-in Python funtino, slower\nun = sorted(set(names))\nprint(un, type(un))  # list\n\n# test membership\nvalues = np.array([6, 0, 0, 3, 2, 5, 6])\ntest_against = [2, 3, 6]\nprint(\"Values: \", values)\nprint(\"Texting membership of each element in values: \", np.in1d(values, test_against))\n\nnames:  ['Bob' 'Will' 'Joe' 'Bob' 'Will' 'Joe' 'Joe']\n['Bob' 'Joe' 'Will'] &lt;class 'numpy.ndarray'&gt;\n['Bob', 'Joe', 'Will'] &lt;class 'list'&gt;\nValues:  [6 0 0 3 2 5 6]\nTexting membership of each element in values:  [ True False False  True  True False  True]\n\n\n\n\nMore Array set operations\n\nunique(x): sorted, unique elemtns in x\nintersect1d(x, y): sorted, common elements\nunion1d(x, y): sorted union of elements\nin1d(x, y): Boolean array of membership of each x in y\nsetdiff1d(x, y): elements that are only in x\nsetxor1d(x, y): elements that are either in x or y, but not in both\n\n\nimport numpy as np\n\n# two arrays for numpy set operations\nx = np.array([1, 2, 3, 4, 4])\ny = np.array([3, 4, 5, 6, 6])\nprint(\"x: \", x)\nprint(\"y: \", y)\nprint(\"unique(x): \", np.unique(x))\nprint(\"intersect1d(x,y):\", np.intersect1d(x,y))\nprint(\"union1d(x,y): \", np.union1d(x,y))\nprint(\"in1d(x,y): \", np.in1d(x,y))\nprint(\"setdiff1d(x,y): \", np.setdiff1d(x,y))\nprint(\"setxor1d(x,y): \", np.setxor1d(x,y))\n\nx:  [1 2 3 4 4]\ny:  [3 4 5 6 6]\nunique(x):  [1 2 3 4]\nintersect1d(x,y): [3 4]\nunion1d(x,y):  [1 2 3 4 5 6]\nin1d(x,y):  [False False  True  True  True]\nsetdiff1d(x,y):  [1 2]\nsetxor1d(x,y):  [1 2 5 6]"
  },
  {
    "objectID": "posts/p4da3d-numpy.html#file-input-and-output-with-arrays",
    "href": "posts/p4da3d-numpy.html#file-input-and-output-with-arrays",
    "title": "[4] Arrays and Vectorized Computation",
    "section": "File Input and Output with Arrays",
    "text": "File Input and Output with Arrays\nNumPy is able to save and load data to and from disk in some text or binary formats.\n\nNumPy built-in binary format\nnumpy.save numpy.load\nWrite code: Create some arrays and save to disk, and load from disk using numpy\n\nimport numpy as np\nimport os\n\narr = np.arange(10)\nprint(arr)\n\n# save\nnp.save(\"some_array\", arr) # save in binary format - some_array.npy\nprint(os.path.basename('./some_array.npy'))\n\n# load\ndata = np.load(\"some_array.npy\")\nprint(data, type(data))\n\n# work with multiple arrays, uncompressed / compressed\n# save\nnp.savez(\"array_archive.npz\", a=arr, b=arr, c=arr) # save three arrays uncompressed\n#np.savez_compressed(\"array_archive.npz\", a=arr, b=arr, c=arr) # save three arrays compressed\nprint(os.path.basename('./array_archive.npz'))\n# load\narch = np.load(\"array_archive.npz\")\nprint(arch)\nprint(arch[\"a\"])\nprint(arch[\"b\"])\nprint(arch[\"c\"])\n\n[0 1 2 3 4 5 6 7 8 9]\nsome_array.npy\n[0 1 2 3 4 5 6 7 8 9] &lt;class 'numpy.ndarray'&gt;\narray_archive.npz\nNpzFile 'array_archive.npz' with keys: a, b, c\n[0 1 2 3 4 5 6 7 8 9]\n[0 1 2 3 4 5 6 7 8 9]\n[0 1 2 3 4 5 6 7 8 9]"
  },
  {
    "objectID": "posts/p4da3d-numpy.html#linear-algebra",
    "href": "posts/p4da3d-numpy.html#linear-algebra",
    "title": "[4] Arrays and Vectorized Computation",
    "section": "Linear Algebra",
    "text": "Linear Algebra\nLinear algebra operations with NumPy - matrix multiplication, decompositions, determinants, other square matrix math\nWrite code: Create two arrays with random numbers and do matrix operations using NumPy\n\n# create arrays\nx = np.array([[1., 2., 3.], [4., 5., 6.]]) # 2x3\ny = np.array([[6., 23.], [-1, 7], [8, 9]]) # 3x2\nprint(\"x: \", x)\nprint(\"y: \", y)\n\n# array multiplication\n# print(x * y) # element-wise product error, different shapes\n\n# 2-d matrix multiplication\nprint(\"Matrix dot product on array: \", x.dot(y)) # 2x3 dot 3x2 -&gt; 2x2 matrix\nprint(\"Matirx dot product using NumPy: \", np.dot(x, y)) # equivalent to the above\n\n\n# 2-d x 1-d array\nprint(x @ np.ones(3)) # using @ symbol (Matrix Multiplication Operator) # 2x3 dot 1-d of (3,)\n\nx:  [[1. 2. 3.]\n [4. 5. 6.]]\ny:  [[ 6. 23.]\n [-1.  7.]\n [ 8.  9.]]\nMatrix dot product on array:  [[ 28.  64.]\n [ 67. 181.]]\nMatirx dot product using NumPy:  [[ 28.  64.]\n [ 67. 181.]]\n[ 6. 15.]\n\n\nWrite code: Create a random 5x5 matrix and run linear algebra functions from numpy.linalg\n\n# Create a random 5x5 matrix\nrng = np.random.default_rng(seed=12345)\narr = rng.standard_normal((5,5))\nprint(\"# Random 5x5 array\")\nprint(arr)\n\n# Get diagonal matrix in 1-d\nprint(\"# Get diagonal matrix in 1-d\")\nprint(np.diag(arr))\n\n# Convert 1-d matrix tp a square matrix with zeros on the off-diagonal\nprint(\"# Convert 1-d matrix tp a square matrix with zeros on the off-diagonal\")\nprint(np.diag(np.diag(arr)))\n\n# Matrix multiplication\nprint(\"# Matrix multiplication\")\nprint(np.dot(arr, arr))\n\n# Compute the matrix determinant\nprint(\"# Compute the matrix determinant\")\nprint(np.linalg.det(arr))\n\n# Compute the inverse of a square matrix\nprint(\"# Compute the inverse of a square matrix\")\nprint(np.linalg.inv(arr))\n\n# Random 5x5 array\n[[-1.42382504  1.26372846 -0.87066174 -0.25917323 -0.07534331]\n [-0.74088465 -1.3677927   0.6488928   0.36105811 -1.95286306]\n [ 2.34740965  0.96849691 -0.75938718  0.90219827 -0.46695317]\n [-0.06068952  0.78884434 -1.25666813  0.57585751  1.39897899]\n [ 1.32229806 -0.29969852  0.90291934 -1.62158273 -0.15818926]]\n# Get diagonal matrix in 1-d\n[-1.42382504 -1.3677927  -0.75938718  0.57585751 -0.15818926]\n# Convert 1-d matrix tp a square matrix with zeros on the off-diagonal\n[[-1.42382504  0.          0.          0.          0.        ]\n [ 0.         -1.3677927   0.          0.          0.        ]\n [ 0.          0.         -0.75938718  0.          0.        ]\n [ 0.          0.          0.          0.57585751  0.        ]\n [ 0.          0.          0.          0.         -0.15818926]]\n# Matrix multiplication\n[[-1.03669626 -4.55294704  2.97852946  0.01271579 -2.30471409]\n [ 0.98730448  2.43311934 -2.95225985  3.65824184  3.23796467]\n [-6.51464318  1.75796043 -2.39406508  0.33292097 -0.37758177]\n [-1.63302762 -2.33775979  2.05851653 -2.77016438 -0.36481815]\n [ 0.34808225  1.72365844 -0.13645271 -0.3135842  -2.17951354]]\n# Compute the matrix determinant\n-11.335264065758818\n# Compute the inverse of a square matrix\n[[-0.16403331  0.05319637  0.22318788  0.16488555  0.22079067]\n [ 0.31512456 -0.85623041  0.19880833 -1.17377785 -0.5472339 ]\n [-0.29807133 -1.17254064 -0.09117927 -1.78479938 -0.89798385]\n [-0.32695068 -0.4123963   0.11716846 -0.64698576 -0.82081818]\n [-0.31797409 -0.3983991  -0.23255394  0.0468956  -0.15061793]]"
  },
  {
    "objectID": "posts/p4da3d-numpy.html#example-random-walks",
    "href": "posts/p4da3d-numpy.html#example-random-walks",
    "title": "[4] Arrays and Vectorized Computation",
    "section": "Example Random Walks",
    "text": "Example Random Walks\nIllustrate an application of utilizing array operations - Random Walks, simple random walk starting at 0 with steps of 1 and -1 occurring with equal probability.\nPure Python implementation\n\nimport random\n\nposition = 0\nwalk = [position]\nnsteps = 1000\nfor _ in range(nsteps):\n  step = 1 if random.randint(0, 1) else -1\n  position += step\n  walk.append(position)\n\nprint(walk)\n\n# plot\nplt.clf() # clear any previous figure\nplt.plot(walk[:100]) # positions for first 100 steps\nplt.show()\n\n[0, -1, -2, -3, -2, -1, -2, -3, -2, -1, 0, 1, 2, 3, 4, 3, 4, 5, 6, 5, 4, 3, 4, 3, 2, 1, 0, 1, 2, 3, 2, 3, 2, 3, 4, 3, 2, 3, 4, 3, 2, 3, 4, 3, 2, 3, 2, 3, 2, 3, 4, 5, 6, 7, 8, 7, 8, 9, 8, 9, 10, 11, 10, 9, 10, 11, 10, 11, 10, 9, 8, 9, 8, 9, 10, 11, 10, 11, 10, 9, 8, 7, 6, 5, 4, 5, 4, 3, 4, 3, 2, 1, 2, 3, 2, 3, 2, 1, 0, -1, -2, -3, -4, -3, -4, -5, -6, -5, -6, -7, -8, -7, -8, -9, -10, -11, -12, -13, -14, -13, -12, -13, -12, -13, -14, -15, -14, -13, -12, -11, -10, -9, -10, -9, -8, -9, -8, -7, -8, -7, -8, -7, -6, -7, -8, -9, -10, -11, -12, -13, -14, -13, -14, -13, -12, -13, -12, -13, -14, -13, -14, -13, -12, -13, -14, -13, -14, -13, -12, -13, -14, -15, -14, -15, -16, -17, -16, -15, -14, -15, -14, -15, -14, -13, -14, -15, -16, -17, -18, -19, -20, -19, -18, -19, -20, -21, -20, -21, -20, -19, -18, -17, -18, -17, -16, -15, -16, -15, -14, -13, -14, -15, -14, -15, -16, -17, -16, -17, -16, -17, -16, -15, -14, -13, -14, -13, -14, -13, -12, -11, -12, -13, -14, -15, -14, -13, -14, -13, -12, -11, -10, -11, -12, -11, -12, -11, -12, -11, -12, -11, -10, -11, -10, -11, -12, -11, -12, -11, -12, -11, -12, -13, -14, -15, -14, -13, -12, -13, -14, -13, -14, -15, -16, -17, -18, -19, -20, -21, -22, -23, -24, -23, -22, -21, -20, -21, -22, -23, -24, -25, -24, -23, -24, -25, -26, -27, -28, -27, -28, -27, -28, -27, -26, -25, -24, -25, -24, -23, -22, -21, -22, -23, -24, -23, -24, -23, -24, -25, -24, -23, -22, -23, -24, -23, -24, -25, -24, -23, -24, -23, -24, -25, -26, -27, -28, -27, -26, -27, -26, -25, -26, -25, -24, -23, -24, -23, -22, -23, -24, -25, -26, -25, -24, -23, -24, -25, -24, -23, -22, -21, -20, -21, -20, -19, -18, -17, -16, -17, -18, -19, -18, -17, -18, -19, -20, -21, -20, -21, -22, -21, -22, -23, -24, -23, -24, -23, -24, -25, -24, -25, -24, -23, -22, -21, -20, -21, -20, -19, -18, -19, -20, -19, -18, -17, -16, -15, -16, -15, -14, -15, -16, -17, -16, -15, -16, -17, -16, -17, -16, -17, -18, -19, -20, -19, -20, -19, -18, -19, -18, -19, -18, -17, -16, -15, -16, -15, -16, -15, -16, -17, -18, -19, -18, -19, -18, -19, -20, -19, -18, -17, -16, -17, -16, -17, -16, -17, -16, -17, -18, -17, -16, -17, -16, -15, -14, -15, -16, -15, -14, -13, -14, -15, -16, -17, -18, -19, -20, -19, -18, -17, -16, -17, -16, -15, -14, -13, -12, -13, -12, -11, -10, -11, -12, -11, -10, -9, -10, -11, -12, -13, -12, -11, -10, -11, -10, -9, -8, -7, -6, -7, -6, -5, -4, -3, -4, -5, -4, -3, -4, -5, -6, -7, -8, -7, -6, -5, -4, -3, -4, -3, -4, -3, -2, -3, -2, -1, 0, -1, 0, 1, 0, -1, 0, -1, -2, -1, -2, -3, -2, -3, -2, -1, 0, 1, 2, 1, 2, 1, 2, 3, 4, 5, 6, 5, 6, 7, 8, 7, 8, 7, 8, 7, 8, 9, 10, 11, 10, 11, 12, 11, 12, 11, 10, 11, 10, 9, 8, 7, 8, 9, 10, 11, 12, 11, 12, 13, 12, 13, 12, 11, 12, 13, 14, 13, 14, 13, 14, 13, 14, 15, 16, 17, 16, 15, 16, 15, 14, 13, 12, 11, 12, 11, 10, 9, 8, 9, 10, 11, 10, 11, 10, 9, 8, 7, 6, 7, 6, 7, 8, 9, 8, 9, 8, 9, 10, 9, 10, 11, 10, 9, 8, 7, 8, 9, 8, 9, 8, 9, 10, 11, 12, 13, 12, 11, 10, 11, 10, 11, 10, 9, 8, 9, 8, 7, 6, 7, 8, 7, 8, 7, 8, 9, 8, 7, 8, 9, 10, 9, 8, 9, 10, 9, 10, 11, 12, 13, 12, 11, 12, 13, 12, 13, 14, 15, 14, 13, 14, 15, 16, 17, 16, 15, 14, 15, 14, 13, 14, 13, 12, 11, 10, 9, 8, 9, 8, 7, 6, 5, 6, 7, 6, 7, 6, 7, 6, 5, 6, 5, 6, 5, 4, 5, 4, 5, 6, 7, 8, 9, 8, 7, 6, 5, 6, 5, 4, 3, 2, 1, 0, 1, 2, 1, 2, 3, 4, 5, 6, 5, 4, 3, 4, 3, 2, 1, 0, -1, -2, -1, -2, -1, -2, -3, -2, -3, -2, -3, -2, -3, -2, -3, -2, -3, -4, -3, -2, -3, -2, -3, -2, -3, -2, -3, -2, -3, -4, -3, -4, -3, -4, -3, -4, -5, -4, -5, -4, -5, -6, -5, -6, -5, -6, -7, -6, -7, -8, -7, -8, -7, -6, -5, -6, -7, -6, -5, -6, -5, -4, -5, -4, -5, -4, -3, -4, -3, -4, -5, -4, -3, -2, -1, -2, -1, 0, 1, 0, -1, -2, -3, -4, -3, -4, -5, -4, -5, -4, -5, -6, -7, -6, -7, -6, -5, -6, -7, -8, -7, -6, -5, -4, -3, -4, -5, -6, -7, -6, -5, -4, -5, -4, -3, -2, -3, -4, -3, -4, -5, -4, -5, -6, -7, -8, -7, -6, -5, -6, -5, -6, -5, -4, -5, -4, -3, -4, -5, -4, -5, -4, -5, -4, -5, -6, -7, -6, -7, -8, -7, -8, -9, -10, -11, -10, -9, -10, -11, -10, -11, -12, -13, -12, -13, -12, -11, -12, -13, -12, -13, -12, -11, -12, -13, -14, -15, -16, -15, -16, -17, -18, -19, -18, -19, -20, -21, -22, -21, -22, -23, -22, -21, -22, -21, -22, -23, -22, -21, -20, -21, -22, -21, -22, -23, -24, -23, -24, -23, -22, -23, -24, -23, -22, -23, -22, -21, -20, -21, -20, -19, -18, -19, -20, -19, -18]\n\n\n\n\n\n\nnsteps = 1000\nrng = np.random.default_rng(seed=12345)\ndraws = rng.integers(0, 2, size=nsteps) # sequence of 0 or 1, 1000 numbers\nprint(draws)\nsteps = np.where(draws == 0, 1, -1) # numpy ternary expression to generate sequence of step direction\nprint(steps)\nwalk = steps.cumsum() # walk is the result of cumulative sum of steps\nprint(walk)\n\n# plot the walk\nplt.clf()\nplt.plot(walk[:]) # all steps of walk\nplt.show()\n\n[1 0 1 0 0 1 1 1 1 0 1 0 1 1 0 0 0 1 1 1 1 0 1 1 1 1 0 0 0 0 0 1 0 1 0 0 0\n 1 1 0 1 0 0 0 1 0 0 0 0 0 1 1 0 0 0 0 0 0 0 1 1 1 1 1 0 1 1 1 1 1 1 1 1 1\n 0 1 1 0 0 0 1 0 1 1 1 0 1 1 0 0 0 0 1 0 1 0 0 0 0 1 0 0 1 0 1 1 0 0 0 0 1\n 0 1 0 1 0 1 0 0 0 1 0 0 0 1 0 1 0 1 0 1 0 1 0 1 0 1 1 0 0 0 1 1 0 0 1 0 1\n 1 0 1 1 0 0 0 0 0 1 1 1 0 1 0 0 1 0 1 1 1 0 1 1 1 0 0 1 1 0 1 0 0 0 0 0 1\n 1 1 1 1 0 1 0 0 0 1 1 0 0 0 0 0 0 0 0 1 1 0 0 0 1 1 0 0 1 0 0 0 0 0 0 0 0\n 0 0 0 1 1 1 0 0 1 1 1 0 1 1 0 1 1 0 1 0 1 0 1 0 1 1 0 0 1 0 0 1 0 0 0 0 1\n 0 1 1 0 1 1 1 0 0 0 1 0 0 0 1 0 1 0 1 0 1 1 0 1 0 1 1 0 1 0 0 1 0 1 1 1 0\n 1 0 1 1 1 1 0 1 1 0 1 0 0 1 1 0 1 0 0 0 0 0 1 1 1 1 0 1 0 1 0 1 0 1 0 0 0\n 1 1 1 1 1 1 1 0 1 1 1 1 1 0 1 1 0 0 0 1 0 1 1 0 0 1 1 1 0 0 0 0 0 1 1 0 0\n 1 0 0 1 1 1 0 0 0 0 1 1 1 0 0 1 1 1 0 0 0 0 1 0 1 0 0 1 1 0 0 1 1 0 0 0 1\n 0 1 1 1 0 0 0 1 0 1 1 0 1 0 0 1 0 1 0 1 0 1 0 1 0 1 0 1 1 1 1 0 0 0 0 1 0\n 1 1 0 1 1 1 1 1 0 1 1 1 0 0 1 0 0 0 1 1 0 1 0 0 0 1 0 1 0 0 0 0 1 1 1 1 0\n 1 1 1 1 1 0 1 1 1 1 0 0 0 0 1 0 0 1 1 1 0 0 0 0 0 0 1 0 0 1 0 0 0 1 1 0 1\n 0 1 1 0 1 1 1 0 0 1 0 1 0 0 1 1 0 0 1 0 1 1 1 0 0 1 1 0 1 1 0 0 1 0 1 0 0\n 0 0 0 0 0 0 0 0 1 0 1 1 1 1 1 1 1 0 1 1 0 0 0 1 0 0 1 1 0 0 0 0 1 0 1 0 1\n 0 0 1 0 0 0 1 1 0 0 1 1 1 0 0 1 1 0 0 0 1 0 0 1 0 1 0 0 0 0 1 1 0 1 1 1 1\n 1 1 1 1 1 0 0 0 0 0 0 1 0 1 0 1 0 1 0 1 0 1 0 0 1 1 0 0 1 1 0 1 1 0 0 1 1\n 0 0 0 0 1 0 1 0 0 1 0 0 1 0 1 1 1 0 1 1 1 1 1 0 0 0 1 0 0 1 0 1 0 0 0 1 0\n 0 0 0 1 0 0 0 0 1 0 0 1 1 0 0 1 1 0 0 0 1 0 1 0 0 0 0 0 0 0 1 0 0 1 1 0 1\n 1 0 0 1 1 0 1 0 1 1 0 1 1 1 0 0 1 0 1 0 0 0 1 0 0 0 0 1 0 0 1 0 1 1 0 1 1\n 1 1 0 1 1 1 0 1 0 0 1 0 1 0 0 0 0 1 1 1 0 0 0 1 1 0 1 1 0 1 1 1 0 1 1 0 0\n 1 1 0 1 0 1 1 0 1 1 1 0 1 0 0 0 0 1 1 0 0 0 0 0 0 0 0 1 1 0 0 0 1 0 0 0 1\n 1 1 1 1 1 0 1 0 0 1 1 1 0 0 1 0 0 1 1 1 1 0 0 0 0 0 0 1 0 1 1 1 0 0 1 0 0\n 1 0 0 1 1 1 0 1 0 0 0 1 0 1 1 0 0 0 1 0 1 1 1 0 0 1 1 1 0 0 1 1 0 1 1 1 0\n 0 1 0 0 1 1 0 1 0 1 0 0 0 0 1 1 1 1 1 0 0 0 1 0 0 1 1 1 1 1 0 0 0 0 0 1 0\n 1 1 1 1 0 0 0 1 0 0 0 0 0 1 1 1 0 0 1 1 0 0 0 0 1 0 0 1 0 0 1 1 1 0 1 0 1\n 1]\n[-1  1 -1  1  1 -1 -1 -1 -1  1 -1  1 -1 -1  1  1  1 -1 -1 -1 -1  1 -1 -1\n -1 -1  1  1  1  1  1 -1  1 -1  1  1  1 -1 -1  1 -1  1  1  1 -1  1  1  1\n  1  1 -1 -1  1  1  1  1  1  1  1 -1 -1 -1 -1 -1  1 -1 -1 -1 -1 -1 -1 -1\n -1 -1  1 -1 -1  1  1  1 -1  1 -1 -1 -1  1 -1 -1  1  1  1  1 -1  1 -1  1\n  1  1  1 -1  1  1 -1  1 -1 -1  1  1  1  1 -1  1 -1  1 -1  1 -1  1  1  1\n -1  1  1  1 -1  1 -1  1 -1  1 -1  1 -1  1 -1  1 -1 -1  1  1  1 -1 -1  1\n  1 -1  1 -1 -1  1 -1 -1  1  1  1  1  1 -1 -1 -1  1 -1  1  1 -1  1 -1 -1\n -1  1 -1 -1 -1  1  1 -1 -1  1 -1  1  1  1  1  1 -1 -1 -1 -1 -1  1 -1  1\n  1  1 -1 -1  1  1  1  1  1  1  1  1 -1 -1  1  1  1 -1 -1  1  1 -1  1  1\n  1  1  1  1  1  1  1  1  1 -1 -1 -1  1  1 -1 -1 -1  1 -1 -1  1 -1 -1  1\n -1  1 -1  1 -1  1 -1 -1  1  1 -1  1  1 -1  1  1  1  1 -1  1 -1 -1  1 -1\n -1 -1  1  1  1 -1  1  1  1 -1  1 -1  1 -1  1 -1 -1  1 -1  1 -1 -1  1 -1\n  1  1 -1  1 -1 -1 -1  1 -1  1 -1 -1 -1 -1  1 -1 -1  1 -1  1  1 -1 -1  1\n -1  1  1  1  1  1 -1 -1 -1 -1  1 -1  1 -1  1 -1  1 -1  1  1  1 -1 -1 -1\n -1 -1 -1 -1  1 -1 -1 -1 -1 -1  1 -1 -1  1  1  1 -1  1 -1 -1  1  1 -1 -1\n -1  1  1  1  1  1 -1 -1  1  1 -1  1  1 -1 -1 -1  1  1  1  1 -1 -1 -1  1\n  1 -1 -1 -1  1  1  1  1 -1  1 -1  1  1 -1 -1  1  1 -1 -1  1  1  1 -1  1\n -1 -1 -1  1  1  1 -1  1 -1 -1  1 -1  1  1 -1  1 -1  1 -1  1 -1  1 -1  1\n -1  1 -1 -1 -1 -1  1  1  1  1 -1  1 -1 -1  1 -1 -1 -1 -1 -1  1 -1 -1 -1\n  1  1 -1  1  1  1 -1 -1  1 -1  1  1  1 -1  1 -1  1  1  1  1 -1 -1 -1 -1\n  1 -1 -1 -1 -1 -1  1 -1 -1 -1 -1  1  1  1  1 -1  1  1 -1 -1 -1  1  1  1\n  1  1  1 -1  1  1 -1  1  1  1 -1 -1  1 -1  1 -1 -1  1 -1 -1 -1  1  1 -1\n  1 -1  1  1 -1 -1  1  1 -1  1 -1 -1 -1  1  1 -1 -1  1 -1 -1  1  1 -1  1\n -1  1  1  1  1  1  1  1  1  1  1 -1  1 -1 -1 -1 -1 -1 -1 -1  1 -1 -1  1\n  1  1 -1  1  1 -1 -1  1  1  1  1 -1  1 -1  1 -1  1  1 -1  1  1  1 -1 -1\n  1  1 -1 -1 -1  1  1 -1 -1  1  1  1 -1  1  1 -1  1 -1  1  1  1  1 -1 -1\n  1 -1 -1 -1 -1 -1 -1 -1 -1 -1  1  1  1  1  1  1 -1  1 -1  1 -1  1 -1  1\n -1  1 -1  1  1 -1 -1  1  1 -1 -1  1 -1 -1  1  1 -1 -1  1  1  1  1 -1  1\n -1  1  1 -1  1  1 -1  1 -1 -1 -1  1 -1 -1 -1 -1 -1  1  1  1 -1  1  1 -1\n  1 -1  1  1  1 -1  1  1  1  1 -1  1  1  1  1 -1  1  1 -1 -1  1  1 -1 -1\n  1  1  1 -1  1 -1  1  1  1  1  1  1  1 -1  1  1 -1 -1  1 -1 -1  1  1 -1\n -1  1 -1  1 -1 -1  1 -1 -1 -1  1  1 -1  1 -1  1  1  1 -1  1  1  1  1 -1\n  1  1 -1  1 -1 -1  1 -1 -1 -1 -1  1 -1 -1 -1  1 -1  1  1 -1  1 -1  1  1\n  1  1 -1 -1 -1  1  1  1 -1 -1  1 -1 -1  1 -1 -1 -1  1 -1 -1  1  1 -1 -1\n  1 -1  1 -1 -1  1 -1 -1 -1  1 -1  1  1  1  1 -1 -1  1  1  1  1  1  1  1\n  1 -1 -1  1  1  1 -1  1  1  1 -1 -1 -1 -1 -1 -1  1 -1  1  1 -1 -1 -1  1\n  1 -1  1  1 -1 -1 -1 -1  1  1  1  1  1  1 -1  1 -1 -1 -1  1  1 -1  1  1\n -1  1  1 -1 -1 -1  1 -1  1  1  1 -1  1 -1 -1  1  1  1 -1  1 -1 -1 -1  1\n  1 -1 -1 -1  1  1 -1 -1  1 -1 -1 -1  1  1 -1  1  1 -1 -1  1 -1  1 -1  1\n  1  1  1 -1 -1 -1 -1 -1  1  1  1 -1  1  1 -1 -1 -1 -1 -1  1  1  1  1  1\n -1  1 -1 -1 -1 -1  1  1  1 -1  1  1  1  1  1 -1 -1 -1  1  1 -1 -1  1  1\n  1  1 -1  1  1 -1  1  1 -1 -1 -1  1 -1  1 -1 -1]\n[-1  0 -1  0  1  0 -1 -2 -3 -2 -3 -2 -3 -4 -3 -2 -1 -2 -3 -4 -5 -4 -5 -6\n -7 -8 -7 -6 -5 -4 -3 -4 -3 -4 -3 -2 -1 -2 -3 -2 -3 -2 -1  0 -1  0  1  2\n  3  4  3  2  3  4  5  6  7  8  9  8  7  6  5  4  5  4  3  2  1  0 -1 -2\n -3 -4 -3 -4 -5 -4 -3 -2 -3 -2 -3 -4 -5 -4 -5 -6 -5 -4 -3 -2 -3 -2 -3 -2\n -1  0  1  0  1  2  1  2  1  0  1  2  3  4  3  4  3  4  3  4  3  4  5  6\n  5  6  7  8  7  8  7  8  7  8  7  8  7  8  7  8  7  6  7  8  9  8  7  8\n  9  8  9  8  7  8  7  6  7  8  9 10 11 10  9  8  9  8  9 10  9 10  9  8\n  7  8  7  6  5  6  7  6  5  6  5  6  7  8  9 10  9  8  7  6  5  6  5  6\n  7  8  7  6  7  8  9 10 11 12 13 14 13 12 13 14 15 14 13 14 15 14 15 16\n 17 18 19 20 21 22 23 24 25 24 23 22 23 24 23 22 21 22 21 20 21 20 19 20\n 19 20 19 20 19 20 19 18 19 20 19 20 21 20 21 22 23 24 23 24 23 22 23 22\n 21 20 21 22 23 22 23 24 25 24 25 24 25 24 25 24 23 24 23 24 23 22 23 22\n 23 24 23 24 23 22 21 22 21 22 21 20 19 18 19 18 17 18 17 18 19 18 17 18\n 17 18 19 20 21 22 21 20 19 18 19 18 19 18 19 18 19 18 19 20 21 20 19 18\n 17 16 15 14 15 14 13 12 11 10 11 10  9 10 11 12 11 12 11 10 11 12 11 10\n  9 10 11 12 13 14 13 12 13 14 13 14 15 14 13 12 13 14 15 16 15 14 13 14\n 15 14 13 12 13 14 15 16 15 16 15 16 17 16 15 16 17 16 15 16 17 18 17 18\n 17 16 15 16 17 18 17 18 17 16 17 16 17 18 17 18 17 18 17 18 17 18 17 18\n 17 18 17 16 15 14 15 16 17 18 17 18 17 16 17 16 15 14 13 12 13 12 11 10\n 11 12 11 12 13 14 13 12 13 12 13 14 15 14 15 14 15 16 17 18 17 16 15 14\n 15 14 13 12 11 10 11 10  9  8  7  8  9 10 11 10 11 12 11 10  9 10 11 12\n 13 14 15 14 15 16 15 16 17 18 17 16 17 16 17 16 15 16 15 14 13 14 15 14\n 15 14 15 16 15 14 15 16 15 16 15 14 13 14 15 14 13 14 13 12 13 14 13 14\n 13 14 15 16 17 18 19 20 21 22 23 22 23 22 21 20 19 18 17 16 17 16 15 16\n 17 18 17 18 19 18 17 18 19 20 21 20 21 20 21 20 21 22 21 22 23 24 23 22\n 23 24 23 22 21 22 23 22 21 22 23 24 23 24 25 24 25 24 25 26 27 28 27 26\n 27 26 25 24 23 22 21 20 19 18 19 20 21 22 23 24 23 24 23 24 23 24 23 24\n 23 24 23 24 25 24 23 24 25 24 23 24 23 22 23 24 23 22 23 24 25 26 25 26\n 25 26 27 26 27 28 27 28 27 26 25 26 25 24 23 22 21 22 23 24 23 24 25 24\n 25 24 25 26 27 26 27 28 29 30 29 30 31 32 33 32 33 34 33 32 33 34 33 32\n 33 34 35 34 35 34 35 36 37 38 39 40 41 40 41 42 41 40 41 40 39 40 41 40\n 39 40 39 40 39 38 39 38 37 36 37 38 37 38 37 38 39 40 39 40 41 42 43 42\n 43 44 43 44 43 42 43 42 41 40 39 40 39 38 37 38 37 38 39 38 39 38 39 40\n 41 42 41 40 39 40 41 42 41 40 41 40 39 40 39 38 37 38 37 36 37 38 37 36\n 37 36 37 36 35 36 35 34 33 34 33 34 35 36 37 36 35 36 37 38 39 40 41 42\n 43 42 41 42 43 44 43 44 45 46 45 44 43 42 41 40 41 40 41 42 41 40 39 40\n 41 40 41 42 41 40 39 38 39 40 41 42 43 44 43 44 43 42 41 42 43 42 43 44\n 43 44 45 44 43 42 43 42 43 44 45 44 45 44 43 44 45 46 45 46 45 44 43 44\n 45 44 43 42 43 44 43 42 43 42 41 40 41 42 41 42 43 42 41 42 41 42 41 42\n 43 44 45 44 43 42 41 40 41 42 43 42 43 44 43 42 41 40 39 40 41 42 43 44\n 43 44 43 42 41 40 41 42 43 42 43 44 45 46 47 46 45 44 45 46 45 44 45 46\n 47 48 47 48 49 48 49 50 49 48 47 48 47 48 47 46]"
  },
  {
    "objectID": "posts/p4da3d-numpy.html",
    "href": "posts/p4da3d-numpy.html",
    "title": "[4] Arrays and Vectorized Computation",
    "section": "",
    "text": "NumPy is a fundamental Python library for numerical and scientific computing. It provides support for working with large, multi-dimensional arrays and matrices, along with a vast collection of mathematical functions to operate on these arrays. Here’s a must-know summary of NumPy:\nNumPy is the foundation of many scientific and data science libraries in Python and is an essential tool for tasks such as data manipulation, statistical analysis, machine learning, and more. Its ease of use and performance make it a go-to choice for researchers, scientists, engineers, and data analysts working with numerical data in Python.\nIdea of performance difference\n# NumPy array of one-million integers vs Python list\n\nimport numpy as np\nimport timeit\n\nmy_arr = np.arange(1_000_000)\nmy_list = list(range(1_000_000))\n# time it\nexecution_time = timeit.timeit(lambda: my_arr * 2, number=10)\nprint(f\"np array multiplication: {execution_time}\")\n\nexecution_time = timeit.timeit(lambda: [ x*2 for x in my_list * 2 ], number=10)\nprint(f\"Python list element multiplication: {execution_time}\")\n\nnp array multiplication: 0.008902800007490441\nPython list element multiplication: 1.2835534999903757"
  },
  {
    "objectID": "posts/p4da3d-numpy.html#the-numpy-ndarray-a-multidimensional-array-object",
    "href": "posts/p4da3d-numpy.html#the-numpy-ndarray-a-multidimensional-array-object",
    "title": "[4] Arrays and Vectorized Computation",
    "section": "The NumPy ndarray: A Multidimensional Array Object",
    "text": "The NumPy ndarray: A Multidimensional Array Object\nBatch computation\n\nimport numpy as np\n\ndata = np.array([\n  [1.5, -0.1, 3], \n  [0, -3, 6.5],\n  [2, 7, 9.9],\n  [23, 9, 21]\n])\nprint(\"data: \", data)\n\n# math operations with the ndarray\nprint(\"data * 10: \", data * 10)\nprint(\"data + data: \", data + data)\n\ndata:  [[ 1.5 -0.1  3. ]\n [ 0.  -3.   6.5]\n [ 2.   7.   9.9]\n [23.   9.  21. ]]\ndata * 10:  [[ 15.  -1.  30.]\n [  0. -30.  65.]\n [ 20.  70.  99.]\n [230.  90. 210.]]\ndata + data:  [[ 3.  -0.2  6. ]\n [ 0.  -6.  13. ]\n [ 4.  14.  19.8]\n [46.  18.  42. ]]\n\n\n\n# shape and type\nprint(data.shape)  # tuple 4R x 3C\nprint(data.dtype)  # ndarray is for homogeneous data\n\n(4, 3)\nfloat64\n\n\n\nCreating ndarrays\n\n# ndarray creation\n\n# np.array()\ndata1 = [6, 7.5, 8, 0, 1] # any sequence-like object\narr1 = np.array(data1)\nprint(arr1)\n\ndata2 = [[1, 2, 3, 4], [5, 6, 7, 8]] # list of equal length array\narr2 = np.array(data2)\nprint(arr2)\nprint(arr2.shape)\nprint(arr2.dtype)\n\n# np.zeros() / np.empty()\nprint(np.zeros(10))\nprint(np.zeros((3, 6)))\nprint(np.zeros((2, 3, 5)))\nprint(np.empty(((2, 3, 2)))) # uninitialized meory with garbage data\n\n# np.arange()\nprint(np.arange(15))\n\n[6.  7.5 8.  0.  1. ]\n[[1 2 3 4]\n [5 6 7 8]]\n(2, 4)\nint32\n[0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]\n[[0. 0. 0. 0. 0. 0.]\n [0. 0. 0. 0. 0. 0.]\n [0. 0. 0. 0. 0. 0.]]\n[[[0. 0. 0. 0. 0.]\n  [0. 0. 0. 0. 0.]\n  [0. 0. 0. 0. 0.]]\n\n [[0. 0. 0. 0. 0.]\n  [0. 0. 0. 0. 0.]\n  [0. 0. 0. 0. 0.]]]\n[[[ 3.  -0.2]\n  [ 6.   0. ]\n  [-6.  13. ]]\n\n [[ 4.  14. ]\n  [19.8 46. ]\n  [18.  42. ]]]\n[ 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14]\n\n\nSome important NumPy array creation functions from Python for Data Analysis 3E by Wes Mckinney\n\n\nData types for ndarrays - dtype\n\n# dtype\narr1 = np.array([1, 2, 3], dtype=np.float64)\narr2 = np.array([1, 2, 3], dtype=np.int32)\nprint(arr1, arr1.dtype)\nprint(arr2, arr2.dtype)\n\n[1. 2. 3.] float64\n[1 2 3] int32\n\n\n\n# type casting - astype()\narr_float = np.array([3.7, -1.2, -2.6, 0.5, 12.9, 10.1])\nprint(arr_float)\narr_int = arr_float.astype(np.int32)  # decimal truncated\nprint(arr_int)\nnumeric_strings = np.array([\"1.25\", \"-9.6\", \"42\"], dtype=np.string_)\nprint(numeric_strings)\nnumeric_from_strings = numeric_strings.astype(float) # ValueError when fails\nprint(numeric_from_strings)\n# conver to the other array's type\nint_array = np.arange(10)\ncalibers = np.array([.22, .270, .357, .380, .44, .50], dtype=np.float64)\nprint(int_array.astype(calibers.dtype))\n\n[ 3.7 -1.2 -2.6  0.5 12.9 10.1]\n[ 3 -1 -2  0 12 10]\n[b'1.25' b'-9.6' b'42']\n[ 1.25 -9.6  42.  ]\n[0. 1. 2. 3. 4. 5. 6. 7. 8. 9.]\n\n\n\n\nArithmetic with NumPy Arrays\n\n# arrays in shame shape\nprint(\"\\nArrays in shame shape\\n\")\narr = np.array([[1., 2., 3.], [4., 5., 6.]])\nprint(arr)\nprint(arr * arr) # element-wise multiplication\n# print(arr * [10, 200]) # broadcast error, not in same shape\nprint(arr - arr) # element-wies subraction\n\n# array with salar\nprint(\"\\nArray with salar\\n\")\nprint(1 / arr) # applied with each element\nprint(arr ** 2)  \n\n# array comparison\nprint(\"\\nArray comparison\\n\")\narr2 = np.array([[0., 4., 1.], [7., 2., 12.]])\nprint(arr2)\narr_bool = arr &lt; arr2  # element-wise boolean evaluation\nprint(arr_bool)\nif arr_bool.all():\n  print(\"Two arrays are same.\") \nelse:\n  print(\"Two arrays are different.\")\n\n\nArrays in shame shape\n\n[[1. 2. 3.]\n [4. 5. 6.]]\n[[ 1.  4.  9.]\n [16. 25. 36.]]\n[[0. 0. 0.]\n [0. 0. 0.]]\n\nArray with salar\n\n[[1.         0.5        0.33333333]\n [0.25       0.2        0.16666667]]\n[[ 1.  4.  9.]\n [16. 25. 36.]]\n\nArray comparison\n\n[[ 0.  4.  1.]\n [ 7.  2. 12.]]\n[[False  True False]\n [ True False  True]]\nTwo arrays are different.\n\n\n\n\nBasic Indexing and Slicing\n\n# Similar to Python lists\nprint(\"\\nSimilar to Python lists...\\n\")\narr = np.arange(10)\nprint(arr)\nprint(arr[5]) # element accessing\nprint(arr[5:8]) # slicing\narr[5:8] = 99 # assignment changes broadcasts the new valjue, relfected to the original array - value propagation / broadcast\nprint(arr)\narr_slice = arr[5:8] # check broadcasted value\nprint(arr_slice)\narr_slice[1] = 12345 # value propagation to the original\nprint(arr)\n\n# Assignment to all values - bare slice [:]\nprint(\"\\nAssignment to all values - bare slice [:]...\\n\")\narr_slice[:] = 64\nprint(arr)  # value propagation to the original \n\n# 2d array, each index of 1-d array, not scalar\nprint(\"\\n2d array, each index of 1-d array, not scalar...\\n\")\narr2d = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\nprint(arr2d)\nprint(arr2d[2], type(arr2d[2]))\nprint(arr2d[0][2]) # accessing individual element\n\n# Axis in 2-d array\nprint(\"\\narr(r, c) - Axis0 (row), Axis1 (col) in 2-d array...\\n\")\nprint(arr2d[0, 2]) # same as above\n\n\nSimilar to Python lists...\n\n[0 1 2 3 4 5 6 7 8 9]\n5\n[5 6 7]\n[ 0  1  2  3  4 99 99 99  8  9]\n[99 99 99]\n[    0     1     2     3     4    99 12345    99     8     9]\n\nAssignment to all values - bare slice [:]...\n\n[ 0  1  2  3  4 64 64 64  8  9]\n\n2d array, each index of 1-d array, not scalar...\n\n[[1 2 3]\n [4 5 6]\n [7 8 9]]\n[7 8 9] &lt;class 'numpy.ndarray'&gt;\n3\n\narr(r, c) - Axis0 (row), Axis1 (col) in 2-d array...\n\n3\n\n\n\n# 3-d -&gt; 2-d -&gt; 1-d \narr3d = np.array([[[1, 2, 3], [4, 5, 6]], [[7, 8, 9], [10, 11, 12]]])\nprint(\"arr3d: \", arr3d)\nprint(arr3d.shape)\nprint(arr3d[0]) # arr3d[0] 2x3 array, first row\nold_values = arr3d[0].copy() # save to variable\nprint(old_values)\narr3d[0] = 99 # change with scalar, broadcasting to the whole 2x3\nprint(arr3d)\narr3d[0] = old_values # change with array\nprint(arr3d)\nprint(\"arr3d[1, 0]: \", arr3d[1, 0])\n\narr3d:  [[[ 1  2  3]\n  [ 4  5  6]]\n\n [[ 7  8  9]\n  [10 11 12]]]\n(2, 2, 3)\n[[1 2 3]\n [4 5 6]]\n[[1 2 3]\n [4 5 6]]\n[[[99 99 99]\n  [99 99 99]]\n\n [[ 7  8  9]\n  [10 11 12]]]\n[[[ 1  2  3]\n  [ 4  5  6]]\n\n [[ 7  8  9]\n  [10 11 12]]]\narr3d[1, 0]:  [7 8 9]\n\n\n\n# Indexing with slices\n\nprint(\"arr: \", arr)\nprint(\"arr[1:6]: \", arr[1:6]) # 1-d array\nprint(\"arr2d: \", arr2d)\nprint(\"arr2d[:2]: \", arr2d[:2]) # 2-d array, slicing rows\nprint(\"arr2d[:2, 1:]: \",arr2d[:2, 1:] ) # 2-d array, slicing rows and columns\n\n# select the second row, and first two cols.\nlower_dim_slice = arr2d[1, :2]  # slicing 1-d array\nprint(lower_dim_slice)\nprint(lower_dim_slice.shape)\n\n# select the third col, and first two rows\nprint(arr2d[:2, 2])\nprint(arr)\n\n# select all rows and the first col.\nprint(arr2d[:, :1])\n\narr:  [ 0  1  2  3  4 64 64 64  8  9]\narr[1:6]:  [ 1  2  3  4 64]\narr2d:  [[1 2 3]\n [4 5 6]\n [7 8 9]]\narr2d[:2]:  [[1 2 3]\n [4 5 6]]\narr2d[:2, 1:]:  [[2 3]\n [5 6]]\n[4 5]\n(2,)\n[3 6]\n[ 0  1  2  3  4 64 64 64  8  9]\n[[1]\n [4]\n [7]]\n\n\n\n\nBoolean Indexing\n\n# Boolean indexing\n\nnames = np.array([\"Bob\", \"Joe\", \"Will\", \"Bob\", \"Will\", \"Joe\", \"Joe\"])\ndata = np.array([[4, 7], [0, 2], [-5, 6], [0, 0], [1, 2], [-12, -4], [3, 4]])\nprint(names, names.shape)\nprint(data, data.shape)\n\n# Suppose each name corresponds to a row in the data array\n\n# row filtering using Boolean indexing, compare names with the string 'Bob' to filter the corresponding rows from data array\nprint(names == \"Bob\")  # output - array of comparison result for each element\n\nprint(data[names == \"Bob\"]) # filter the corresponding rows from data, where \"Bob\" was matched in names.\nprint(data[names == \"Bob\", :1]) # also slice the column(s) to select the first col.\nprint(data[names == \"Bob\", 1]) # reduced to 1-d\n\n# negating the conditon\nprint(\"\\n__Negating the condition__\")\nprint(\"names: \", names)\nprint(names == \"Bob\")\nprint(names != \"Bob\")\nprint(~(names == \"Bob\")) # same as !=\n\n# Filter rows in data with the same row index where Bob is not matched in names\nprint(data[~(names == \"Bob\")])\n\n# Use a reference variable to invert Boolean condition\ncond = names == \"Bob\"\nprint(cond)\nprint(data[~cond])  # same as data[~(names == \"Bob\")]\n\n# Multiple Boolean conditions - &, |\ncond = (names == \"Bob\") | (names == \"Will\")\nprint(cond)\nprint(data[cond])\n\n['Bob' 'Joe' 'Will' 'Bob' 'Will' 'Joe' 'Joe'] (7,)\n[[  4   7]\n [  0   2]\n [ -5   6]\n [  0   0]\n [  1   2]\n [-12  -4]\n [  3   4]] (7, 2)\n[ True False False  True False False False]\n[[4 7]\n [0 0]]\n[[4]\n [0]]\n[7 0]\n\n__Negating the condition__\nnames:  ['Bob' 'Joe' 'Will' 'Bob' 'Will' 'Joe' 'Joe']\n[ True False False  True False False False]\n[False  True  True False  True  True  True]\n[False  True  True False  True  True  True]\n[[  0   2]\n [ -5   6]\n [  1   2]\n [-12  -4]\n [  3   4]]\n[ True False False  True False False False]\n[[  0   2]\n [ -5   6]\n [  1   2]\n [-12  -4]\n [  3   4]]\n[ True False  True  True  True False False]\n[[ 4  7]\n [-5  6]\n [ 0  0]\n [ 1  2]]\n\n\n\nprint(\"\\n___Setting values with Boolean arrays___\\n\")\nprint(data)\nprint(data &lt; 0)\ndata[data &lt; 0] = 999  # value setting applies to element with True\nprint(data)\n\n\n___Setting values with Boolean arrays___\n\n[[  4   7]\n [  0   2]\n [ -5   6]\n [  0   0]\n [  1   2]\n [-12  -4]\n [  3   4]]\n[[False False]\n [False False]\n [ True False]\n [False False]\n [False False]\n [ True  True]\n [False False]]\n[[  4   7]\n [  0   2]\n [999   6]\n [  0   0]\n [  1   2]\n [999 999]\n [  3   4]]\n\n\n\n#\ncond = (names != \"Joe\") # Save the boolean array to a variable\nprint(cond) \ndata[cond] = 7 # set the all element in the filtered rows\nprint(data)\n\n[ True False  True  True  True False False]\n[[  7   7]\n [  0   2]\n [  7   7]\n [  7   7]\n [  7   7]\n [999 999]\n [  3   4]]\n\n\n\n\nFancy Indexing\nDescribe indexing using array of integers\n\n# Create an array of 5,4 filled initialized with zero\narr = np.zeros((8, 4))\n\nfor i in range(8):\n  arr[i] = i # fill each row with row index number\nprint(arr, \"\\n\")\n\n# select rows in custom order - pass an array of row index in customer order\nprint(arr[ [4, 3, 0, 6]], \"\\n\")\nprint(arr[ [-3, -5, -7] ], \"\\n\")\n\n# passing multiple index arrays - select using each tuple of indices\narr = np.arange(32).reshape((8, 4))\nprint(arr, \"\\n\")\nprint(arr[[1, 5, 7, 2], [0, 3, 1, 2]], \"\\n\") # indexing using (1,0) (5,3) (7,1) (2,2)\n\n# retangular shaping and subsetting\nprint(arr.shape)\nprint(arr[[1, 5, 7, 2]][:, [0, 3, 1, 2]], \"\\n\") # rows subsetted in custom order, then cols subsetted in custom order\n\n# value assignment using fancy indexing\nprint(arr[[1, 5, 7, 2], [0, 3, 1, 2]])\narr[[1, 5, 7, 2], [0, 3, 1, 2]] = 777  # changes the indexed value\nprint(arr)\n\n[[0. 0. 0. 0.]\n [1. 1. 1. 1.]\n [2. 2. 2. 2.]\n [3. 3. 3. 3.]\n [4. 4. 4. 4.]\n [5. 5. 5. 5.]\n [6. 6. 6. 6.]\n [7. 7. 7. 7.]] \n\n[[4. 4. 4. 4.]\n [3. 3. 3. 3.]\n [0. 0. 0. 0.]\n [6. 6. 6. 6.]] \n\n[[5. 5. 5. 5.]\n [3. 3. 3. 3.]\n [1. 1. 1. 1.]] \n\n[[ 0  1  2  3]\n [ 4  5  6  7]\n [ 8  9 10 11]\n [12 13 14 15]\n [16 17 18 19]\n [20 21 22 23]\n [24 25 26 27]\n [28 29 30 31]] \n\n[ 4 23 29 10] \n\n(8, 4)\n[[ 4  7  5  6]\n [20 23 21 22]\n [28 31 29 30]\n [ 8 11  9 10]] \n\n[ 4 23 29 10]\n[[  0   1   2   3]\n [777   5   6   7]\n [  8   9 777  11]\n [ 12  13  14  15]\n [ 16  17  18  19]\n [ 20  21  22 777]\n [ 24  25  26  27]\n [ 28 777  30  31]]\n\n\n\n\nTransposing Arrays and Swapping Axes\n\n# T attribute\nprint(\"\\nT attribute in array to transpose...\\n\")\narr = np.arange(15).reshape(3, 5)\nprint(arr)\nprint(arr.T)\n\n# inner matrix product using T\nprint(\"\\ninner matrix product using T...\\n\")\narr = np.array([[0, 1, 0], [1, 2, -2], [6, 3, 2], [-1, 0, -1], [1, 0, 1\n]])\nprint(arr)\nprint(arr.T)\nprint(np.dot(arr.T, arr)) # matrix dot product\nprint(arr.T @ arr) # same as above\n\nprint(\"\\ndarray.swapaxes, same effect of transposing...\\n\")\nprint(arr)\nprint(arr.swapaxes(0, 1))\nprint(arr.T == arr.swapaxes(0,1))\n\n\nT attribute in array to transpose...\n\n[[ 0  1  2  3  4]\n [ 5  6  7  8  9]\n [10 11 12 13 14]]\n[[ 0  5 10]\n [ 1  6 11]\n [ 2  7 12]\n [ 3  8 13]\n [ 4  9 14]]\n\ninner matrix product using T...\n\n[[ 0  1  0]\n [ 1  2 -2]\n [ 6  3  2]\n [-1  0 -1]\n [ 1  0  1]]\n[[ 0  1  6 -1  1]\n [ 1  2  3  0  0]\n [ 0 -2  2 -1  1]]\n[[39 20 12]\n [20 14  2]\n [12  2 10]]\n[[39 20 12]\n [20 14  2]\n [12  2 10]]\n\ndarray.swapaxes, same effect of transposing...\n\n[[ 0  1  0]\n [ 1  2 -2]\n [ 6  3  2]\n [-1  0 -1]\n [ 1  0  1]]\n[[ 0  1  6 -1  1]\n [ 1  2  3  0  0]\n [ 0 -2  2 -1  1]]\n[[ True  True  True  True  True]\n [ True  True  True  True  True]\n [ True  True  True  True  True]]"
  }
]