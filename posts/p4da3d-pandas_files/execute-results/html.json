{
  "hash": "15d33c9b814f79ec1a551da1692352b3",
  "result": {
    "markdown": "---\ntitle: '[5] Pandas'\nsubtitle: 'A series of posts, exploring data analysis using the book - Python for Data Analysis, 3E by Wes McKinney'\ndate: '2023-10-11'\ncategories:\n  - Python\n  - pandas\ndescription: 'Learning notes - Python for Data Analysis, 3E - Wes McKinney'\nimage: data.jpg\nformat:\n  html:\n    code-fold: false\n---\n\n------------------------------------------------------------------------\n\n**pandas is ....**\n\nTwo workhorse data structures: Series and DataFrame, solid foundation of wide variety of data tasks.\n\nSeries - one-dimensional array-like object with a sequence of values and index: array + lables\n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\n# Simple Series\nimport numpy as np\nimport pandas as pd\n\nobj = pd.Series([4, 7, -5, 3])\nprint(obj)\nprint(type(obj))\nprint(obj.array)\nprint(obj.index)\n\n# A Series with a custom index\nobj2 = pd.Series([4, 7, -5, 3], index=[\"d\", \"b\", \"a\", \"c\"])\nprint(obj2)\nprint(obj2.index)\n\n# Select, modify array elemtns using index\nobj2[\"a\"]\nobj2[\"d\"] = 6\nobj2[[\"c\", \"a\", \"d\"]]  # using a list of 'indices'-like\n\n# Preservation of index-value link\nprint(obj2[obj2 > 0])\nprint(obj2 * 2)\nprint(np.exp(obj2))\n\n# Series and dictionary, the shared context: mapping of index value to data value\nprint(\"b\" in obj2)\nprint(\"B\" in obj2)\n\n# Convert Python dictionary to/from a Series\ndata_dict = {\n    \"name\": \"John Smith\",\n    \"age\": 30,\n    \"city\": \"New York\",\n    \"email\": \"john.smith@email.com\",\n    \"is_student\": False\n}\nprint(data_dict)\ns_data = pd.Series(data_dict)  # dictionary to Series\nprint(s_data, type(s_data))\nd_data = s_data.to_dict()  # Series to dictionary\nprint(d_data, type(d_data))\n\n# Preservation of index-value\nnew_index = [\"gender\", \"name\", \"age\", \"city\", \"email\"]\nobj4 = pd.Series(data_dict, index=new_index)\nprint(obj4)\n\n# Detecting missing data using pd and Series\nprint(pd.isna(obj4))\nprint(pd.notna(obj4))\nprint(obj4.isna())\nprint(obj4.notna())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n0    4\n1    7\n2   -5\n3    3\ndtype: int64\n<class 'pandas.core.series.Series'>\n<PandasArray>\n[4, 7, -5, 3]\nLength: 4, dtype: int64\nRangeIndex(start=0, stop=4, step=1)\nd    4\nb    7\na   -5\nc    3\ndtype: int64\nIndex(['d', 'b', 'a', 'c'], dtype='object')\nd    6\nb    7\nc    3\ndtype: int64\nd    12\nb    14\na   -10\nc     6\ndtype: int64\nd     403.428793\nb    1096.633158\na       0.006738\nc      20.085537\ndtype: float64\nTrue\nFalse\n{'name': 'John Smith', 'age': 30, 'city': 'New York', 'email': 'john.smith@email.com', 'is_student': False}\nname                    John Smith\nage                             30\ncity                      New York\nemail         john.smith@email.com\nis_student                   False\ndtype: object <class 'pandas.core.series.Series'>\n{'name': 'John Smith', 'age': 30, 'city': 'New York', 'email': 'john.smith@email.com', 'is_student': False} <class 'dict'>\ngender                     NaN\nname                John Smith\nage                         30\ncity                  New York\nemail     john.smith@email.com\ndtype: object\ngender     True\nname      False\nage       False\ncity      False\nemail     False\ndtype: bool\ngender    False\nname       True\nage        True\ncity       True\nemail      True\ndtype: bool\ngender     True\nname      False\nage       False\ncity      False\nemail     False\ndtype: bool\ngender    False\nname       True\nage        True\ncity       True\nemail      True\ndtype: bool\n```\n:::\n:::\n\n\n**Q: How to assign a name to a pandas Series and customize its index name?**\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\nsdata = {\"Ohio\": 35000, \"Texas\": 71000, \"Oregon\": 16000, \"Utah\": 5000}\nstates = [\"California\", \"Ohio\", \"Oregon\", \"Texas\"]\n\nobj4 = pd.Series(sdata, index=states)\nprint(obj4)\n\nobj4.name = \"population\"\nobj4.index.name = \"state\"\nprint(obj4)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nCalifornia        NaN\nOhio          35000.0\nOregon        16000.0\nTexas         71000.0\ndtype: float64\nstate\nCalifornia        NaN\nOhio          35000.0\nOregon        16000.0\nTexas         71000.0\nName: population, dtype: float64\n```\n:::\n:::\n\n\nQ: Change the index of Series in place\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\n# change the index using index attribute\nobj.index = [\"One\", \"Two\", \"Three\", \"Four\"]\nprint(obj)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nOne      4\nTwo      7\nThree   -5\nFour     3\ndtype: int64\n```\n:::\n:::\n\n\n### DataFrame\n\nRectangular table of data, ordered, named collection of columns. Each column can be a different value type. It has both a row and column index - A dictionary of Series\n\n**Q. Create a DataFrame from a dictionary of equal-length lists or Numpy arrays**\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\n# most common way of creating a DataFrame\ndata = {\"state\": [\"Ohio\", \"Ohio\", \"Ohio\", \"Nevada\", \"Nevada\", \"Nevada\"],\n        \"year\": [2000, 2001, 2002, 2001, 2002, 2003],\n        \"pop\": [1.5, 1.7, 3.6, 2.4, 2.9, 3.2]}\nframe = pd.DataFrame(data)\n\nprint(frame)\nprint(frame.head())\nprint(frame.tail())\nprint(frame.columns.array)\nprint(frame.index.array)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n    state  year  pop\n0    Ohio  2000  1.5\n1    Ohio  2001  1.7\n2    Ohio  2002  3.6\n3  Nevada  2001  2.4\n4  Nevada  2002  2.9\n5  Nevada  2003  3.2\n    state  year  pop\n0    Ohio  2000  1.5\n1    Ohio  2001  1.7\n2    Ohio  2002  3.6\n3  Nevada  2001  2.4\n4  Nevada  2002  2.9\n    state  year  pop\n1    Ohio  2001  1.7\n2    Ohio  2002  3.6\n3  Nevada  2001  2.4\n4  Nevada  2002  2.9\n5  Nevada  2003  3.2\n<PandasArray>\n['state', 'year', 'pop']\nLength: 3, dtype: object\n<PandasArray>\n[0, 1, 2, 3, 4, 5]\nLength: 6, dtype: int64\n```\n:::\n:::\n\n\n**Q: Create a DataFrame in a customized sequence of columns**\n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\n# create a DataFrame in a custom column order - default is by the order of key value\nframe2 = pd.DataFrame(data, columns=[\"year\", \"state\", \"pop\", \"debt\"])\nprint(frame2)\nprint(frame2.columns)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   year   state  pop debt\n0  2000    Ohio  1.5  NaN\n1  2001    Ohio  1.7  NaN\n2  2002    Ohio  3.6  NaN\n3  2001  Nevada  2.4  NaN\n4  2002  Nevada  2.9  NaN\n5  2003  Nevada  3.2  NaN\nIndex(['year', 'state', 'pop', 'debt'], dtype='object')\n```\n:::\n:::\n\n\n**Q: Retrieve columns in a DataFrame**\n\n::: {.cell execution_count=6}\n``` {.python .cell-code}\n# Retrieve columns using [] or dot notation\nprint(frame2[\"state\"])\nprint(frame2.state)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n0      Ohio\n1      Ohio\n2      Ohio\n3    Nevada\n4    Nevada\n5    Nevada\nName: state, dtype: object\n0      Ohio\n1      Ohio\n2      Ohio\n3    Nevada\n4    Nevada\n5    Nevada\nName: state, dtype: object\n```\n:::\n:::\n\n\nQ: Retrieve rows using row labels and integer\n\n::: {.cell execution_count=7}\n``` {.python .cell-code}\n# data source dictionary\ndata = {'A': [1, 2, 3, 4, 5],\n        'B': [6, 7, 8, 9, 10]}\n\n# DataFrame\ndf = pd.DataFrame(data, index=['row1', 'row2', 'row3', 'row4', 'row5'])\nprint(df)\n\n# Label-based selection\nprint(df.loc['row1':'row3'])\n\n# Integer-based selection\nprint(df.iloc[0:2])\n\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n      A   B\nrow1  1   6\nrow2  2   7\nrow3  3   8\nrow4  4   9\nrow5  5  10\n      A  B\nrow1  1  6\nrow2  2  7\nrow3  3  8\n      A  B\nrow1  1  6\nrow2  2  7\n```\n:::\n:::\n\n\n**Q: Modify the 'debt' column in the DataFrame with a specific scalar value or an array of values**\n\n::: {.cell execution_count=8}\n``` {.python .cell-code}\nframe2[\"debt\"] = 16.5\nprint(frame2)\n\nframe2[\"debt\"] = np.arange(6.)\nprint(frame2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   year   state  pop  debt\n0  2000    Ohio  1.5  16.5\n1  2001    Ohio  1.7  16.5\n2  2002    Ohio  3.6  16.5\n3  2001  Nevada  2.4  16.5\n4  2002  Nevada  2.9  16.5\n5  2003  Nevada  3.2  16.5\n   year   state  pop  debt\n0  2000    Ohio  1.5   0.0\n1  2001    Ohio  1.7   1.0\n2  2002    Ohio  3.6   2.0\n3  2001  Nevada  2.4   3.0\n4  2002  Nevada  2.9   4.0\n5  2003  Nevada  3.2   5.0\n```\n:::\n:::\n\n\nQ: **Modify the 'debt' column in the DataFrame with a Series object with different number of data**\n\n::: {.cell execution_count=9}\n``` {.python .cell-code}\n# Series index value is used to match the index of DataFrame, if not presented, it is ignored\nval = pd.Series([-1.2, -1.5, -1.7], index=[2, 4, 32])\nframe2[\"debt\"] = val\nprint(frame2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   year   state  pop  debt\n0  2000    Ohio  1.5   NaN\n1  2001    Ohio  1.7   NaN\n2  2002    Ohio  3.6  -1.2\n3  2001  Nevada  2.4   NaN\n4  2002  Nevada  2.9  -1.5\n5  2003  Nevada  3.2   NaN\n```\n:::\n:::\n\n\n**Q: Create a column called *`eastern`*, and initialize it with Boolean value if the state is *`Ohio`***\n\n::: {.cell execution_count=10}\n``` {.python .cell-code}\nframe2[\"eastern\"] = (frame2[\"state\"] == \"Ohio\")\nprint(frame2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   year   state  pop  debt  eastern\n0  2000    Ohio  1.5   NaN     True\n1  2001    Ohio  1.7   NaN     True\n2  2002    Ohio  3.6  -1.2     True\n3  2001  Nevada  2.4   NaN    False\n4  2002  Nevada  2.9  -1.5    False\n5  2003  Nevada  3.2   NaN    False\n```\n:::\n:::\n\n\n**Q: Delete column *`eastern`* and list all the columns for the DataFrame**\n\n::: {.cell execution_count=11}\n``` {.python .cell-code}\ndel frame2[\"eastern\"]\nframe2.columns\n```\n\n::: {.cell-output .cell-output-display execution_count=11}\n```\nIndex(['year', 'state', 'pop', 'debt'], dtype='object')\n```\n:::\n:::\n\n\n**Q: Create a DataFrame using a nested dictionary data.**\n\n::: {.cell execution_count=12}\n``` {.python .cell-code}\npopulations = {\"Ohio\": {2000: 1.5, 2001: 1.7, 2002: 3.6},\n               \"Nevada\": {2001: 2.4, 2002: 2.9}}\nprint(populations)\n\n# outer dictionary key - column indices\ndf_populations = pd.DataFrame(populations)\nprint(df_populations)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n{'Ohio': {2000: 1.5, 2001: 1.7, 2002: 3.6}, 'Nevada': {2001: 2.4, 2002: 2.9}}\n      Ohio  Nevada\n2000   1.5     NaN\n2001   1.7     2.4\n2002   3.6     2.9\n```\n:::\n:::\n\n\n**Q: Transpose the df_populations DataFrame.**\n\n::: {.cell execution_count=13}\n``` {.python .cell-code}\ndf_populations.T\n```\n\n::: {.cell-output .cell-output-display execution_count=13}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>2000</th>\n      <th>2001</th>\n      <th>2002</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>Ohio</th>\n      <td>1.5</td>\n      <td>1.7</td>\n      <td>3.6</td>\n    </tr>\n    <tr>\n      <th>Nevada</th>\n      <td>NaN</td>\n      <td>2.4</td>\n      <td>2.9</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n**Q: Create a DataFrame using a nested dictionary data, using new column index**\n\n::: {.cell execution_count=14}\n``` {.python .cell-code}\npd.DataFrame(populations, index=[2000, 2001, 2012])\n```\n\n::: {.cell-output .cell-output-display execution_count=14}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>Ohio</th>\n      <th>Nevada</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>2000</th>\n      <td>1.5</td>\n      <td>NaN</td>\n    </tr>\n    <tr>\n      <th>2001</th>\n      <td>1.7</td>\n      <td>2.4</td>\n    </tr>\n    <tr>\n      <th>2012</th>\n      <td>NaN</td>\n      <td>NaN</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nQ. Create a DataFrame using frame3, using a dictionary with a few Series of columns with custom range\n\n::: {.cell execution_count=15}\n``` {.python .cell-code}\nsub_populations = {\n    \"Ohio2\": df_populations[\"Ohio\"][:-1],\n    \"Nevada2\": df_populations[\"Nevada\"][:2]\n}\ndf_sub_populations = pd.DataFrame(sub_populations)\nprint(df_sub_populations)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n      Ohio2  Nevada2\n2000    1.5      NaN\n2001    1.7      2.4\n```\n:::\n:::\n\n\n::: {.cell execution_count=16}\n``` {.python .cell-code}\npopulations\n```\n\n::: {.cell-output .cell-output-display execution_count=16}\n```\n{'Ohio': {2000: 1.5, 2001: 1.7, 2002: 3.6}, 'Nevada': {2001: 2.4, 2002: 2.9}}\n```\n:::\n:::\n\n\n**Q: Create a DataFrame using a NumPy 2D-array. Give custom row and column labels**\n\n::: {.cell execution_count=17}\n``` {.python .cell-code}\n# Create a 2D ndarray as data source\ndata = np.array([[1, 2, 3,],\n                [4, 5, 6],\n                [7, 8, 9]])\n\n# Define custom row and column labels\nrow_labels = ['Row-1', 'Row-2', 'Row-3']\ncolumn_labels = ['A', 'B', 'C']\n\n# Create a DataFrame with the custom labels\ndf = pd.DataFrame(data, index=row_labels, columns=column_labels)\nprint(df)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n       A  B  C\nRow-1  1  2  3\nRow-2  4  5  6\nRow-3  7  8  9\n```\n:::\n:::\n\n\n**Q: Create a DataFrame using a dictionary of arrays, lists or tuples.**\n\n::: {.cell execution_count=18}\n``` {.python .cell-code}\n# DataFrame from a dictionary\n\n# Create a dictionary with arrays\ndata_dict = {\n    'Name': np.array(['Alice', 'Bob', 'Charlie']),\n    'Age': np.array([25, 30, 28]),\n    'City': np.array(['Toronto', 'Calgary', 'Ottawa'])\n}\n\n# Create a pandas DataFrame\ndf = pd.DataFrame(data_dict)\n\nprint(df)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n      Name  Age     City\n0    Alice   25  Toronto\n1      Bob   30  Calgary\n2  Charlie   28   Ottawa\n```\n:::\n:::\n\n\n::: {.cell execution_count=19}\n``` {.python .cell-code}\n# DataFrame from a list\n\n# Create a dictionary with lists\ndata_dict = {\n    'Country': ['USA', 'Canada', 'UK'],\n    'Population': [328, 38, 66],\n    'Capital': ['Washington D.C.', 'Ottawa', 'London']\n}\n\n# Create a pandas DataFrame\ndf = pd.DataFrame(data_dict)\n\nprint(df)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  Country  Population          Capital\n0     USA         328  Washington D.C.\n1  Canada          38           Ottawa\n2      UK          66           London\n```\n:::\n:::\n\n\n::: {.cell execution_count=20}\n``` {.python .cell-code}\n# Create a dictionary with tuples\ndata_dict = {\n    'Fruit': ('Apple', 'Banana', 'Cherry'),\n    'Color': ('Red', 'Yellow', 'Red'),\n    'Taste': ('Sweet', 'Sweet', 'Tart')\n}\n\n# Create a pandas DataFrame\ndf = pd.DataFrame(data_dict)\n\nprint(df)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n    Fruit   Color  Taste\n0   Apple     Red  Sweet\n1  Banana  Yellow  Sweet\n2  Cherry     Red   Tart\n```\n:::\n:::\n\n\n**Q: Create a DataFrame using a NumPy structured array**\n\n`\n\n\n# Create a NumPy structured array\n# Field + Type: (ID, Name, Age)\n\ndata = np.array([(100, 'Alice', 25),\n                 (200, 'Bob', 30),\n                 (300, 'Charlie', 29)],\n                dtype=[('ID', int), ('Name', 'U10'), ('Age', int)])\n\n# Create a DataFrame from the structued array\ndf = pd.DataFrame(data)\nprint(df)\n```\n\n**Q:** **Create a DataFrame using a dictionary of Series.**\n\n::: {.cell execution_count=21}\n``` {.python .cell-code}\n# Create a dictioinary of Series\ndata_dict = {\n    'Name': pd.Series(['Alice', 'Bob', 'Charlie']),\n    'Age': pd.Series([25, 30, 28]),\n    'City': pd.Series(['New York', 'San Francisco', 'Los Angeles', 'Paris'])\n}\n\n# Create a pandas DataFrame from the dictioanry of Series\ndf = pd.DataFrame(data_dict)\nprint(df)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n      Name   Age           City\n0    Alice  25.0       New York\n1      Bob  30.0  San Francisco\n2  Charlie  28.0    Los Angeles\n3      NaN   NaN          Paris\n```\n:::\n:::\n\n\n**Q:** **Create a DataFrame using a list of dictionaries / Series.**\n\n`\n\n\n# Create a list of dictionaries\ndata_dict = [\n    {'Name': 'Alice', 'Age': 25, 'City': 'New York'},\n    {'Name': 'Bob', 'Age': 30, 'City': 'San Francisco'},\n    {'Name': 'Charlie', 'Age': 28, 'City': 'Los Angeles'}\n]\n\n# Create a list of Series\nname_series = pd.Series(['Alice', 'Bob', 'Charlie'], name='Name')\nage_series = pd.Series([25, 30, 28], name='Age')\ncity_series = pd.Series(\n    ['New York', 'San Francisco', 'Los Angeles'], name='City')\n\n# Create a DataFrame from the list of dictionaries\ndf1 = pd.DataFrame(data_dict)\nprint(df1)\nprint(\"-\" * 50)\n# Create a DataFrame from the list of Series\ndf2 = pd.DataFrame({'Name': name_series,\n                    'Age': age_series,\n                    'City': city_series})\nprint(df2)\n\n```\n\n**Q: Create a DataFrame using a list of lists / tuples**\n\n`\n\n\n# Create a list of lists\ndata_list = [\n    ['Alice', 25, 'New York'],\n    ['Bob', 30, 'San Francisco'],\n    ['Charlie', 28, 'Los Angeles']\n]\n\n# Define column labels\ncolumns = ['Name', 'Age', 'City']\n\n# Create a DataFrame from the list of lists\ndf = pd.DataFrame(data_list, columns=columns)\nprint(df)\n\nprint(\"-\" * 50)\n\n# Create a list of tuples\ndata_tuples = [\n    ('Alice', 25, 'New York'),\n    ('Bob', 30, 'San Francisco'),\n    ('Charlie', 28, 'Los Angeles')\n]\n\n# Define column labels\ncolumns = ['name', 'age', 'city']\n\n# Create a DataFrame from the list of tuples\ndf = pd.DataFrame(data_tuples, columns=columns)\nprint(df)\n```\n\n**Q: Create a DataFrame using another DataFrame**\n\n`\n\n\n# Create the original DataFrame\ndata = {\n    'Name': ['Alice', 'Bob', 'Charlie'],\n    'Age': [25, 30, 28],\n    'City': ['New York', 'San Francisco', 'Los Angeles']\n}\n\noriginal_df = pd.DataFrame(data)\nprint(original_df)\nprint(\"-\" * 50)\n\n# Create a new DataFrame based on the original DataFrame\ncopy_original_df = original_df.copy()\ncopy_original_df.columns = ['_name', '_age', '_city']\nprint(copy_original_df)\nprint(\"-\" * 50)\n\nnew_df = pd.DataFrame(original_df)\nprint(new_df)\nprint(\"-\" * 50)\n\nprint(id(original_df))\nprint(id(copy_original_df))\nprint(id(new_df))\n```\n\n**Q: Create a DataFrame and update the name attributes for index and columns**\n\n::: {.cell execution_count=22}\n``` {.python .cell-code}\n# Data source in a idctionary\npopulations = {\n    \"Ohio\": {2000: 1.5, 2001: 1.7, 2002: 3.6},\n    \"Nevada\": {2001: 2.4, 2002: 2.9}\n}\n\n# Create a DataFrame\nframe3 = pd.DataFrame(populations)\nprint(frame3)\nprint(\"-\" * 50)\n\n# Update the name attributes for index / columns\nframe3.index.name = \"year\"\nframe3.columns.name = \"state\"\nprint(frame3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n      Ohio  Nevada\n2000   1.5     NaN\n2001   1.7     2.4\n2002   3.6     2.9\n--------------------------------------------------\nstate  Ohio  Nevada\nyear               \n2000    1.5     NaN\n2001    1.7     2.4\n2002    3.6     2.9\n```\n:::\n:::\n\n\n**Q. Create a DataFrame from a dictionary, then convert it to a NumPy array.**\n\n::: {.cell execution_count=23}\n``` {.python .cell-code}\n# Data source in a dictionary\ndata = {\n    \"state\": [\"Ohio\", \"Ohio\", \"Ohio\", \"Nevada\", \"Nevada\", \"Nevada\"],\n    \"year\": [2000, 2001, 2002, 2001, 2002, 2003],\n    \"pop\": [1.5, 1.7, 3.6, 2.4, 2.9, 3.2]\n}\nprint(data, type(data))\nprint(\"-\"*50)\n\n# Create a DataFrame and add a column 'debt'\nframe2 = pd.DataFrame(data)\nval = pd.Series([-1.2, -1.5, -1.7], index=[2, 4, 5])\nframe2[\"debt\"] = val\nprint(frame2, type(frame2))\nprint(\"-\"*50)\n\n# Convert DataFrame to NuPy 2d-ndarray\nframe2_array = frame2.to_numpy()\nprint(frame2_array, type(frame2_array))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n{'state': ['Ohio', 'Ohio', 'Ohio', 'Nevada', 'Nevada', 'Nevada'], 'year': [2000, 2001, 2002, 2001, 2002, 2003], 'pop': [1.5, 1.7, 3.6, 2.4, 2.9, 3.2]} <class 'dict'>\n--------------------------------------------------\n    state  year  pop  debt\n0    Ohio  2000  1.5   NaN\n1    Ohio  2001  1.7   NaN\n2    Ohio  2002  3.6  -1.2\n3  Nevada  2001  2.4   NaN\n4  Nevada  2002  2.9  -1.5\n5  Nevada  2003  3.2  -1.7 <class 'pandas.core.frame.DataFrame'>\n--------------------------------------------------\n[['Ohio' 2000 1.5 nan]\n ['Ohio' 2001 1.7 nan]\n ['Ohio' 2002 3.6 -1.2]\n ['Nevada' 2001 2.4 nan]\n ['Nevada' 2002 2.9 -1.5]\n ['Nevada' 2003 3.2 -1.7]] <class 'numpy.ndarray'>\n```\n:::\n:::\n\n\n## **Index Objects**\n\nIndex objects holds the information about axis labels (labels assigned to rows and columns in DataFrame and Series) and meta data. Index objects are immutable and it makes it safer to share index objects among data structures.\n\nQ: Construct a Series object and retrieve index information from it.\n\n::: {.cell execution_count=24}\n``` {.python .cell-code}\n# Create a Series\nobj = pd.Series(np.arange(3), index=[\"a\", \"b\", \"c\"])  # row labels\nprint(obj, type(obj))\nprint(obj.index)\nprint(obj.index[1:])  # slicing the array of index object\n```\n\n::: {.cell-output .cell-output-stdout}\n```\na    0\nb    1\nc    2\ndtype: int32 <class 'pandas.core.series.Series'>\nIndex(['a', 'b', 'c'], dtype='object')\nIndex(['b', 'c'], dtype='object')\n```\n:::\n:::\n\n\n### Q: Create an Index Object and construct a Series using the object.\n\n::: {.cell execution_count=25}\n``` {.python .cell-code}\n# Create an Index object\nlabels = pd.Index(np.arange(3))\nprint(labels, type(labels))\n\n# Create a Series using the index object\nobj2 = pd.Series([1.5, -2.5, 0], index=labels)\nprint(obj2, type(obj2))\n\n# Test equality of the index object\nprint(obj2.index is labels)\nprint(id(obj2.index))\nprint(id(labels))  # refering to the the same object\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nInt64Index([0, 1, 2], dtype='int64') <class 'pandas.core.indexes.numeric.Int64Index'>\n0    1.5\n1   -2.5\n2    0.0\ndtype: float64 <class 'pandas.core.series.Series'>\nTrue\n1582613487184\n1582613487184\n```\n:::\n:::\n\n\n### Q: Create a DataFrame and use its index and columns to test Set operation for element existence.\n\n::: {.cell execution_count=26}\n``` {.python .cell-code}\n# Data source in a idctionary\npopulations = {\n    \"Ohio\": {2000: 1.5, 2001: 1.7, 2002: 3.6},\n    \"Nevada\": {2001: 2.4, 2002: 2.9}\n}\n\n# Create a DataFrame\nframe3 = pd.DataFrame(populations)\nprint(frame3)\nprint(\"Index: Outer keys become column labels, Inner keys become row labels.\")\nprint(\"-\" * 50)\n\n# Indexes for columns and rows\nprint(frame3.columns, type(frame3.columns))\nprint(frame3.index, type(frame3.index))\nprint(\"-\" * 50)\n\n# Check with set operator\nprint(\"Ohio is in index for columns: \", \"Ohio\" in frame3.columns)\nprint(\"2003 is in index for rows: \", \"2003\" in frame3.index)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n      Ohio  Nevada\n2000   1.5     NaN\n2001   1.7     2.4\n2002   3.6     2.9\nIndex: Outer keys become column labels, Inner keys become row labels.\n--------------------------------------------------\nIndex(['Ohio', 'Nevada'], dtype='object') <class 'pandas.core.indexes.base.Index'>\nInt64Index([2000, 2001, 2002], dtype='int64') <class 'pandas.core.indexes.numeric.Int64Index'>\n--------------------------------------------------\nOhio is in index for columns:  True\n2003 is in index for rows:  False\n```\n:::\n:::\n\n\n### Q: Concatenate with additional Index objects, producing a new index\n\n::: {.cell execution_count=27}\n``` {.python .cell-code}\n# Create an initial index\nindex1 = pd.Index([1, 2, 3])\n\n# Create a new index to append\nindex2 = pd.Index([4, 5, 6])\n\n# Use the append() method to concatenate index2 to index1import pandas as pd\n\n# Create two Index objects\nindex1 = pd.Index([1, 2, 3, 4, 5])\nindex2 = pd.Index([3, 4, 5, 6, 7])\n\n# Use the difference() method to find the set difference\nresult = index1.difference(index2)\n\n# Display the elements in index1 that are not in index2\nprint(result)\n\nnew_index = index1.append(index2)\n\n# Display the new concatenated index\nprint(new_index)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nInt64Index([1, 2], dtype='int64')\nInt64Index([1, 2, 3, 4, 5, 3, 4, 5, 6, 7], dtype='int64')\n```\n:::\n:::\n\n\n### Q: Compute set difference, intersection and union as an index between two index objects\n\n::: {.cell execution_count=28}\n``` {.python .cell-code}\n# Create two Index objects\nindex1 = pd.Index([1, 2, 3, 4, 5])\nindex2 = pd.Index([3, 4, 5, 6, 7])\n\n# Use the difference() method to find the set difference\nresult = index1.difference(index2)\nprint(result)\n\n# intersection\nresult = index1.intersection(index2)\nprint(result)\n\n# union\nresult = index1.union(index2)\nprint(result)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nInt64Index([1, 2], dtype='int64')\nInt64Index([3, 4, 5], dtype='int64')\nInt64Index([1, 2, 3, 4, 5, 6, 7], dtype='int64')\n```\n:::\n:::\n\n\n### Q: Compute Boolean array indicating whether each value is contained in the passed collection\n\n`\n\n\n# Create an Index object\nindex = pd.Index([1, 2, 3, 4, 5])\n\n# Create a collection of values to check for containment\ncollection = [3, 5, 7]\n\n# Use the isin() method to check for containment\nis_in_collection = index.isin(collection)\n\n# Display the Boolean array for each element's containment\nprint(is_in_collection)\n\n```\n\n### Q: Delete an element at a specific location in an Index and created a new updated Index.\n\n::: {.cell execution_count=29}\n``` {.python .cell-code}\n# Create an INdex\nindex = pd.Index(['A', 'B', 'C', 'D'])\nprint(index)\n\n# Delete an element at a specific position\nnew_index = index.delete(2)  # elemnt at position 2 (0-based)\nprint(new_index)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nIndex(['A', 'B', 'C', 'D'], dtype='object')\nIndex(['A', 'B', 'D'], dtype='object')\n```\n:::\n:::\n\n\n### Question: Create a new Index object by deleting passed lables from the index.\n\n::: {.cell execution_count=30}\n``` {.python .cell-code}\n# Create an Index\nindex = pd.Index(['A', 'B', 'C', 'D', 'E'])\nprint(\"original Index obj: \", index)\n\n# Drop specific labels from the Index\nlabels_to_drop = ['B', 'C']\nnew_index = index.drop(labels_to_drop)\nprint(\"new Index obj: \", new_index)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\noriginal Index obj:  Index(['A', 'B', 'C', 'D', 'E'], dtype='object')\nnew Index obj:  Index(['A', 'D', 'E'], dtype='object')\n```\n:::\n:::\n\n\n### Question: Create a new Index object by inserting new labels to an existing Index object, after the element matching with the first letter of the new label\n\n::: {.cell execution_count=31}\n``` {.python .cell-code}\n# Create a Index object\noriginal_labels = ['A', 'B', 'C', 'D', 'E']\nindex = pd.Index(original_labels)\nprint(\"Original index: \", index)\n\n# additional labels to be inserted\nadditional_labels = ['C-3', 'C-5', 'C-1', 'C-2', 'C-4']\nprint(\"Labels to insert: \", additional_labels)\n\n# insert the labels\nnew_index = index\nadditional_labels.sort(reverse=True)\n# print(\"reverse-sorted additional labels: \", additional_labels)\n\nfor label in additional_labels:\n    first_letter = label[:1]\n\n    if (first_letter in original_labels):\n        # find the index of the first letter\n        idx = original_labels.index(first_letter)\n        # print(first_letter, label, idx)\n        new_index = new_index.insert(idx+1, label)\n\nprint(\"New index: \", new_index)\n\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nOriginal index:  Index(['A', 'B', 'C', 'D', 'E'], dtype='object')\nLabels to insert:  ['C-3', 'C-5', 'C-1', 'C-2', 'C-4']\nNew index:  Index(['A', 'B', 'C', 'C-1', 'C-2', 'C-3', 'C-4', 'C-5', 'D', 'E'], dtype='object')\n```\n:::\n:::\n\n\n### Question: You have a Pandas Index object, and you want to check if it is monotonically decreasing. Write a Python function that takes an Index object as input and returns **`True`** if the index is monotonically decreasing, and **`False`** otherwise.\n\n::: {.cell execution_count=32}\n``` {.python .cell-code}\n# Function to check if an Index is monotonically  decreasing\n\ndef is_monotonic_decreasing(index):\n    return index.is_monotonic_decreasing\n\n\n# indexes to test\nindex1 = pd.Index([5, 4, 3, 2, 1])\nindex2 = pd.Index(['E', 'D', 'C', 'B', 'A'])\nindex3 = pd.Index([4, 3, 2, 'D', 'C', 'B'])\n\nlist_of_index = [index1, index2, index3]\nfor index in list_of_index:\n    print(index, is_monotonic_decreasing(index))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nInt64Index([5, 4, 3, 2, 1], dtype='int64') True\nIndex(['E', 'D', 'C', 'B', 'A'], dtype='object') True\nIndex([4, 3, 2, 'D', 'C', 'B'], dtype='object') False\n```\n:::\n:::\n\n\n### Question: You have a Pandas Index object, and you want to check if it contains unique elements. Write a Python function that takes an Index object as input and returns `True` if all the elements are unique, and `False` otherwise.\n\n::: {.cell execution_count=33}\n``` {.python .cell-code}\n# Create indexes for testing\nindex1 = pd.Index(['A', 'B', 'C', 'D', 'E'])\nindex2 = pd.Index(['A', 'B', 'C', 'A', 'D'])\n\n# Function to check if an Index contatins unique elements\n\n\ndef is_unique(index):\n    return index.is_unique\n\n\n# Test the indexes\nprint(index1, is_unique(index1))\nprint(index2, is_unique(index2))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nIndex(['A', 'B', 'C', 'D', 'E'], dtype='object') True\nIndex(['A', 'B', 'C', 'A', 'D'], dtype='object') False\n```\n:::\n:::\n\n\n### You have a Pandas Index object, and you want to retrieve the unique elements from it. Write a Python function that takes an Index object as input and returns a list of unique elements from the index.\n\n::: {.cell execution_count=34}\n``` {.python .cell-code}\nindex = pd.Index(['A', 'B', 'C', 'A', 'D', 'B'])\n\n\ndef get_unique_elements(index):\n    return index.unique()\n\n\nunique_elements = get_unique_elements(index)\nprint(\"Unique elements: \", unique_elements)  # Index object\nprint(unique_elements.tolist())  # List object\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nUnique elements:  Index(['A', 'B', 'C', 'D'], dtype='object')\n['A', 'B', 'C', 'D']\n```\n:::\n:::\n\n\n## The mechanics of interacting with data in Series and DataFrame\n\n### Question: You're working with a dataset of daily stock prices for a portfolio of companies. The dataset has missing values for certain days, and you want to reindex it to ensure you have a complete set of daily data for a specified date range. You need to create a Python function that takes several arguments to demonstrate the use of the reindex() method and its optional parameters. Your task is to implement the reindex_stock_data() function, which demonstrates the use of these parameters. The function should reindex the stock price data to the specified date range, filling missing data with the provided fill_value and considering the other optional parameters.\n\n-   `data`: A DataFrame containing stock price data with a date index.\n-   `start_date`: The start date of the desired date range.\n-   `end_date`: The end date of the desired date range.\n-   `fill_value`: The value to fill missing data points.\n-   `method`: A method to use for filling missing values (e.g., 'ffill', 'bfill').\n-   `limit`: The maximum number of consecutive NaN values to fill.\n-   `tolerance`: The maximum allowed difference in the index value when reindexing.\n-   `level`: The level in case of MultiIndex.\n-   `copy`: Whether to create a copy of the original data or reindex in-place.\n\n::: {.cell execution_count=35}\n``` {.python .cell-code}\n# Function to reindex data as the parameters instruct\ndef reindex_stock_data(\n    data,\n    start_date,\n    end_date,\n    fill_value,\n    method=None,\n    limit=None,\n    tolerance=None,\n    level=None,\n    copy=False\n):\n    # print(\"fill_value passed in: \" + str(fill_value))\n    # Fill NaN values with the specified fill_value\n    data_filled = data.fillna(fill_value)\n    # print(\"data_filled:\\n\", data_filled)\n\n    # Generate fixed-frequency Datetime index - index of dates and times\n    date_range = pd.date_range(start=start_date, end=end_date, freq='D')\n\n    # Reindex the filled data\n    result = data_filled.reindex(date_range, method=method, tolerance=tolerance,\n                                 limit=limit, fill_value=fill_value, level=level, copy=copy)\n    return result\n\n# Create an incomplete initial data for testing\ndata = pd.DataFrame({\n    'AAPL': [150, 151, np.nan, 153, np.nan],\n    'GOOGL': [2000, np.nan, 2020, 2030, 2040],\n    'MSFT': [300, np.nan, 302, np.nan, 304],\n    'AMZN': [3500, 3510, np.nan, np.nan, 3540],\n    'TSLA': [np.nan, 701, 702, 703, np.nan]\n}, index=pd.date_range(start='2022-01-01', periods=5, freq='D'))\nprint(\"Original data:\\n\", data)\n\n# Set parameters and values for the function - reindexing\nstart_date = '2022-01-01'\nend_date = '2022-01-05'\nfill_value = 0\nmethod = 'bfill'  # Backward fill\nlimit = 1\ntolerance = '1D'  # Tolerance of 1 day\nlevel = None\ncopy = True\n\n# print(\"fill_value is: \", str(fill_value))\n# Call the function and reindex the data\nresult = reindex_stock_data(\n    data, start_date, end_date, fill_value, method, limit, tolerance, level, copy)\nprint(\"Result re-indexed data:\\n\", result)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nOriginal data:\n              AAPL   GOOGL   MSFT    AMZN   TSLA\n2022-01-01  150.0  2000.0  300.0  3500.0    NaN\n2022-01-02  151.0     NaN    NaN  3510.0  701.0\n2022-01-03    NaN  2020.0  302.0     NaN  702.0\n2022-01-04  153.0  2030.0    NaN     NaN  703.0\n2022-01-05    NaN  2040.0  304.0  3540.0    NaN\nResult re-indexed data:\n              AAPL   GOOGL   MSFT    AMZN   TSLA\n2022-01-01  150.0  2000.0  300.0  3500.0    0.0\n2022-01-02  151.0     0.0    0.0  3510.0  701.0\n2022-01-03    0.0  2020.0  302.0     0.0  702.0\n2022-01-04  153.0  2030.0    0.0     0.0  703.0\n2022-01-05    0.0  2040.0  304.0  3540.0    0.0\n```\n:::\n:::\n\n\nQuestion: Create a DataFrame called 'sales_data' that contains sales data for various products in different stores. Use the 'sales_data' and create DataFrames below.\n- \n\n::: {.cell execution_count=36}\n``` {.python .cell-code}\nimport pandas as pd\n\n# Create a dictionary of store sales data and a DataFrmae\ndata = {\n    'Store': ['A', 'B', 'C', 'A', 'B', 'C', 'A', 'B', 'C'],\n    'Products': ['X', 'Y', 'Z', 'X', 'Y', 'Z', 'X', 'Y', 'Z'],\n    'Sales': [1000, 1500, 1200, 2000, 1800, 2200, 1200, 1400, 1100]\n}\n\nsales_data = pd.DataFrame(data)\nprint(sales_data)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  Store Products  Sales\n0     A        X   1000\n1     B        Y   1500\n2     C        Z   1200\n3     A        X   2000\n4     B        Y   1800\n5     C        Z   2200\n6     A        X   1200\n7     B        Y   1400\n8     C        Z   1100\n```\n:::\n:::\n\n\n::: {.cell execution_count=37}\n``` {.python .cell-code}\n# Create a DataFrame called 'store_A_sales', \n# by selecting all the products sold in Store A\n\ncond = sales_data['Store'] == 'A'\nstore_A_sales = sales_data[cond]\nprint(store_A_sales)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  Store Products  Sales\n0     A        X   1000\n3     A        X   2000\n6     A        X   1200\n```\n:::\n:::\n\n\nCreate a DataFrame called 'high_sales_products' for rows where 'Sales' is greater than or equal to 1500. Use the DataFrame 'sales_data'. Display only 'Products' and 'Sales' columns.\n\n::: {.cell execution_count=38}\n``` {.python .cell-code}\n# Create a DataFrame indexing with Boolean values meeting the sales condition\nhigh_sales_products = sales_data.loc[sales_data['Sales'] >= 1500, ['Products', 'Sales']]\nprint(\"High sales products from store 'A'\\n\", high_sales_products)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nHigh sales products from store 'A'\n   Products  Sales\n1        Y   1500\n3        X   2000\n4        Y   1800\n5        Z   2200\n```\n:::\n:::\n\n\n### Dropping Entries from an Axis\nCreate a Series for the questions.\n\n::: {.cell execution_count=39}\n``` {.python .cell-code}\nimport pandas as pd\nimport numpy as np\n\nobj = pd.Series(np.arange(5.), index=list(\"abcde\"))\nprint(obj)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\na    0.0\nb    1.0\nc    2.0\nd    3.0\ne    4.0\ndtype: float64\n```\n:::\n:::\n\n\n###### **Question:** Drop single or multiple indexes - 'c' or 'c' and 'd' both from the Series.\n\n::: {.cell execution_count=40}\n``` {.python .cell-code}\nnew_obj = obj.drop('c')\nprint(new_obj)\nnew_obj = obj.drop(['c','d'])\nprint(new_obj)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\na    0.0\nb    1.0\nd    3.0\ne    4.0\ndtype: float64\na    0.0\nb    1.0\ne    4.0\ndtype: float64\n```\n:::\n:::\n\n\n###### Indexing and retrieving from DataFrame with a single value of sequence\n\n::: {.cell execution_count=41}\n``` {.python .cell-code}\nimport pandas as pd\nimport numpy as np\n\n# Create a DataFrame\ndata = pd.DataFrame(np.arange(16).reshape((4, 4)),\n                    index=[\"Ohio\", \"Colorado\", \"Utah\", \"New York\"],\n                    columns=[\"one\", \"two\", \"three\", \"four\"]\n)\nprint(data)\n\n# Drop 'Colorado' and 'Ohio', with a sequence of labels from the row labels (axis=0)\ndata2 = data.drop(index=['Colorado', 'Ohio'])\nprint(data2)\n\n# Drop the column 'two'\ndata2 = data.drop(columns = 'two')\nprint(data2)\n\n# Drop column(s) using axis parameter\ndata2 = data.drop(\"one\", axis=1)\nprint(data2)\ndata2 = data.drop([\"two\", \"four\"], axis=1)\nprint(data2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n          one  two  three  four\nOhio        0    1      2     3\nColorado    4    5      6     7\nUtah        8    9     10    11\nNew York   12   13     14    15\n          one  two  three  four\nUtah        8    9     10    11\nNew York   12   13     14    15\n          one  three  four\nOhio        0      2     3\nColorado    4      6     7\nUtah        8     10    11\nNew York   12     14    15\n          two  three  four\nOhio        1      2     3\nColorado    5      6     7\nUtah        9     10    11\nNew York   13     14    15\n          one  three\nOhio        0      2\nColorado    4      6\nUtah        8     10\nNew York   12     14\n```\n:::\n:::\n\n\n###### Indexing, Selection, and Filtering\n\n::: {.cell execution_count=42}\n``` {.python .cell-code}\nimport pandas as pd\nimport numpy as np\n\n# Create a Seriese\nobj = pd.Series(np.arange(4.), index=[\"a\",\"b\",\"c\",\"d\"])\nprint(obj)\n\n# Select using a label\nprint(obj[\"b\"])\n\n# Select using a integer index (like NumPy)\nprint(obj[1])\n\n# Select using a slice of integers (like NumPy)\nprint(obj[2:4])\n\n# Select using a sequence of labels\nprint(obj[[\"b\", \"a\" , \"d\"]])\n\n# Select using a list of integers\nprint(obj[[1, 3]])\n\n# Select using an array of Boolean values, condition\ncond = obj < 2\nprint(obj[cond]) # equivalent to obj[[obj < 2]]\n\n# Create Serieses\nobj1 = pd.Series([1, 2, 3], index=[2, 0, 1])\nobj2 = pd.Series([1, 2, 3], index=[\"a\", \"b\", \"c\"])\nprint(\"obj1\\n:\", obj1)\nprint(\"obj2\\n:\", obj2)\n\n# Prefer to use loc when selecting using labels\nprint(obj2.loc[[\"b\", \"a\", \"c\"]])\n#print(obj2.loc[[0, 1, 2]]) # error, not all indexes have matching labels\nprint(obj1.loc[[0, 1, 2]])\n\n# Use iloc for indexing with integers\nprint(obj1.iloc[[0, 1, 2]])\nprint(obj2.iloc[[0, 1, 2]]) # iloc always work with integer indexing\n\n# Slicing inclusive of endpoint\nprint(obj2.loc[\"b\":\"c\"]) # \"c\" label included for selection\nobj2.loc[\"b\":\"c\"] = 99 # modify values using label slicing\nprint(obj2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\na    0.0\nb    1.0\nc    2.0\nd    3.0\ndtype: float64\n1.0\n1.0\nc    2.0\nd    3.0\ndtype: float64\nb    1.0\na    0.0\nd    3.0\ndtype: float64\nb    1.0\nd    3.0\ndtype: float64\na    0.0\nb    1.0\ndtype: float64\nobj1\n: 2    1\n0    2\n1    3\ndtype: int64\nobj2\n: a    1\nb    2\nc    3\ndtype: int64\nb    2\na    1\nc    3\ndtype: int64\n0    2\n1    3\n2    1\ndtype: int64\n2    1\n0    2\n1    3\ndtype: int64\na    1\nb    2\nc    3\ndtype: int64\nb    2\nc    3\ndtype: int64\na     1\nb    99\nc    99\ndtype: int64\n```\n:::\n:::\n\n\n###### Indexing into a DataFrame retriving one or more columns with single value or sequence\n\n::: {.cell execution_count=43}\n``` {.python .cell-code}\nimport pandas as pd\nimport numpy as np\n\n# Create some state index and columns with random integer value, 4x4\ndata = pd.DataFrame(np.arange(16).reshape(4, 4), \n                    index=[\"Ohio\", \"Colorado\", \"Utah\", \"New York\"],\n                    columns=[\"one\", \"two\", \"three\", \"four\"]\n)\nprint(data)\nprint(data.index)\nprint(data.columns)\n\n# Select with a single or sequence\nprint(data[\"one\"]) # single column \"one\"\nprint(data[[\"three\", \"two\"]]) # multiple columns - three, \n\n# Select with slicing\nprint(data[:2])  # select row index at 0, 1\n\n# Select / assign using Boolean array\ncond = data[\"three\"] > 5\nprint(\"cond:\\n\", cond, type(cond)) # return a Series\nprint(data[cond])\ncond = data < 5\nprint(\"cond\\n\", cond, type(cond)) # return a DF\nprint(data[cond])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n          one  two  three  four\nOhio        0    1      2     3\nColorado    4    5      6     7\nUtah        8    9     10    11\nNew York   12   13     14    15\nIndex(['Ohio', 'Colorado', 'Utah', 'New York'], dtype='object')\nIndex(['one', 'two', 'three', 'four'], dtype='object')\nOhio         0\nColorado     4\nUtah         8\nNew York    12\nName: one, dtype: int32\n          three  two\nOhio          2    1\nColorado      6    5\nUtah         10    9\nNew York     14   13\n          one  two  three  four\nOhio        0    1      2     3\nColorado    4    5      6     7\ncond:\n Ohio        False\nColorado     True\nUtah         True\nNew York     True\nName: three, dtype: bool <class 'pandas.core.series.Series'>\n          one  two  three  four\nColorado    4    5      6     7\nUtah        8    9     10    11\nNew York   12   13     14    15\ncond\n             one    two  three   four\nOhio       True   True   True   True\nColorado   True  False  False  False\nUtah      False  False  False  False\nNew York  False  False  False  False <class 'pandas.core.frame.DataFrame'>\n          one  two  three  four\nOhio      0.0  1.0    2.0   3.0\nColorado  4.0  NaN    NaN   NaN\nUtah      NaN  NaN    NaN   NaN\nNew York  NaN  NaN    NaN   NaN\n```\n:::\n:::\n\n\n###### Selection on DataFrame with `loc` and `iloc`\n\n::: {.cell execution_count=44}\n``` {.python .cell-code}\nprint(data)\n\n# loc with labels\nprint(data.loc[\"Colorado\"]) # Series\nprint(data.loc[[\"Colorado\", \"New York\"]]) # DF\nsel = data.loc[\"Colorado\", [\"two\", \"three\"]] # Series\nprint(sel)\nprint(type(sel))\n\n# iloc with integers\nprint(data.iloc[2]) # Series\nprint(data.iloc[[2, 1]]) # two rows, DF\nprint(data.iloc[2, [2, 1]]) # row + columns, Series\nprint(data.iloc[[1, 2], [3, 0, 1]]) # rows + columns, DF\n\n# Slicing\nprint(data.loc[:\"Utah\", \"two\"]) # slicing using row and colum labels at once\nprint(data.iloc[:, :3][data.three >= 2])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n          one  two  three  four\nOhio        0    1      2     3\nColorado    4    5      6     7\nUtah        8    9     10    11\nNew York   12   13     14    15\none      4\ntwo      5\nthree    6\nfour     7\nName: Colorado, dtype: int32\n          one  two  three  four\nColorado    4    5      6     7\nNew York   12   13     14    15\ntwo      5\nthree    6\nName: Colorado, dtype: int32\n<class 'pandas.core.series.Series'>\none       8\ntwo       9\nthree    10\nfour     11\nName: Utah, dtype: int32\n          one  two  three  four\nUtah        8    9     10    11\nColorado    4    5      6     7\nthree    10\ntwo       9\nName: Utah, dtype: int32\n          four  one  two\nColorado     7    4    5\nUtah        11    8    9\nOhio        1\nColorado    5\nUtah        9\nName: two, dtype: int32\n          one  two  three\nOhio        0    1      2\nColorado    4    5      6\nUtah        8    9     10\nNew York   12   13     14\n```\n:::\n:::\n\n\n###### Arithmetic and Data Alignment with Series and DataFrame\n\n::: {.cell execution_count=45}\n``` {.python .cell-code}\nimport pandas as pd\nimport numpy as np\n\n# Create two Serieses with different number of data and labels\ns1 = pd.Series([7.3, -2.5, 3.4, 1.5], index=[\"a\", \"c\", \"d\", \"e\"])\ns2 = pd.Series([-2.1, 3.6, -1.5, 4, 3.1], index=[\"a\", \"c\", \"e\", \"f\", \"g\"])\nprint(s1)\nprint(s2)\n\n# s1 + s2, result with the union of the index pairs and data alignment\nprint(s1 + s2)\n\n# Create two DataFrames - 3x3 / 4x3\ndf1 = pd.DataFrame(np.arange(9.).reshape((3, 3)), columns=list(\"bcd\"), index=[\"Ohio\", \"Texas\", \"Colorado\"])\ndf2 = pd.DataFrame(np.arange(12.).reshape((4, 3)), columns=list(\"bde\"), index=[\"Utah\", \"Ohio\", \"Texas\", \"Oregon\"])\nprint(df1)\nprint(df2)\n\n# df1 + df2 , Union of index pairs and data alignment\nprint(df1+df2)\n\n# Case of DataFrames with no rows or columns in common\ndf1 = pd.DataFrame({\"A\": [1, 2]})\ndf2 = pd.DataFrame({\"B\": [3, 4]})\nprint(df1)\nprint(df2)\nprint(df1+df2)\n\n# Practice to fill missing value(NaN, null) with sepcific value during arithmetic operations\n\n# Create DataFrames with different shapes, with data not in common and null\ndf1 = pd.DataFrame(np.arange(12.).reshape((3, 4)), columns=list(\"abcd\"))\ndf2 = pd.DataFrame(np.arange(20.).reshape((4, 5)), columns=list(\"abcde\"))\n\n# Set null for the value at 1, \"b\" in df2\ndf2.loc[1, \"b\"] = np.nan\n\nprint(\"df1: \", df1)\nprint(\"df2: \", df2)\n\n# addtion and missing values\nprint(df1 + df2)\n\n# add() method and fill_value argument to substitute missing values during arithmetic operations.\nprint(df1.add(df2, fill_value=0))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\na    7.3\nc   -2.5\nd    3.4\ne    1.5\ndtype: float64\na   -2.1\nc    3.6\ne   -1.5\nf    4.0\ng    3.1\ndtype: float64\na    5.2\nc    1.1\nd    NaN\ne    0.0\nf    NaN\ng    NaN\ndtype: float64\n            b    c    d\nOhio      0.0  1.0  2.0\nTexas     3.0  4.0  5.0\nColorado  6.0  7.0  8.0\n          b     d     e\nUtah    0.0   1.0   2.0\nOhio    3.0   4.0   5.0\nTexas   6.0   7.0   8.0\nOregon  9.0  10.0  11.0\n            b   c     d   e\nColorado  NaN NaN   NaN NaN\nOhio      3.0 NaN   6.0 NaN\nOregon    NaN NaN   NaN NaN\nTexas     9.0 NaN  12.0 NaN\nUtah      NaN NaN   NaN NaN\n   A\n0  1\n1  2\n   B\n0  3\n1  4\n    A   B\n0 NaN NaN\n1 NaN NaN\ndf1:       a    b     c     d\n0  0.0  1.0   2.0   3.0\n1  4.0  5.0   6.0   7.0\n2  8.0  9.0  10.0  11.0\ndf2:        a     b     c     d     e\n0   0.0   1.0   2.0   3.0   4.0\n1   5.0   NaN   7.0   8.0   9.0\n2  10.0  11.0  12.0  13.0  14.0\n3  15.0  16.0  17.0  18.0  19.0\n      a     b     c     d   e\n0   0.0   2.0   4.0   6.0 NaN\n1   9.0   NaN  13.0  15.0 NaN\n2  18.0  20.0  22.0  24.0 NaN\n3   NaN   NaN   NaN   NaN NaN\n      a     b     c     d     e\n0   0.0   2.0   4.0   6.0   4.0\n1   9.0   5.0  13.0  15.0   9.0\n2  18.0  20.0  22.0  24.0  14.0\n3  15.0  16.0  17.0  18.0  19.0\n```\n:::\n:::\n\n\n",
    "supporting": [
      "p4da3d-pandas_files"
    ],
    "filters": [],
    "includes": {
      "include-in-header": [
        "<script src=\"https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js\" integrity=\"sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==\" crossorigin=\"anonymous\"></script>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js\" integrity=\"sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==\" crossorigin=\"anonymous\"></script>\n<script type=\"application/javascript\">define('jquery', [],function() {return window.jQuery;})</script>\n"
      ]
    }
  }
}